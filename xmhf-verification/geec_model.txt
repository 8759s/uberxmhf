GEEC model (in text)
author: amit vasudevan (amitvasudevan@acm.org)


Notes:
    1. l_xxx => local variable
    2. g_xxx => global variable
    3. hw.xxx => hardware component/state variable

//////
// geec prime (gp)
//////


g_stack[1..MAX_CPUS][MAX_STACKSIZE];
	1. Entrystub:
		a. Cpuid = hw.lapic.id;
		b. hw.cpu.esp = stack[cpuid];
		c. Call slab_main
		d. Halt

entrystub {
    l_cpuid = hw.lapic.id;
    hw.cpu.esp = g_stack[cpuid];
	slab_main();
    halt();
}







Geec_prime:
	2. Slab_main:
		a. Setup temporary unity mapped page-tables
			i. For all slabs, slabcode=ro, slabdata=rw, slabstack=rw, slabdmadata=rw
			ii. Rest of system memory "rw"
			iii. Hw.cpu.msr_efer |= NX
			iv. Hw.cpu.cr4 |= PAE, PSE
			v. Hw.cpu.cr3 = temporary_unity_mapped_table_base
			vi. Hw.cpu.cr0 |= PG
		b. Sanity check hw requirements
		c. Setup slab device allocations
			i. Sysdevlist = Initialize system bus and enumerate devices
			ii. Setup slabdevicemap based on sinfotable[].deviceallocation
			iii. Devtablebase = Call_slab(uapi_devpgtbl, DEVPGTBL_INIT);
			iv. For all slabs: call_slab(uapi_devpgtbl, DEVPGTBL_INITTBL);
			v. Initialize IOMMU
				1) Hw.iommu.base = devtablebase
				2) Hw.iommu.translationenable = true
			vi. For all devices in sysdevlist
				1) If getslabfordevice(device)
					a) Call_slab(uapi_devpgtbl, DEVPGTBL_BINDDEVICE)
		d. Setup (unverified) slab iotbl
			i. For slab = I to totslab
				1) If sinfotable[slab].type == unverified or unverified guest
					a) Call_slab(uapi_iotbl, IOTBL_INIT)
					b) For all device in slabdevicemap
						i) Call_slab(uapi_iotbl, IOTBL_ALLOWACCESS, port)
		e. Setup slab memory page tables
			i. Setup_slab_mem_page_tables
				1) Call_slab(uapi_mempgtbl, MEMPGTBL_INITTABLE, GEEC_PRIME)
				2) Populate page tables (GEEC_PRIME)
				3) For slabid in 1â€¦totalslabs
					a) If sinfotable[slabid].type == unverified or unverified guest
						i) Call_Slab(uapi_mempgtbl, MEMPGTBL_INITTABLE)
						ii) Populate page tables (slabid)
			ii. Populate_page_tables (slabid)
				1) Slabtype = sinfotable[slabid].type;
				2) For(spa=0; spa < ADDR_4GB; spa += PAGE_SIZE_4K){
					a) Spa_slabregion, spa_slabtype, spa_sameslab = getspatype(slabid, spa);
					b) Flags = getflagsforspa(slabid, spa_slabregion, spa_slabtype, spa_sameslab)
					c) If spa_slabregion == REGION_IOTBL && slabtype != verified
						i) Call_slab(uapi_mempgtbl, MEMPGTBL_SETENTRYFORPADDR, spa, sinfotable[slabid].iotbl_base, flags
					d) Else
						i) Call_slab(uapi_mempgtbl, MEMPGTBL_SETENTRYFORPADDR, spa, spa, flags
				3) }
			iii. Getspatype(slabid, spa)
				1) For I in 1..totslab
					a) If spa in iotbl[] return REGION_IOTBL
					b) If spa in slabdevicemap[i].mmioregions return REGION_DEVMMIO
					c) If spa in sinfotable[slabid].codeextents return REGION_CODE
					d) If spa in sinfotable[slabid].dataextents return REGION_DATA
					e) If spa in sinfotable[slabid].stackextents return REGION_STACK
					f) If spa in sinfotable[slabid].dmadataextents return REGION_DMADATA
					g) Else
					h) REGION_OTHER
				2) Return region, sinfotable[i].type
			iv. Getflagsforspa(slabid, spa_slabregion, spa_slabtype, spa_sameslab)
				1) Switch(sinfotable[slabid].slabtype)
					a) Case verified:
						i) REGION_OTHER = p, rw, super
						ii) If sameslab || spa_slabtype == verified
							One. REGION_CODE = p, ro, super
							Two. REGION_{DATA,STACK,DMADATA} = p, rw, nx, super
							Three. REGION_MMIO = p, rw, nx, pcd, super
						iii) Else
							One. Flags = p, rw, nx, super
					b) Case unverified
						i) REGION_OTHER = p, rw, nx, super
						ii) If sameslab || spa_labtype == verified
							One. REGION_CODE = p, ro, super
							Two. REGION_{DATA,STACK,DMADATA} = p, rw, nx, super
							Three. REGION_MMIO = p, rw, nx, pcd, super
							Four. If sameslab flags |= user
						iii) Else
							One. Flags = p, rw, nx, super
					c) Case unverified guest
						i) If sameslab  && spa_slabregion != REGION_OTHER
							One. CODE = p, rw
							Two. DATA,STACK,DMADATA = p, rw
						ii) Else
							One. Flags =0
				2) Return flags
		f. Cpu.hw.cr3 = sinfotable[GEEC_PRIME].mempgtbl_base
		g. Setup cpu state and replicate
			i. Initialize GDT
				1) TSS desc[1..maxcpus] = iotbl[1..maxcpus]
			ii. Initialize IDT
				1) IDT_desc[1..maxexceptions] = sinfotable[GEEC_SENTINEL].memoffets[2..maxexceptions+2]
			iii. Initialize TSS
			iv. Replicate_cr3 = hw.cpu.cr3;
			v. Replicate_cr4 = hw.cpu.cr4;
			vi. Replicate_msfefer = hw.cpu.msrefer;
			vii. Replicate_cr0 = hw.cpu.cr0;
			viii. Hw.lapic.command_register |= WAKE_APS at common_state
			ix. common_state()
		h. Common_state
			i. Cpuid = hw.lapic.id;
			ii. hw.cpu.esp = stack[cpuid];
			iii. Hw.cpu.cr3 = replicate_cr3;
			iv. Hw.cpu.cr4 = replicate_cr4;
			v. Hw.cpu.cr0 = replicate_cr0;
			vi. Setup vmcs state
				1) Call_slab(uapi_cpustate, VMCSREAD,VMCSWRITE,RDMSR,WRMSR)
			vii. Hw.cpu.vmxon = true
			viii. Hw.cpu.vmcsbase = sinfotable[UAPI_CPUSTATE].memoffsets[0];
			ix. Hw.cpu.sysenterhandler = sinfotable[GEEC_SENTINEL].memoffsets[0];
			x. Hw.cpu.vmexithandler = sinfotable[GEEC_SENTINEL].memoffsets[1];
			xi. Call_slab(init_slab, 0);
			xii. halt
	3. outputp[1..n] Call_slab(callee, callee_fn, inputp[1..m]):
			i. New iparams, oparams
			ii. Iparams.caller=GEEC_PRIME;
			iii. Iparams.callee=callee;
			iv. Iparams.callee_fn = callee_fn;
			v. Iparams.inputp = inputp;
			vi. Verifiedslab_call_sentinel_stub (iparams, oparams)
			vii. Return oparams
	4. Verifiedslab_call_sentinel_stub(iparams, oparams)
		a. Iparams.ctype = CALL_FROM_VERIFIED
		b. caller_stackframe = current stack frame
		c. Verified_ep(caller_stackframe)
