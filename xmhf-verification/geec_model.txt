GEEC model (in text)
author: amit vasudevan (amitvasudevan@acm.org)


Notes:
    1. l_xxx => local variable
    2. g_xxx => global variable
    3. hw.xxx => hardware component/state variable
	4. Verified (hypervisor), unverified (hypervisor) and unverified guest slabs
	5. Call-return pairings supported
		a. Verified to verified one-way/roundtrip (CALL_FROM_VERIFIED, implicit return)
		b. Verified to unverified roundtrip (CALL_FROM_VERIFIED, RET_TO_VERIFIED)
		c. Unverified to verified roundtrip (CALL_FROM_UNVERIFIED, RET_TO_UNVERIFIED)
		d. Verified to unverified guest one-way (CALL_FROM_VERIFIED)
		e. signal to verified roundtrip (CALL_SIGNAL, RET_SIGNAL)
		f. Signal-guest to verified roundtrip (CALL_SIGNALGUEST, RET_SIGNALGUEST)
	6. Geec_Prime, geec_sentinel ==> verified geec slabs
	7. Init, signal, signal-guest, uapi(mempgtbl,iotbl,devpgtbl,cpustate) slabs ==> verified slabs required by geec for XMHF as the consumer
		a. init = gets control from prime after initialization,
		b. signal = gets control on any interrupt/exception during hypervisor slab execution,
		c. signal-guest = gets control on any intercept in guest slab execution
		d. Uapi (mempgtbl,iotbl,devpgtbl,cpustate) = uapi slabs controlling memory page tables, io table, device pagetable and cpu state resource access respectively



//=============================================================================
//
// constants, type definitions and global input data
//
//=============================================================================


////// constants
MAX_CPUS = max. no. of platform cpus
MAX_STACKSIZE = size of stack in bytes
ADDR_4GB_PAGES = (0x100000000ULL/0x1000) = max. 4K pages in 4GB memory address space
PAGES(memextent) = memory page range (x..y) for a given memory extent (memextent)
ADDRS(memextent) = memory address range (mx..my) for a given memory extent (memextent)

////// type defs
type oparams = byte [];
type iparams = byte [];
type siparams = {
    .ctype;
    .caller;
    .callee;
    .param_buf
}

type soparams = {
    .param_buf
}

////// global input data
g_totalslabs;
g_sinfotable[1..g_totalslabs]{
    .s_type (s_verified, s_unverified, s_unverified_guest);
    .s_codeextents;
    .s_dataextents;
    .s_stackextents;
    .s_dmadataextents;
    .s_deviceallocations;
    .s_iotblbase;
    .s_mempgtblbase;
}


//=============================================================================
//
// Initialization phase
//
//
//                                     +-----------------------------------+
//                                     |                                   |
//                 +-----------------<>| uapi_slabs{V}{mempgtbl,devpgtbl,  |
//                 |                   | iotbl,cpustate}                   |
//                 |                   |                                   |
//                 |                   +-----------------------------------+
//                 |
//        +--------------------+             +--------------+
// []-----| geec_prime_slab{V} |------------>| init_slab{V} |
//        +--------------------+             +--------------+
//
//
// -----> control transfer initiated by slab with geec_sentinel enforced one-way call
// ----<> control transfer initiated by slab with geec_sentinel enforced roundtrip call
// []---- one-way control transfer initiated and enforced by hardware
//
//=============================================================================

gp_entry_stub();







//=============================================================================
//
// Runtime phase
//
//
//       +----------------------+                     +---------------------+<>---+
// []--<>| signal_guest_slab{V} |--------+----------<>|                     |-----+
//       +----------------------+        |            | verified_slabs{...} |----------+
//                                       |            |                     |--------+ |
//           +----------------+          |     +----<>|                     |----+   | |
// []------<>| signal_slab{V} |----------+     |      +---------------------+    |   | |
//           +----------------+                |                                 |   | |
//                                             |                                 |   | |
//                                  +----------+    +-----------------------+    |   | |
//                                  |               |                       |<>--+   | |
//                                  +-------------<>| unverified_slabs{...} |----+   | |
//                                  |               +-----------------------+    |   | |
//                                  |                                            |   | |
//                                  |                                            |   | |
//                                  |   +-----------------------------------+    |   | |
// from       +--------------+      |   |                                   |<>--+   | |
// prime  --->+ init_slab{V} |------+-<>| uapi_slabs{V}{mempgtbl,devpgtbl,  |<>------+ |
//            +--------------+      |   | iotbl,cpustate,...}               |          |
//                                  |   |                                   |          |
//                                  |   +-----------------------------------+          |
//                                  |                                                  |
//                                  |        +------------------------------+          |
//                                  +------->| unverified_guest_slabs{...}  |<---------+
//                                           +------------------------------+
//
//
// -----> control transfer initiated by slab with geec_sentinel enforced one-way call
// ----<> control transfer initiated by slab with geec_sentinel enforced roundtrip call
// []--<> control transfer initiated by hardware with geec_sentinel enforced roundtrip call
//
//
//=============================================================================

thread_verifiedslab(INIT_SLAB);




//////
// geec prime (gp)
//////


g_stack[0..MAX_CPUS-1][MAX_STACKSIZE];
g_temp_mempgtbl[0..ADDR_4GB_PAGES]{
    .addr;
    .flags (f_readwrite, f_readonly, f_noexecute, f_present, f_super, f_user);
};
g_sysdevlist; //list of system devices
g_sysdevlist_count; //count of system devices
g_iotbl[0..MAXCPUS-1][MAX_IOTBLSIZE];
g_slabdevicemapping[0..g_totalslabs-1];

gp_entrystub {
    l_cpuid = hw.lapic.id;
    hw.cpu.esp = g_stack[cpuid];
	gp_slab_main();
    halt();
}


gp_slab_main {
    //setup temporary unity mapped page-tables
    gp_setup_temp_mempgtbl();

    //sanity check hw requirements
    gp_sanitycheck_hw_requirements();

    //setup slab device allocations
    gp_setup_slab_device_allocations();

    //setup slab memory page tables
    gp_setup_slab_mempgtbl();

	//load verified slabs' memory page table
	hw.cpu.cr3 = g_sinfotable[GEEC_PRIME].s_mempgtblbase;

    //setup cpu state and transfer control to init slab
    gp_setup_cpustate_and_replicate();

    halt();
}


//setup temporary unity mapped page-tables
gp_setup_temp_pagetables {
    for (l_i=0; l_i < g_totalslabs; l_i++){
        g_temp_mempgtbl[PAGES(sinfotable[l_i].codeextents)].addr = ADDRS(sinfotable[l_i].codeextents);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].codeextents)].flags = (f_present | f_readonly | f_super);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].dataextents)].addr = ADDRS(sinfotable[l_i].dataextents);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].dataextents)].flags = (f_present | f_readwrite | f_noexecute | f_super);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].stackextents)].addr = ADDRS(sinfotable[l_i].stackextents);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].stackextents)].flags = (f_present | f_readwrite | f_noexecute | f_super);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].dmadataextents)].addr = ADDRS(sinfotable[l_i].stackextents);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].dmadataextents)].flags = (f_present | f_readwrite | f_noexecute | f_super);
    }

    g_temp_mempgtbl[PAGES(~sinfotable[0..(g_totalslabs-1)].{code,data,stack,dmadata}extents)].addr = ADDRS(~sinfotable[0..(g_totalslabs-1)].{code,data,stack,dmadata}extents);
    g_temp_mempgtbl[PAGES(~sinfotable[0..(g_totalslabs-1)].{code,data,stack,dmadata}extents)].flags = (f_present | f_readwrite | f_noexecute | f_super);

    hw.cpu.msr_efer |= NX;
    hw.cpu.cr4 |= PAE, PSE;
	hw.cpu.cr3 = g_temp_mempgtbl;
    hw.cpu.cr0 |= PG;
}


//setup slab device allocations
gp_setup_slab_device_allocations {
    //enumerate system devices and setup g_sysdevlist and g_sysdevlist_count
    gp_enumerate_system_devices();

    //setup slab device mappings based on system devices and individual slab device allocations
    for(l_i=0; l_i < g_totalslabs; l_i++){
        g_slabdevicemapping[l_i] = gp_getslabdevicemapping(g_sysdevlist, g_sinfotable[l_i].deviceallocations);
    }
    l_iommutablebase = gp_call_slab(UAPI_DEVPGTBL, UAPI_DEVPGTBL_INIT);

	//iv. For all slabs: call_slab(uapi_devpgtbl, DEVPGTBL_INITTBL);
    for(l_i=0; l_i < g_totalslabs; l_i++){
        gp_call_slab(UAPI_DEVPGTBL, UAPI_DEVPGTBL_INITTABLE, l_i);
    }

    //v. Initialize IOMMU
    hw.iommu.tablebase = l_iommutablebase;
	hw.iommu.translationenable = true

	for(l_i=0; l_i < g_sysdevlist_count; l_i++){
        if( (l_slabid = gp_getslabid_for_device(g_sysdevlist[l_i])) in 0..g_totalslabs ) {
            gp_call_slab(UAPI_DEVPGTBL, UAPI_DEVPGTBL_BINDDEVICE, l_slabid, g_sysdevllist[l_i]);
        }
	}
}

//setup (unverified) slab legacy I/O table
gp_setup_slab_iotbl {

    for(l_i=0; l_i < g_totalslabs; l_i++){
        if(g_sinfotable[l_i].s_type == s_unverified || s_unverified_guest){
            gp_call_slab(UAPI_IOTBL, UAPI_IOTBL_INIT, l_i);
            for(l_k=0; l_k <  g_slabdevicemapping[l_i].devcount; l_k++){
                gp_call_slab(UAPI_IOTBL, UAPI_IOTBL_ALLOWACCESSTOPORT, l_i, g_slabdevicemapping[l_i].device[l_k].ports);
            }
        }
    }

}


oparams gp_call_slab(callee, callee_fn, iparams){
    l_soparams, l_siparams;

    l_siparams.caller = GEEC_PRIME;
    l_siparams.callee = callee;
    l_siparams.callee_fn = callee_fn;
    l_siparams.parambuf = iparams;

    call_sentinel(ls_iparams, l_soparams);

    return l_soparams.parambuf;
}


gp_call_sentinel (siparams, soparams) {
    siparams.ctype = CALL_FROM_VERIFIED;
    l_caller_stackframe = current stack frame;
	geec_sentinel_verified_ep(l_caller_stackframe);
}



gp_setup_slab_mempgtbl {

    gp_call_slab(UAPI_MEMPGTBL, UAPI_MEMPGTBL_INITTABLE, GEEC_PRIME);
    gp_setup_slab_mempgtbl_populate_pt(GEEC_PRIME);
    for(l_i=0; l_i < g_totalslabs; l_i++){
        if( g_sinfotable[l_i].s_type == s_unverified || s_unverified_guest ){
            gp_call_slab(UAPI_MEMPGTBL, UAPI_MEMPGTBL_INITTABLE, l_i);
            gp_setup_slab_mempgtbl_populate_pt(l_i);
        }
    }
}

gp_setup_slab_mempgtbl_populate_pt (slabid) {

    l_slabtype = g_sinfotable[slabid].s_type;
    for(l_spa=0; l_spa < ADDR_4GB; l_spa += PAGE_SIZE_4K){
        l_spa_slabregion, l_spa_slabtype, l_spa_sameslab = gp_setup_slab_mempgtbl_getspatype(slabid, l_spa);
        l_flags = gp_setup_slab_mempgtbl_getflagsforspa(slabid, l_spa_slabregion, l_spa_slabtype, l_spa_sameslab);
        if( l_spa_slabregion == REGION_IOTBL && l_slabtype != s_verified)
            gp_call_slab(UAPI_MEMPGTBL, UAPI_MEMPGTBL_SETENTRYFORPADDR, l_spa, g_sinfotable[slabid].s_iotblbase, l_flags);
        else
            gp_call_slab(UAPI_MEMPGTBL, UAPI_MEMPGTBL_SETENTRYFORPADDR, l_spa, l_spa, l_flags);
    }

}


gp_setup_slab_mempgtbl_getspatype(slabid, spa) {

   for(l_i=0; l_i < g_totalslabs; l_i++){
    switch (spa) {
        case spa in g_iotbl[]:
            return REGION_IOTBL, s_not_a_slab, false;
        case spa in g_slabdevicemapping[l_i].device[0..devcount].mmioregions:
            return REGION_DEVMMIO, sinfotable[l_i].s_type, ((l_i == slabid) ? true : false);
        case spa in g_sinfotable[l_i].codeextents
            return REGION_CODE, sinfotable[l_i].s_type, ((l_i == slabid) ? true : false);
        case spa in g_sinfotable[l_i].dataextents
            return REGION_DATA, sinfotable[l_i].s_type, ((l_i == slabid) ? true : false);
        case spa in g_sinfotable[l_i].stackextents
            return REGION_STACK, sinfotable[l_i].s_type, ((l_i == slabid) ? true : false);
        case spa in g_sinfotable[l_i].dmadataextents
            return REGION_DMADATA, sinfotable[l_i].s_type, ((l_i == slabid) ? true : false);
        default
            return REGION_OTHER, s_not_a_slab, false;
    }
   }

}


gp_setup_slab_mempgtbl_getflagsforspa(slabid, spa_slabregion, spa_slabtype, spa_sameslab) {
    l_flags=0;

    switch(g_sinfotable[slabid].s_type){
        case s_verified:
            if(spa_slabregion == REGION_OTHER){
                l_flags = f_present + f_readwrite + f_super;
            }else{
                if(spa_sameslab || spa_slabtype == s_verified){
                    switch(spa_slabregion){
                        case REGION_CODE:
                            l_flags = f_present + f_readonly + f_super;
                        case REGION_DATA:
                        case REGION_STACK:
                        case REGION_DMADATA:
                            l_flags = f_present + f_readwrite + f_noexecute + f_super;
                        case REGION_MMIO:
                            l_flags = f_present + f_readwrite + f_noexecute + f_super;
                    }
                }else{
                    l_flags = f_present + f_readwrite + f_noexecute + f_super;
                }
            }
            break;

        case s_unverified:
            if(spa_slabregion == REGION_OTHER){
                l_flags = f_present + f_readwrite + f_super;
            }else{
                if(spa_sameslab || spa_slabtype == s_verified){
                    switch(spa_slabregion){
                        case REGION_CODE:
                            l_flags = f_present + f_readonly + f_super;
                        case REGION_DATA:
                        case REGION_STACK:
                        case REGION_DMADATA:
                            l_flags = f_present + f_readwrite + f_noexecute + f_super;
                        case REGION_MMIO:
                            l_flags = f_present + f_readwrite + f_noexecute + f_super;
                    }

                    if(spa_sameslab) l_flags += f_user;
                }else{
                    l_flags = f_present + f_readwrite + f_noexecute + f_super;
                }
            }
            break;

        case s_unverified guest:
            if(spa_sameslab && spa_slabregion != REGION_OTHER){
                l_flags = f_present + f_readwrite;
            }else{
                l_flags =0;
            }
            break;
    }

   return l_flags;
}


gp_setup_cpustate_and_replicate {
    //initialize GDT
    g_gdt[code_desc0] = code_32bit_ring0;
    g_gdt[data_desc0] = data_32bit_ring0;
    g_gdt[sysentercode_desc0] = code_32bit_ring0;
    g_gdt[sysenterdata_desc0] = data_32bit_ring0;
    g_gdt[sysentercode_desc3] = code_32bit_ring3;
    g_gdt[sysenterdata_desc3] = data_32bit_ring3;
    g_gdt[tssdesc_cpu0..tssdesc_cpu(maxcpus-1)] = g_tss[0..(maxcpus-1)];

    //initialize TSS
    g_tss[0..(maxcpus-1)].ss0 = data_desc0;
    g_tss[0..(maxcpus-1)].esp0 = g_tsstack[0..(maxcpus-1)];
    g_tss[0..(maxcpus-1)].iobitmap = g_iotbl[0..(maxcpus-1)];

    //initialize IDT
    g_idt[0..maxexceptions-1] = g_sinfotable[GEEC_SENTINEL].memoffets[2..(maxexceptions-1)+2]

    g_replicate_cr3 = hw.cpu.cr3;
    g_replicate_cr4 = hw.cpu.cr4;
    g_replicate_msrefer = hw.cpu.msrefer;
    g_replicate_cr0 = hw.cpu.cr0;

    hw.lapic.command_register |= WAKE_APS at gp_common_state

    gp_common_state();

    halt();
}


gp_common_state {

    l_cpuid = hw.lapic.id;
    hw.cpu.esp = g_stack[cpuid];
    hw.cpu.cr3 = g_replicate_cr3;
    hw.cpu.cr4 = g_replicate_cr4;
    hw.cpu.cr0 = g_replicate_cr0;

    setup unverified_guest_slab VMCS support via:
    gp_call_slab(UAPI_CPUSTATE, UAPI_CPUSTATE_VMREAD);
    gp_call_slab(UAPI_CPUSTATE, UAPI_CPUSTATE_VMWRITE);
    gp_call_slab(UAPI_CPUSTATE, UAPI_CPUSTATE_RDMSR);
    gp_call_slab(UAPI_CPUSTATE, UAPI_CPUSTATE_WRMSR);

    hw.cpu.vmxon = true
    hw.cpu.vmcsbase = g_sinfotable[UAPI_CPUSTATE].memoffsets[0];
    hw.cpu.sysenterhandler = g_sinfotable[GEEC_SENTINEL].memoffsets[0];
    hw.cpu.sysenterstack = g_sysenterstack[cpuid];
    hw.cpu.vmexithandler = g_sinfotable[GEEC_SENTINEL].memoffsets[1];

    gp_call_slab(INIT_SLAB, 0);

    halt();

}





//////
// slab threads
//////

Thread_verifiedslab(slabid):
	1. Choose instruction execution from below
	2. Entrystub (caller_stack_frame):
		a. Iparams = extract iparams from caller_stack_frame
		b. Oparams = extract oparams from caller_stack_frame
		c. Call slab_main(iparams, oparams)
		d. Ctype = extract ctype from iparams
		e. If ctype == CALL_FROM_VERIFIED
			i. Restore caller registers from caller_stack_frame
			ii. Resume caller via RET instruction
			iii. Halt

		f. If ctype == CALL_FROM_UNVERIFIED
			i. Iparams.ctype = RET_TO_UNVERIFIED
			ii. Swap iparams.caller and iparams.callee
			iii. Sentinel_verifiedep(caller_stackframe)
			iv. Halt

		g. If ctype == CALL_EXCEPTION
			i. Iparams.ctype = RET_EXCEPTION
			ii. Swap iparams.caller and iparams.callee
			iii. Sentinel_verifiedep(caller_stackframe)
			iv. Halt

		h. If ctype == CALL_INTERCEPT
			i. Iparams.ctype = RET_INTERCEPT
			ii. Swap iparams.caller and iparams.callee
			iii. Sentinel_verifiedep(caller_stackframe)
			iv. Halt


	3. Slab_main(iparams, oparams):
		a. Choose either call_other_slabs or return_from_slab
		b. Call_other_slabs:
			i. Select callee_slabid in sinfotable[slabid].callee_slabs
			ii. Select callee_fn in sinfotable[slabid].callee_fn[callee_slabid]
			iii. New iparams, oparams
			iv. Iparams.caller=slabid;
			v. Iparams.callee=callee_slabid;
			vi. Iparams.callee_fn = callee_fn;
			vii. Verifiedslab_call_sentinel_stub (iparams, oparams)
		c. Return_from_slab:
			i. return

	3. Verifiedslab_call_sentinel_stub(iparams, oparams)
		a. Iparams.ctype = CALL_FROM_VERIFIED
		b. caller_stackframe = current stack frame
		c. Verified_ep(caller_stackframe)



Thread_unverifiedslab(slabid):
	1. Choose between instruction execution and exception; if instruction execution it is one of the below
	2. Entrystub (caller_stack_frame):
		a. Iparams = extract iparams from caller_stack_frame
		b. Oparams = extract oparams from caller_stack_frame
		c. Call slab_main(iparams, oparams)
		d. Iparams.ctype = RET_TO_VERIFIED
		e. Swap iparams.caller and iparams.callee
		f. Sentinel_unverifiedep(caller_stackframe)
		g. halt

	3. Slab_main(iparams, oparams):
		a. Choose either call_other_slabs or return_from_slab
		b. Call_other_slabs:
			i. Select callee_slabid in sinfotable[slabid].callee_slabs
			ii. Select callee_fn in sinfotable[slabid].callee_fn[callee_slabid]
			iii. New iparams, oparams
			iv. Iparams.caller=slabid;
			v. Iparams.callee=callee_slabid;
			vi. Iparams.callee_fn = callee_fn;
			vii. unverifiedslab_call_sentinel_stub (iparams, oparams)
		c. Return_from_slab:
			i. return

	3. unverifiedslab_call_sentinel_stub(iparams, oparams)
		a. Iparams.ctype = CALL_FROM_UNVERIFIED
		b. Save caller saved registers on stack
		c. caller_stackframe = current stack frame (with caller saved registers)
		d. Sentinel_unverifiedep(caller_stackframe)


Thread_unverifiedguestslab(slabid):
	1. Choose between instruction execution and #INTERCEPT




//=============================================================================
//
// geec sentinel
//
//=============================================================================

Verified_ep (caller_stackframe):
	1. Save caller saved registers on stack
	2. Caller_stackframe = stack frame with caller saved registers
	3. Iparams = extract iparams from caller_stackframe
	4. Cpuid = current cpu id
	5. Common_ep (cpuid, iparams.ctype, iparams.caller, iparams.callee, caller_stackframe)

Unverified_ep (caller_stackframe):
	1. Cpuid = current cpu id
	2. Iparams = extract iparams from caller_stackframe
	3. Assert iparams.ctype == RET_TO_VERIFIED or iparams.ctype == CALL_FROM_UNVERIFIED
	4. Get authentic iparams.caller
	5. Common_ep(cpuid, iparams.ctype, iparams.caller, iparams.callee, caller_stackframe)

Exception_ep ():
	1. Cpuid = curent cpu id
	2. New iparams
	3. Iparams.ctype = CALL_EXCEPTION
	4. Iparams.caller = GEEC_SENTINEL
	5. Iparams.calee = signal_slab
	6. Iparams.params = exception details (source slab id, registers etc.)
	7. Common_ep(cpuid, iparams.ctype, iparams.caller, iparams.callee,  iparams)


Unverified_guest_ep ():
	1. Cpuid = curent cpu id
	2. New iparams
	3. Iparams.ctype = CALL_INTERCEPT
	4. Iparams.caller = GEEC_SENTINEL
	5. Iparams.calee = signal_guest_slab
	6. Iparams.params = intercept details (source slab id, registers etc.)
	7. Common_ep(cpuid, iparams.ctype, iparams.caller, iparams.callee,  iparams)


Common_ep(cpuid, ctype, caller, callee, caller_stackframe):
	1. If ctype == CALL_FROM_VERIFIED
		a. If sinfotable[callee].type == VERIFIED
			i. Checkandhaltcallcaps(caller,callee)
			ii. Sentinel_transition_call_from_verified_to_verified(sinfotable[callee].entrystub, caller_stackframe)
			iii. Halt
		b. If sinfotable[callee].type == UNVERIFIED
			i. Checkandhaltcallcaps(caller,callee)
			ii. Sentinel_transition_call_from_verified_to_unverified(cpuid, ctype, caller, callee, sinfotable[callee].emtrystb, caller_stackframe)
			iii. halt
		c. If sinfotable[callee].type == UNVERIFIED GUEST
			i. Checkandhaltcallcaps(caller,callee)
			ii. Sentinel_transition_call_from_verified_to_unverified_guest(sinfotable[callee].entrystub, caller_stackframe)
			iii. halt

	2. If ctype == RET_TO_VERIFIED
		a. Sentinel_transition_ret_to_verified(cpuid, ctype, caller, callee, caller_stackframe)
		b. Halt

	3. If ctype == CALL_FROM_UNVERIFIED
		a. Assert sinfotable[callee].type == VERIFIED
		b. Checkandhaltcallcaps(caller,callee)
		c. Sentinel_transition_call_from_unverified_to_verified(cpuid, ctype, caller, callee, sinfotable[callee].entrystub, caller_stackframe)
		d. halt

	4. If ctype == RET_TO_UNVERIFIED
		a. Sentinel_transition_ret_to_unverified(cpuid, ctype, caller, callee, caller_stackframe)
		b. halt

	5. If ctype == CALL_EXCEPTION
		a. Sentinel_transition_call_exception(cpuid, ctype, caller, callee, sinfotable[callee].entrystub, caller_stackframe);
		b. Halt

	6. If ctype == RET_EXCEPTION
		a. Sentinel_transition_ret_exception(cpuid, ctype, caller, callee, caller_stackframe);
		b. Halt

	7. If ctype == CALL_INTERCEPT
		a. Sentinel_transition_call_intercept(cpuid, ctype, caller, callee, sinfotable[callee].entrystub, caller_stackframe);
		b. halt

	8. If ctype == RET_INTERCEPT
		a. Sentinel_transition_ret_intercept(cpuid, ctype, caller, callee, caller_stackframe);
		b. halt



Sentinel_transition_call_from_verified_to_verified(entrystub, caller_stackframe)
	Entrystub(caller_stackframe) via JMP instruction


Sentinel_transition_call_from_verified_to_unverified(cpuid, ctype, caller, callee, callee_entrystub, caller_stackframe)
	1. Sinfotable[caller].tos[cpuid] = caller_stackframe
	2. Sinfotable[callee].tos[cpuid] -= space for iparams and oparams
	3. Iparams = extract iparams from caller_stackframe
	4. Oparams = extract oparams from caller_stackframe
	5. Copy iparams to callee slab stack at sinfotable[callee].tos[cpuid]
	6. Safestack_push(cpuid, caller, callee, ctype, caller_stackframe, oparams)
	7. Switch to callee slab page-tables (sinfotable[callee].mempgtbl_base)
	8. Callee_stack_frame = sinfotable[callee].tos[cpuid]
	9. Callee_entrystub(callee_stack_frame) via SYSEXIT instruction


Sentinel_transition_ret_to_verified(cpuid, ctype, caller, callee, caller_stackframe)
	1. Safestack_pop(l.cpuid, l.caller, l.callee, l.ctype, l.caller_stackframe, l.oparams)
	2. Assert l.caller == callee and l.callee == caller and l.cpuid == cpuid
	3. Assert l.ctype == CALL_FROM_VERIFIED
	4. Oparams = extracts oparams from caller_stackframe
	5. Copy oparams to caller slab at l.oparams
	6. Sinfotable[caller].tos[cpuid] += free iparams and oparams space
	7. Setup stack frame to l.caller_stackframe and restore caller registers
	8. Resume caller via RET instruction



Sentinel_transition_call_from_unverified_to_verified(cpuid, ctype, caller, callee, callee_entrystub, caller_stackframe)
	1. Sinfotable[caller].tos[cpuid] = caller_stackframe
	2. Sinfotable[callee].tos[cpuid] -= space for iparams and oparams
	3. Iparams = extract iparams from caller_stackframe
	4. Oparams = extract oparams from caller_stackframe
	5. Copy iparams to callee slab stack at sinfotable[callee].tos[cpuid]
	6. Safestack_push(cpuid, caller, callee, ctype, caller_stackframe, oparams)
	7. Callee_stack_frame = sinfotable[callee].tos[cpuid]
	8. Callee_entrystub(callee_stack_frame) via JMP instruction

Sentinel_transition_ret_to_unverified(cpuid, ctype, caller, callee, caller_stackframe)
	1. Safestack_pop(l.cpuid, l.caller, l.callee, l.ctype, l.caller_stackframe, l.oparams)
	2. Assert l.caller == callee and l.callee == caller and l.cpuid == cpuid
	3. Assert l.ctype == CALL_FROM_UNVERIFIED
	4. Oparams = extracts oparams from caller_stackframe
	5. Copy oparams to caller slab at l.oparams
	6. Sinfotable[caller].tos[cpuid] += free  iparams and oparams
	7. Setup stack frame to l.caller_stackframe and restore caller registers
	8. Resume caller via SYSEXIT instruction


Sentinel_transition_call_exception((cpuid, ctype, caller, callee, callee_entrystub, caller_stackframe)
	1. Sinfotable[callee].tos[cpuid] -= space for iparams
	2. Iparams = extract iparams from caller_stackframe
	3. Copy iparams to callee slab stack at sinfotable[callee].tos[cpuid]
	4. Callee_stack_frame = sinfotable[callee].tos[cpuid]
	5. Callee_entrystub(callee_stack_frame) via JMP instruction


Sentinel_transition_ret_exception((cpuid, ctype, caller, callee, caller_stackframe)
	1. Extract iparams from caller_stackframe
	2. Sinfotable[caller].tos[cpuid] += space for iparams and oparams
	3. Caller_stack_frame = iparams.params; //exception frame
	4. Resume caller via IRETL instruction


Sentinel_transition_call_intercept(cpuid, ctype, caller, callee, callee_entrystub, caller_stackframe)
	1. Callee_entrystub(callee_stack_frame) via JMP instruction

Sentinel_transition_ret_intercept(cpuid, ctype, caller, callee, caller_stackframe)
	1. Extract iparams from caller_stackframe
	2. Caller_stack_frame = iparams.params; //intercept frame
	3. Resume caller via VMRESUME instruction
