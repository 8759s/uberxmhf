GEEC model (in text)
author: amit vasudevan (amitvasudevan@acm.org)


Notes:
    1. l_xxx => local variable
    2. g_xxx => global variable
    3. hw.xxx => hardware component/state variable


MAX_CPUS = max. no. of platform cpus
MAX_STACKSIZE = size of stack in bytes
ADDR_4GB_PAGES = (0x100000000ULL/0x1000) = max. 4K pages in 4GB memory address space
PAGES(memextent) = memory page range (x..y) for a given memory extent (memextent)
ADDRS(memextent) = memory address range (mx..my) for a given memory extent (memextent)

g_totalslabs;
g_sinfotable[1..g_totalslabs]{
    .s_type (s_verified, s_unverified, s_unverified_guest);
    .s_codeextents;
    .s_dataextents;
    .s_stackextents;
    .s_dmadataextents;
    .s_deviceallocations;
}

type oparams = byte [];
type iparams = byte [];
type siparams = {
    .ctype;
    .caller;
    .callee;
    .param_buf
}

type soparams = {
    .param_buf
}


//////
// geec prime (gp)
//////


g_stack[1..MAX_CPUS][MAX_STACKSIZE];
g_temp_mempgtbl[0..ADDR_4GB_PAGES]{
    .addr;
    .flags (f_readwrite, f_readonly, f_noexecute, f_present, f_super, f_user);
};
g_sysdevlist; //list of system devices
g_sysdevlist_count; //count of system devices

entrystub {
    l_cpuid = hw.lapic.id;
    hw.cpu.esp = g_stack[cpuid];
	slab_main();
    halt();
}


slab_main {
    //setup temporary unity mapped page-tables
    gp_setup_temp_mempgtbl();

    //sanity check hw requirements
    gp_sanitycheck_hw_requirements();

    //setup slab device allocations
    gp_setup_slab_device_allocations();
}


//setup temporary unity mapped page-tables
gp_setup_temp_pagetables {
    for (l_i=0; l_i < g_totalslabs; l_i++){
        g_temp_mempgtbl[PAGES(sinfotable[l_i].codeextents)].addr = ADDRS(sinfotable[l_i].codeextents);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].codeextents)].flags = (f_present | f_readonly | f_super);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].dataextents)].addr = ADDRS(sinfotable[l_i].dataextents);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].dataextents)].flags = (f_present | f_readwrite | f_noexecute | f_super);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].stackextents)].addr = ADDRS(sinfotable[l_i].stackextents);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].stackextents)].flags = (f_present | f_readwrite | f_noexecute | f_super);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].dmadataextents)].addr = ADDRS(sinfotable[l_i].stackextents);
        g_temp_mempgtbl[PAGES(sinfotable[l_i].dmadataextents)].flags = (f_present | f_readwrite | f_noexecute | f_super);
    }

    g_temp_mempgtbl[PAGES(~sinfotable[0..(g_totalslabs-1)].{code,data,stack,dmadata}extents)].addr = ADDRS(~sinfotable[0..(g_totalslabs-1)].{code,data,stack,dmadata}extents);
    g_temp_mempgtbl[PAGES(~sinfotable[0..(g_totalslabs-1)].{code,data,stack,dmadata}extents)].flags = (f_present | f_readwrite | f_noexecute | f_super);

    hw.cpu.msr_efer |= NX;
    hw.cpu.cr4 |= PAE, PSE;
	hw.cpu.cr3 = g_temp_mempgtbl;
    hw.cpu.cr0 |= PG;
}


//setup slab device allocations
gp_setup_slab_device_allocations {
    //enumerate system devices and setup g_sysdevlist and g_sysdevlist_count
    gp_enumerate_system_devices();

    //setup slab device mappings based on system devices and individual slab device allocations
    for(l_i=0; l_i < g_totalslabs; l_i++){
        g_slabdevicemapping[l_i] = gp_getslabdevicemapping(g_sysdevlist, g_sinfotable[l_i].deviceallocations);
    }
    l_iommutablebase = gp_call_slab(UAPI_DEVPGTBL, UAPI_DEVPGTBL_INIT);

	//iv. For all slabs: call_slab(uapi_devpgtbl, DEVPGTBL_INITTBL);
    for(l_i=0; l_i < g_totalslabs; l_i++){
        gp_call_slab(UAPI_DEVPGTBL, UAPI_DEVPGTBL_INITTABLE, l_i);
    }

    //v. Initialize IOMMU
    hw.iommu.tablebase = l_iommutablebase;
	hw.iommu.translationenable = true

	for(l_i=0; l_i < g_sysdevlist_count; l_i++){
        if( (l_slabid = gp_getslabid_for_device(g_sysdevlist[l_i])) in 0..g_totalslabs ) {
            gp_call_slab(UAPI_DEVPGTBL, UAPI_DEVPGTBL_BINDDEVICE, l_slabid, g_sysdevllist[l_i]);
        }
	}
}

//setup (unverified) slab legacy I/O table
gp_setup_slab_iotbl {

    for(l_i=0; l_i < g_totalslabs; l_i++){
        if(g_sinfotable[l_i].s_type == s_unverified || s_unverified_guest){
            gp_call_slab(UAPI_IOTBL, UAPI_IOTBL_INIT, l_i);
            for(l_k=0; l_k <  g_slabdevicemapping[l_i].devcount; l_k++){
                gp_call_slab(UAPI_IOTBL, UAPI_IOTBL_ALLOWACCESSTOPORT, l_i, g_slabdevicemapping[l_i].device[l_k].ports);
            }
        }
    }

}


oparams gp_call_slab(callee, callee_fn, iparams){
    l_soparams, l_siparams;

    l_siparams.caller = GEEC_PRIME;
    l_siparams.callee = callee;
    l_siparams.callee_fn = callee_fn;
    l_siparams.parambuf = iparams;

    call_sentinel(ls_iparams, l_soparams);

    return l_soparams.parambuf;
}


call_sentinel (siparams, soparams) {
    siparams.ctype = CALL_FROM_VERIFIED;
    l_caller_stackframe = current stack frame;
	geec_sentinel_verified_ep(l_caller_stackframe);
}




//////
Geec_prime:
	2. Slab_main:
		e. Setup slab memory page tables
			i. Setup_slab_mem_page_tables
				1) Call_slab(uapi_mempgtbl, MEMPGTBL_INITTABLE, GEEC_PRIME)
				2) Populate page tables (GEEC_PRIME)
				3) For slabid in 1â€¦totalslabs
					a) If sinfotable[slabid].type == unverified or unverified guest
						i) Call_Slab(uapi_mempgtbl, MEMPGTBL_INITTABLE)
						ii) Populate page tables (slabid)
			ii. Populate_page_tables (slabid)
				1) Slabtype = sinfotable[slabid].type;
				2) For(spa=0; spa < ADDR_4GB; spa += PAGE_SIZE_4K){
					a) Spa_slabregion, spa_slabtype, spa_sameslab = getspatype(slabid, spa);
					b) Flags = getflagsforspa(slabid, spa_slabregion, spa_slabtype, spa_sameslab)
					c) If spa_slabregion == REGION_IOTBL && slabtype != verified
						i) Call_slab(uapi_mempgtbl, MEMPGTBL_SETENTRYFORPADDR, spa, sinfotable[slabid].iotbl_base, flags
					d) Else
						i) Call_slab(uapi_mempgtbl, MEMPGTBL_SETENTRYFORPADDR, spa, spa, flags
				3) }
			iii. Getspatype(slabid, spa)
				1) For I in 1..totslab
					a) If spa in iotbl[] return REGION_IOTBL
					b) If spa in slabdevicemap[i].mmioregions return REGION_DEVMMIO
					c) If spa in sinfotable[slabid].codeextents return REGION_CODE
					d) If spa in sinfotable[slabid].dataextents return REGION_DATA
					e) If spa in sinfotable[slabid].stackextents return REGION_STACK
					f) If spa in sinfotable[slabid].dmadataextents return REGION_DMADATA
					g) Else
					h) REGION_OTHER
				2) Return region, sinfotable[i].type
			iv. Getflagsforspa(slabid, spa_slabregion, spa_slabtype, spa_sameslab)
				1) Switch(sinfotable[slabid].slabtype)
					a) Case verified:
						i) REGION_OTHER = p, rw, super
						ii) If sameslab || spa_slabtype == verified
							One. REGION_CODE = p, ro, super
							Two. REGION_{DATA,STACK,DMADATA} = p, rw, nx, super
							Three. REGION_MMIO = p, rw, nx, pcd, super
						iii) Else
							One. Flags = p, rw, nx, super
					b) Case unverified
						i) REGION_OTHER = p, rw, nx, super
						ii) If sameslab || spa_labtype == verified
							One. REGION_CODE = p, ro, super
							Two. REGION_{DATA,STACK,DMADATA} = p, rw, nx, super
							Three. REGION_MMIO = p, rw, nx, pcd, super
							Four. If sameslab flags |= user
						iii) Else
							One. Flags = p, rw, nx, super
					c) Case unverified guest
						i) If sameslab  && spa_slabregion != REGION_OTHER
							One. CODE = p, rw
							Two. DATA,STACK,DMADATA = p, rw
						ii) Else
							One. Flags =0
				2) Return flags
		f. Cpu.hw.cr3 = sinfotable[GEEC_PRIME].mempgtbl_base
		g. Setup cpu state and replicate
			i. Initialize GDT
				1) TSS desc[1..maxcpus] = iotbl[1..maxcpus]
			ii. Initialize IDT
				1) IDT_desc[1..maxexceptions] = sinfotable[GEEC_SENTINEL].memoffets[2..maxexceptions+2]
			iii. Initialize TSS
			iv. Replicate_cr3 = hw.cpu.cr3;
			v. Replicate_cr4 = hw.cpu.cr4;
			vi. Replicate_msfefer = hw.cpu.msrefer;
			vii. Replicate_cr0 = hw.cpu.cr0;
			viii. Hw.lapic.command_register |= WAKE_APS at common_state
			ix. common_state()
		h. Common_state
			i. Cpuid = hw.lapic.id;
			ii. hw.cpu.esp = stack[cpuid];
			iii. Hw.cpu.cr3 = replicate_cr3;
			iv. Hw.cpu.cr4 = replicate_cr4;
			v. Hw.cpu.cr0 = replicate_cr0;
			vi. Setup vmcs state
				1) Call_slab(uapi_cpustate, VMCSREAD,VMCSWRITE,RDMSR,WRMSR)
			vii. Hw.cpu.vmxon = true
			viii. Hw.cpu.vmcsbase = sinfotable[UAPI_CPUSTATE].memoffsets[0];
			ix. Hw.cpu.sysenterhandler = sinfotable[GEEC_SENTINEL].memoffsets[0];
			x. Hw.cpu.vmexithandler = sinfotable[GEEC_SENTINEL].memoffsets[1];
			xi. Call_slab(init_slab, 0);
			xii. halt



