/*
 * @XMHF_LICENSE_HEADER_START@
 *
 * eXtensible, Modular Hypervisor Framework (XMHF)
 * Copyright (c) 2009-2012 Carnegie Mellon University
 * Copyright (c) 2010-2012 VDG Inc.
 * All Rights Reserved.
 *
 * Developed by: XMHF Team
 *               Carnegie Mellon University / CyLab
 *               VDG Inc.
 *               http://xmhf.org
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in
 * the documentation and/or other materials provided with the
 * distribution.
 *
 * Neither the names of Carnegie Mellon or VDG Inc, nor the names of
 * its contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @XMHF_LICENSE_HEADER_END@
 */

#include <xmhf.h>
#include <xmhf-debug.h>

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pdt[(PAE_PTRS_PER_PDPT*PAE_PTRS_PER_PDT)] = {
	0x0000000000000087,0x0000000000200087,0x0000000000400087,0x0000000000600087,
	0x0000000000800087,0x0000000000a00087,0x0000000000c00087,0x0000000000e00087,
	0x0000000001000087,0x0000000001200087,0x0000000001400087,0x0000000001600087,
	0x0000000001800087,0x0000000001a00087,0x0000000001c00087,0x0000000001e00087,
	0x0000000002000087,0x0000000002200087,0x0000000002400087,0x0000000002600087,
	0x0000000002800087,0x0000000002a00087,0x0000000002c00087,0x0000000002e00087,
	0x0000000003000087,0x0000000003200087,0x0000000003400087,0x0000000003600087,
	0x0000000003800087,0x0000000003a00087,0x0000000003c00087,0x0000000003e00087,
	0x0000000004000087,0x0000000004200087,0x0000000004400087,0x0000000004600087,
	0x0000000004800087,0x0000000004a00087,0x0000000004c00087,0x0000000004e00087,
	0x0000000005000087,0x0000000005200087,0x0000000005400087,0x0000000005600087,
	0x0000000005800087,0x0000000005a00087,0x0000000005c00087,0x0000000005e00087,
	0x0000000006000087,0x0000000006200087,0x0000000006400087,0x0000000006600087,
	0x0000000006800087,0x0000000006a00087,0x0000000006c00087,0x0000000006e00087,
	0x0000000007000087,0x0000000007200087,0x0000000007400087,0x0000000007600087,
	0x0000000007800087,0x0000000007a00087,0x0000000007c00087,0x0000000007e00087,
	0x0000000008000087,0x0000000008200087,0x0000000008400087,0x0000000008600087,
	0x0000000008800087,0x0000000008a00087,0x0000000008c00087,0x0000000008e00087,
	0x0000000009000087,0x0000000009200087,0x0000000009400087,0x0000000009600087,
	0x0000000009800087,0x0000000009a00087,0x0000000009c00087,0x0000000009e00087,
	0x000000000a000087,0x000000000a200087,0x000000000a400087,0x000000000a600087,
	0x000000000a800087,0x000000000aa00087,0x000000000ac00087,0x000000000ae00087,
	0x000000000b000087,0x000000000b200087,0x000000000b400087,0x000000000b600087,
	0x000000000b800087,0x000000000ba00087,0x000000000bc00087,0x000000000be00087,
	0x000000000c000087,0x000000000c200087,0x000000000c400087,0x000000000c600087,
	0x000000000c800087,0x000000000ca00087,0x000000000cc00087,0x000000000ce00087,
	0x000000000d000087,0x000000000d200087,0x000000000d400087,0x000000000d600087,
	0x000000000d800087,0x000000000da00087,0x000000000dc00087,0x000000000de00087,
	0x000000000e000087,0x000000000e200087,0x000000000e400087,0x000000000e600087,
	0x000000000e800087,0x000000000ea00087,0x000000000ec00087,0x000000000ee00087,
	0x000000000f000087,0x000000000f200087,0x000000000f400087,0x000000000f600087,
	0x000000000f800087,0x000000000fa00087,0x000000000fc00087,0x000000000fe00087,
	0x0000000010000087,0x0000000010200087,0x0000000010400087,0x0000000010600087,
	0x0000000010800087,0x0000000010a00087,0x0000000010c00087,0x0000000010e00087,
	0x0000000011000087,0x0000000011200087,0x0000000011400087,0x0000000011600087,
	0x0000000011800087,0x0000000011a00087,0x0000000011c00087,0x0000000011e00087,
	0x0000000012000087,0x0000000012200087,0x0000000012400087,0x0000000012600087,
	0x0000000012800087,0x0000000012a00087,0x0000000012c00087,0x0000000012e00087,
	0x0000000013000087,0x0000000013200087,0x0000000013400087,0x0000000013600087,
	0x0000000013800087,0x0000000013a00087,0x0000000013c00087,0x0000000013e00087,
	0x0000000014000087,0x0000000014200087,0x0000000014400087,0x0000000014600087,
	0x0000000014800087,0x0000000014a00087,0x0000000014c00087,0x0000000014e00087,
	0x0000000015000087,0x0000000015200087,0x0000000015400087,0x0000000015600087,
	0x0000000015800087,0x0000000015a00087,0x0000000015c00087,0x0000000015e00087,
	0x0000000016000087,0x0000000016200087,0x0000000016400087,0x0000000016600087,
	0x0000000016800087,0x0000000016a00087,0x0000000016c00087,0x0000000016e00087,
	0x0000000017000087,0x0000000017200087,0x0000000017400087,0x0000000017600087,
	0x0000000017800087,0x0000000017a00087,0x0000000017c00087,0x0000000017e00087,
	0x0000000018000087,0x0000000018200087,0x0000000018400087,0x0000000018600087,
	0x0000000018800087,0x0000000018a00087,0x0000000018c00087,0x0000000018e00087,
	0x0000000019000087,0x0000000019200087,0x0000000019400087,0x0000000019600087,
	0x0000000019800087,0x0000000019a00087,0x0000000019c00087,0x0000000019e00087,
	0x000000001a000087,0x000000001a200087,0x000000001a400087,0x000000001a600087,
	0x000000001a800087,0x000000001aa00087,0x000000001ac00087,0x000000001ae00087,
	0x000000001b000087,0x000000001b200087,0x000000001b400087,0x000000001b600087,
	0x000000001b800087,0x000000001ba00087,0x000000001bc00087,0x000000001be00087,
	0x000000001c000087,0x000000001c200087,0x000000001c400087,0x000000001c600087,
	0x000000001c800087,0x000000001ca00087,0x000000001cc00087,0x000000001ce00087,
	0x000000001d000087,0x000000001d200087,0x000000001d400087,0x000000001d600087,
	0x000000001d800087,0x000000001da00087,0x000000001dc00087,0x000000001de00087,
	0x000000001e000087,0x000000001e200087,0x000000001e400087,0x000000001e600087,
	0x000000001e800087,0x000000001ea00087,0x000000001ec00087,0x000000001ee00087,
	0x000000001f000087,0x000000001f200087,0x000000001f400087,0x000000001f600087,
	0x000000001f800087,0x000000001fa00087,0x000000001fc00087,0x000000001fe00087,
	0x0000000020000087,0x0000000020200087,0x0000000020400087,0x0000000020600087,
	0x0000000020800087,0x0000000020a00087,0x0000000020c00087,0x0000000020e00087,
	0x0000000021000087,0x0000000021200087,0x0000000021400087,0x0000000021600087,
	0x0000000021800087,0x0000000021a00087,0x0000000021c00087,0x0000000021e00087,
	0x0000000022000087,0x0000000022200087,0x0000000022400087,0x0000000022600087,
	0x0000000022800087,0x0000000022a00087,0x0000000022c00087,0x0000000022e00087,
	0x0000000023000087,0x0000000023200087,0x0000000023400087,0x0000000023600087,
	0x0000000023800087,0x0000000023a00087,0x0000000023c00087,0x0000000023e00087,
	0x0000000024000087,0x0000000024200087,0x0000000024400087,0x0000000024600087,
	0x0000000024800087,0x0000000024a00087,0x0000000024c00087,0x0000000024e00087,
	0x0000000025000087,0x0000000025200087,0x0000000025400087,0x0000000025600087,
	0x0000000025800087,0x0000000025a00087,0x0000000025c00087,0x0000000025e00087,
	0x0000000026000087,0x0000000026200087,0x0000000026400087,0x0000000026600087,
	0x0000000026800087,0x0000000026a00087,0x0000000026c00087,0x0000000026e00087,
	0x0000000027000087,0x0000000027200087,0x0000000027400087,0x0000000027600087,
	0x0000000027800087,0x0000000027a00087,0x0000000027c00087,0x0000000027e00087,
	0x0000000028000087,0x0000000028200087,0x0000000028400087,0x0000000028600087,
	0x0000000028800087,0x0000000028a00087,0x0000000028c00087,0x0000000028e00087,
	0x0000000029000087,0x0000000029200087,0x0000000029400087,0x0000000029600087,
	0x0000000029800087,0x0000000029a00087,0x0000000029c00087,0x0000000029e00087,
	0x000000002a000087,0x000000002a200087,0x000000002a400087,0x000000002a600087,
	0x000000002a800087,0x000000002aa00087,0x000000002ac00087,0x000000002ae00087,
	0x000000002b000087,0x000000002b200087,0x000000002b400087,0x000000002b600087,
	0x000000002b800087,0x000000002ba00087,0x000000002bc00087,0x000000002be00087,
	0x000000002c000087,0x000000002c200087,0x000000002c400087,0x000000002c600087,
	0x000000002c800087,0x000000002ca00087,0x000000002cc00087,0x000000002ce00087,
	0x000000002d000087,0x000000002d200087,0x000000002d400087,0x000000002d600087,
	0x000000002d800087,0x000000002da00087,0x000000002dc00087,0x000000002de00087,
	0x000000002e000087,0x000000002e200087,0x000000002e400087,0x000000002e600087,
	0x000000002e800087,0x000000002ea00087,0x000000002ec00087,0x000000002ee00087,
	0x000000002f000087,0x000000002f200087,0x000000002f400087,0x000000002f600087,
	0x000000002f800087,0x000000002fa00087,0x000000002fc00087,0x000000002fe00087,
	0x0000000030000087,0x0000000030200087,0x0000000030400087,0x0000000030600087,
	0x0000000030800087,0x0000000030a00087,0x0000000030c00087,0x0000000030e00087,
	0x0000000031000087,0x0000000031200087,0x0000000031400087,0x0000000031600087,
	0x0000000031800087,0x0000000031a00087,0x0000000031c00087,0x0000000031e00087,
	0x0000000032000087,0x0000000032200087,0x0000000032400087,0x0000000032600087,
	0x0000000032800087,0x0000000032a00087,0x0000000032c00087,0x0000000032e00087,
	0x0000000033000087,0x0000000033200087,0x0000000033400087,0x0000000033600087,
	0x0000000033800087,0x0000000033a00087,0x0000000033c00087,0x0000000033e00087,
	0x0000000034000087,0x0000000034200087,0x0000000034400087,0x0000000034600087,
	0x0000000034800087,0x0000000034a00087,0x0000000034c00087,0x0000000034e00087,
	0x0000000035000087,0x0000000035200087,0x0000000035400087,0x0000000035600087,
	0x0000000035800087,0x0000000035a00087,0x0000000035c00087,0x0000000035e00087,
	0x0000000036000087,0x0000000036200087,0x0000000036400087,0x0000000036600087,
	0x0000000036800087,0x0000000036a00087,0x0000000036c00087,0x0000000036e00087,
	0x0000000037000087,0x0000000037200087,0x0000000037400087,0x0000000037600087,
	0x0000000037800087,0x0000000037a00087,0x0000000037c00087,0x0000000037e00087,
	0x0000000038000087,0x0000000038200087,0x0000000038400087,0x0000000038600087,
	0x0000000038800087,0x0000000038a00087,0x0000000038c00087,0x0000000038e00087,
	0x0000000039000087,0x0000000039200087,0x0000000039400087,0x0000000039600087,
	0x0000000039800087,0x0000000039a00087,0x0000000039c00087,0x0000000039e00087,
	0x000000003a000087,0x000000003a200087,0x000000003a400087,0x000000003a600087,
	0x000000003a800087,0x000000003aa00087,0x000000003ac00087,0x000000003ae00087,
	0x000000003b000087,0x000000003b200087,0x000000003b400087,0x000000003b600087,
	0x000000003b800087,0x000000003ba00087,0x000000003bc00087,0x000000003be00087,
	0x000000003c000087,0x000000003c200087,0x000000003c400087,0x000000003c600087,
	0x000000003c800087,0x000000003ca00087,0x000000003cc00087,0x000000003ce00087,
	0x000000003d000087,0x000000003d200087,0x000000003d400087,0x000000003d600087,
	0x000000003d800087,0x000000003da00087,0x000000003dc00087,0x000000003de00087,
	0x000000003e000087,0x000000003e200087,0x000000003e400087,0x000000003e600087,
	0x000000003e800087,0x000000003ea00087,0x000000003ec00087,0x000000003ee00087,
	0x000000003f000087,0x000000003f200087,0x000000003f400087,0x000000003f600087,
	0x000000003f800087,0x000000003fa00087,0x000000003fc00087,0x000000003fe00087,
	0x0000000040000087,0x0000000040200087,0x0000000040400087,0x0000000040600087,
	0x0000000040800087,0x0000000040a00087,0x0000000040c00087,0x0000000040e00087,
	0x0000000041000087,0x0000000041200087,0x0000000041400087,0x0000000041600087,
	0x0000000041800087,0x0000000041a00087,0x0000000041c00087,0x0000000041e00087,
	0x0000000042000087,0x0000000042200087,0x0000000042400087,0x0000000042600087,
	0x0000000042800087,0x0000000042a00087,0x0000000042c00087,0x0000000042e00087,
	0x0000000043000087,0x0000000043200087,0x0000000043400087,0x0000000043600087,
	0x0000000043800087,0x0000000043a00087,0x0000000043c00087,0x0000000043e00087,
	0x0000000044000087,0x0000000044200087,0x0000000044400087,0x0000000044600087,
	0x0000000044800087,0x0000000044a00087,0x0000000044c00087,0x0000000044e00087,
	0x0000000045000087,0x0000000045200087,0x0000000045400087,0x0000000045600087,
	0x0000000045800087,0x0000000045a00087,0x0000000045c00087,0x0000000045e00087,
	0x0000000046000087,0x0000000046200087,0x0000000046400087,0x0000000046600087,
	0x0000000046800087,0x0000000046a00087,0x0000000046c00087,0x0000000046e00087,
	0x0000000047000087,0x0000000047200087,0x0000000047400087,0x0000000047600087,
	0x0000000047800087,0x0000000047a00087,0x0000000047c00087,0x0000000047e00087,
	0x0000000048000087,0x0000000048200087,0x0000000048400087,0x0000000048600087,
	0x0000000048800087,0x0000000048a00087,0x0000000048c00087,0x0000000048e00087,
	0x0000000049000087,0x0000000049200087,0x0000000049400087,0x0000000049600087,
	0x0000000049800087,0x0000000049a00087,0x0000000049c00087,0x0000000049e00087,
	0x000000004a000087,0x000000004a200087,0x000000004a400087,0x000000004a600087,
	0x000000004a800087,0x000000004aa00087,0x000000004ac00087,0x000000004ae00087,
	0x000000004b000087,0x000000004b200087,0x000000004b400087,0x000000004b600087,
	0x000000004b800087,0x000000004ba00087,0x000000004bc00087,0x000000004be00087,
	0x000000004c000087,0x000000004c200087,0x000000004c400087,0x000000004c600087,
	0x000000004c800087,0x000000004ca00087,0x000000004cc00087,0x000000004ce00087,
	0x000000004d000087,0x000000004d200087,0x000000004d400087,0x000000004d600087,
	0x000000004d800087,0x000000004da00087,0x000000004dc00087,0x000000004de00087,
	0x000000004e000087,0x000000004e200087,0x000000004e400087,0x000000004e600087,
	0x000000004e800087,0x000000004ea00087,0x000000004ec00087,0x000000004ee00087,
	0x000000004f000087,0x000000004f200087,0x000000004f400087,0x000000004f600087,
	0x000000004f800087,0x000000004fa00087,0x000000004fc00087,0x000000004fe00087,
	0x0000000050000087,0x0000000050200087,0x0000000050400087,0x0000000050600087,
	0x0000000050800087,0x0000000050a00087,0x0000000050c00087,0x0000000050e00087,
	0x0000000051000087,0x0000000051200087,0x0000000051400087,0x0000000051600087,
	0x0000000051800087,0x0000000051a00087,0x0000000051c00087,0x0000000051e00087,
	0x0000000052000087,0x0000000052200087,0x0000000052400087,0x0000000052600087,
	0x0000000052800087,0x0000000052a00087,0x0000000052c00087,0x0000000052e00087,
	0x0000000053000087,0x0000000053200087,0x0000000053400087,0x0000000053600087,
	0x0000000053800087,0x0000000053a00087,0x0000000053c00087,0x0000000053e00087,
	0x0000000054000087,0x0000000054200087,0x0000000054400087,0x0000000054600087,
	0x0000000054800087,0x0000000054a00087,0x0000000054c00087,0x0000000054e00087,
	0x0000000055000087,0x0000000055200087,0x0000000055400087,0x0000000055600087,
	0x0000000055800087,0x0000000055a00087,0x0000000055c00087,0x0000000055e00087,
	0x0000000056000087,0x0000000056200087,0x0000000056400087,0x0000000056600087,
	0x0000000056800087,0x0000000056a00087,0x0000000056c00087,0x0000000056e00087,
	0x0000000057000087,0x0000000057200087,0x0000000057400087,0x0000000057600087,
	0x0000000057800087,0x0000000057a00087,0x0000000057c00087,0x0000000057e00087,
	0x0000000058000087,0x0000000058200087,0x0000000058400087,0x0000000058600087,
	0x0000000058800087,0x0000000058a00087,0x0000000058c00087,0x0000000058e00087,
	0x0000000059000087,0x0000000059200087,0x0000000059400087,0x0000000059600087,
	0x0000000059800087,0x0000000059a00087,0x0000000059c00087,0x0000000059e00087,
	0x000000005a000087,0x000000005a200087,0x000000005a400087,0x000000005a600087,
	0x000000005a800087,0x000000005aa00087,0x000000005ac00087,0x000000005ae00087,
	0x000000005b000087,0x000000005b200087,0x000000005b400087,0x000000005b600087,
	0x000000005b800087,0x000000005ba00087,0x000000005bc00087,0x000000005be00087,
	0x000000005c000087,0x000000005c200087,0x000000005c400087,0x000000005c600087,
	0x000000005c800087,0x000000005ca00087,0x000000005cc00087,0x000000005ce00087,
	0x000000005d000087,0x000000005d200087,0x000000005d400087,0x000000005d600087,
	0x000000005d800087,0x000000005da00087,0x000000005dc00087,0x000000005de00087,
	0x000000005e000087,0x000000005e200087,0x000000005e400087,0x000000005e600087,
	0x000000005e800087,0x000000005ea00087,0x000000005ec00087,0x000000005ee00087,
	0x000000005f000087,0x000000005f200087,0x000000005f400087,0x000000005f600087,
	0x000000005f800087,0x000000005fa00087,0x000000005fc00087,0x000000005fe00087,
	0x0000000060000087,0x0000000060200087,0x0000000060400087,0x0000000060600087,
	0x0000000060800087,0x0000000060a00087,0x0000000060c00087,0x0000000060e00087,
	0x0000000061000087,0x0000000061200087,0x0000000061400087,0x0000000061600087,
	0x0000000061800087,0x0000000061a00087,0x0000000061c00087,0x0000000061e00087,
	0x0000000062000087,0x0000000062200087,0x0000000062400087,0x0000000062600087,
	0x0000000062800087,0x0000000062a00087,0x0000000062c00087,0x0000000062e00087,
	0x0000000063000087,0x0000000063200087,0x0000000063400087,0x0000000063600087,
	0x0000000063800087,0x0000000063a00087,0x0000000063c00087,0x0000000063e00087,
	0x0000000064000087,0x0000000064200087,0x0000000064400087,0x0000000064600087,
	0x0000000064800087,0x0000000064a00087,0x0000000064c00087,0x0000000064e00087,
	0x0000000065000087,0x0000000065200087,0x0000000065400087,0x0000000065600087,
	0x0000000065800087,0x0000000065a00087,0x0000000065c00087,0x0000000065e00087,
	0x0000000066000087,0x0000000066200087,0x0000000066400087,0x0000000066600087,
	0x0000000066800087,0x0000000066a00087,0x0000000066c00087,0x0000000066e00087,
	0x0000000067000087,0x0000000067200087,0x0000000067400087,0x0000000067600087,
	0x0000000067800087,0x0000000067a00087,0x0000000067c00087,0x0000000067e00087,
	0x0000000068000087,0x0000000068200087,0x0000000068400087,0x0000000068600087,
	0x0000000068800087,0x0000000068a00087,0x0000000068c00087,0x0000000068e00087,
	0x0000000069000087,0x0000000069200087,0x0000000069400087,0x0000000069600087,
	0x0000000069800087,0x0000000069a00087,0x0000000069c00087,0x0000000069e00087,
	0x000000006a000087,0x000000006a200087,0x000000006a400087,0x000000006a600087,
	0x000000006a800087,0x000000006aa00087,0x000000006ac00087,0x000000006ae00087,
	0x000000006b000087,0x000000006b200087,0x000000006b400087,0x000000006b600087,
	0x000000006b800087,0x000000006ba00087,0x000000006bc00087,0x000000006be00087,
	0x000000006c000087,0x000000006c200087,0x000000006c400087,0x000000006c600087,
	0x000000006c800087,0x000000006ca00087,0x000000006cc00087,0x000000006ce00087,
	0x000000006d000087,0x000000006d200087,0x000000006d400087,0x000000006d600087,
	0x000000006d800087,0x000000006da00087,0x000000006dc00087,0x000000006de00087,
	0x000000006e000087,0x000000006e200087,0x000000006e400087,0x000000006e600087,
	0x000000006e800087,0x000000006ea00087,0x000000006ec00087,0x000000006ee00087,
	0x000000006f000087,0x000000006f200087,0x000000006f400087,0x000000006f600087,
	0x000000006f800087,0x000000006fa00087,0x000000006fc00087,0x000000006fe00087,
	0x0000000070000087,0x0000000070200087,0x0000000070400087,0x0000000070600087,
	0x0000000070800087,0x0000000070a00087,0x0000000070c00087,0x0000000070e00087,
	0x0000000071000087,0x0000000071200087,0x0000000071400087,0x0000000071600087,
	0x0000000071800087,0x0000000071a00087,0x0000000071c00087,0x0000000071e00087,
	0x0000000072000087,0x0000000072200087,0x0000000072400087,0x0000000072600087,
	0x0000000072800087,0x0000000072a00087,0x0000000072c00087,0x0000000072e00087,
	0x0000000073000087,0x0000000073200087,0x0000000073400087,0x0000000073600087,
	0x0000000073800087,0x0000000073a00087,0x0000000073c00087,0x0000000073e00087,
	0x0000000074000087,0x0000000074200087,0x0000000074400087,0x0000000074600087,
	0x0000000074800087,0x0000000074a00087,0x0000000074c00087,0x0000000074e00087,
	0x0000000075000087,0x0000000075200087,0x0000000075400087,0x0000000075600087,
	0x0000000075800087,0x0000000075a00087,0x0000000075c00087,0x0000000075e00087,
	0x0000000076000087,0x0000000076200087,0x0000000076400087,0x0000000076600087,
	0x0000000076800087,0x0000000076a00087,0x0000000076c00087,0x0000000076e00087,
	0x0000000077000087,0x0000000077200087,0x0000000077400087,0x0000000077600087,
	0x0000000077800087,0x0000000077a00087,0x0000000077c00087,0x0000000077e00087,
	0x0000000078000087,0x0000000078200087,0x0000000078400087,0x0000000078600087,
	0x0000000078800087,0x0000000078a00087,0x0000000078c00087,0x0000000078e00087,
	0x0000000079000087,0x0000000079200087,0x0000000079400087,0x0000000079600087,
	0x0000000079800087,0x0000000079a00087,0x0000000079c00087,0x0000000079e00087,
	0x000000007a000087,0x000000007a200087,0x000000007a400087,0x000000007a600087,
	0x000000007a800087,0x000000007aa00087,0x000000007ac00087,0x000000007ae00087,
	0x000000007b000087,0x000000007b200087,0x000000007b400087,0x000000007b600087,
	0x000000007b800087,0x000000007ba00087,0x000000007bc00087,0x000000007be00087,
	0x000000007c000087,0x000000007c200087,0x000000007c400087,0x000000007c600087,
	0x000000007c800087,0x000000007ca00087,0x000000007cc00087,0x000000007ce00087,
	0x000000007d000087,0x000000007d200087,0x000000007d400087,0x000000007d600087,
	0x000000007d800087,0x000000007da00087,0x000000007dc00087,0x000000007de00087,
	0x000000007e000087,0x000000007e200087,0x000000007e400087,0x000000007e600087,
	0x000000007e800087,0x000000007ea00087,0x000000007ec00087,0x000000007ee00087,
	0x000000007f000087,0x000000007f200087,0x000000007f400087,0x000000007f600087,
	0x000000007f800087,0x000000007fa00087,0x000000007fc00087,0x000000007fe00087,
	0x0000000080000087,0x0000000080200087,0x0000000080400087,0x0000000080600087,
	0x0000000080800087,0x0000000080a00087,0x0000000080c00087,0x0000000080e00087,
	0x0000000087000087,0x0000000087200087,0x0000000087400087,0x0000000087600087,
	0x0000000087800087,0x0000000087a00087,0x0000000087c00087,0x0000000087e00087,
	0x0000000082000087,0x0000000082200087,0x0000000082400087,0x0000000082600087,
	0x0000000082800087,0x0000000082a00087,0x0000000082c00087,0x0000000082e00087,
	0x0000000087000087,0x0000000087200087,0x0000000087400087,0x0000000087600087,
	0x0000000087800087,0x0000000087a00087,0x0000000087c00087,0x0000000087e00087,
	0x0000000084000087,0x0000000084200087,0x0000000084400087,0x0000000084600087,
	0x0000000084800087,0x0000000084a00087,0x0000000084c00087,0x0000000084e00087,
	0x0000000085000087,0x0000000085200087,0x0000000085400087,0x0000000085600087,
	0x0000000085800087,0x0000000085a00087,0x0000000085c00087,0x0000000085e00087,
	0x0000000086000087,0x0000000086200087,0x0000000086400087,0x0000000086600087,
	0x0000000086800087,0x0000000086a00087,0x0000000086c00087,0x0000000086e00087,
	0x0000000087000087,0x0000000087200087,0x0000000087400087,0x0000000087600087,
	0x0000000087800087,0x0000000087a00087,0x0000000087c00087,0x0000000087e00087,
	0x0000000088000087,0x0000000088200087,0x0000000088400087,0x0000000088600087,
	0x0000000088800087,0x0000000088a00087,0x0000000088c00087,0x0000000088e00087,
	0x0000000089000087,0x0000000089200087,0x0000000089400087,0x0000000089600087,
	0x0000000089800087,0x0000000089a00087,0x0000000089c00087,0x0000000089e00087,
	0x000000008a000087,0x000000008a200087,0x000000008a400087,0x000000008a600087,
	0x000000008a800087,0x000000008aa00087,0x000000008ac00087,0x000000008ae00087,
	0x000000008b000087,0x000000008b200087,0x000000008b400087,0x000000008b600087,
	0x000000008b800087,0x000000008ba00087,0x000000008bc00087,0x000000008be00087,
	0x000000008c000087,0x000000008c200087,0x000000008c400087,0x000000008c600087,
	0x000000008c800087,0x000000008ca00087,0x000000008cc00087,0x000000008ce00087,
	0x000000008d000087,0x000000008d200087,0x000000008d400087,0x000000008d600087,
	0x000000008d800087,0x000000008da00087,0x000000008dc00087,0x000000008de00087,
	0x000000008e000087,0x000000008e200087,0x000000008e400087,0x000000008e600087,
	0x000000008e800087,0x000000008ea00087,0x000000008ec00087,0x000000008ee00087,
	0x000000008f000087,0x000000008f200087,0x000000008f400087,0x000000008f600087,
	0x000000008f800087,0x000000008fa00087,0x000000008fc00087,0x000000008fe00087,
	0x0000000090000087,0x0000000090200087,0x0000000090400087,0x0000000090600087,
	0x0000000090800087,0x0000000090a00087,0x0000000090c00087,0x0000000090e00087,
	0x0000000091000087,0x0000000091200087,0x0000000091400087,0x0000000091600087,
	0x0000000091800087,0x0000000091a00087,0x0000000091c00087,0x0000000091e00087,
	0x0000000092000087,0x0000000092200087,0x0000000092400087,0x0000000092600087,
	0x0000000092800087,0x0000000092a00087,0x0000000092c00087,0x0000000092e00087,
	0x0000000093000087,0x0000000093200087,0x0000000093400087,0x0000000093600087,
	0x0000000093800087,0x0000000093a00087,0x0000000093c00087,0x0000000093e00087,
	0x0000000094000087,0x0000000094200087,0x0000000094400087,0x0000000094600087,
	0x0000000094800087,0x0000000094a00087,0x0000000094c00087,0x0000000094e00087,
	0x0000000095000087,0x0000000095200087,0x0000000095400087,0x0000000095600087,
	0x0000000095800087,0x0000000095a00087,0x0000000095c00087,0x0000000095e00087,
	0x0000000096000087,0x0000000096200087,0x0000000096400087,0x0000000096600087,
	0x0000000096800087,0x0000000096a00087,0x0000000096c00087,0x0000000096e00087,
	0x0000000097000087,0x0000000097200087,0x0000000097400087,0x0000000097600087,
	0x0000000097800087,0x0000000097a00087,0x0000000097c00087,0x0000000097e00087,
	0x0000000098000087,0x0000000098200087,0x0000000098400087,0x0000000098600087,
	0x0000000098800087,0x0000000098a00087,0x0000000098c00087,0x0000000098e00087,
	0x0000000099000087,0x0000000099200087,0x0000000099400087,0x0000000099600087,
	0x0000000099800087,0x0000000099a00087,0x0000000099c00087,0x0000000099e00087,
	0x000000009a000087,0x000000009a200087,0x000000009a400087,0x000000009a600087,
	0x000000009a800087,0x000000009aa00087,0x000000009ac00087,0x000000009ae00087,
	0x000000009b000087,0x000000009b200087,0x000000009b400087,0x000000009b600087,
	0x000000009b800087,0x000000009ba00087,0x000000009bc00087,0x000000009be00087,
	0x000000009c000087,0x000000009c200087,0x000000009c400087,0x000000009c600087,
	0x000000009c800087,0x000000009ca00087,0x000000009cc00087,0x000000009ce00087,
	0x000000009d000087,0x000000009d200087,0x000000009d400087,0x000000009d600087,
	0x000000009d800087,0x000000009da00087,0x000000009dc00087,0x000000009de00087,
	0x000000009e000087,0x000000009e200087,0x000000009e400087,0x000000009e600087,
	0x000000009e800087,0x000000009ea00087,0x000000009ec00087,0x000000009ee00087,
	0x000000009f000087,0x000000009f200087,0x000000009f400087,0x000000009f600087,
	0x000000009f800087,0x000000009fa00087,0x000000009fc00087,0x000000009fe00087,
	0x00000000a0000087,0x00000000a0200087,0x00000000a0400087,0x00000000a0600087,
	0x00000000a0800087,0x00000000a0a00087,0x00000000a0c00087,0x00000000a0e00087,
	0x00000000a1000087,0x00000000a1200087,0x00000000a1400087,0x00000000a1600087,
	0x00000000a1800087,0x00000000a1a00087,0x00000000a1c00087,0x00000000a1e00087,
	0x00000000a2000087,0x00000000a2200087,0x00000000a2400087,0x00000000a2600087,
	0x00000000a2800087,0x00000000a2a00087,0x00000000a2c00087,0x00000000a2e00087,
	0x00000000a3000087,0x00000000a3200087,0x00000000a3400087,0x00000000a3600087,
	0x00000000a3800087,0x00000000a3a00087,0x00000000a3c00087,0x00000000a3e00087,
	0x00000000a4000087,0x00000000a4200087,0x00000000a4400087,0x00000000a4600087,
	0x00000000a4800087,0x00000000a4a00087,0x00000000a4c00087,0x00000000a4e00087,
	0x00000000a5000087,0x00000000a5200087,0x00000000a5400087,0x00000000a5600087,
	0x00000000a5800087,0x00000000a5a00087,0x00000000a5c00087,0x00000000a5e00087,
	0x00000000a6000087,0x00000000a6200087,0x00000000a6400087,0x00000000a6600087,
	0x00000000a6800087,0x00000000a6a00087,0x00000000a6c00087,0x00000000a6e00087,
	0x00000000a7000087,0x00000000a7200087,0x00000000a7400087,0x00000000a7600087,
	0x00000000a7800087,0x00000000a7a00087,0x00000000a7c00087,0x00000000a7e00087,
	0x00000000a8000087,0x00000000a8200087,0x00000000a8400087,0x00000000a8600087,
	0x00000000a8800087,0x00000000a8a00087,0x00000000a8c00087,0x00000000a8e00087,
	0x00000000a9000087,0x00000000a9200087,0x00000000a9400087,0x00000000a9600087,
	0x00000000a9800087,0x00000000a9a00087,0x00000000a9c00087,0x00000000a9e00087,
	0x00000000aa000087,0x00000000aa200087,0x00000000aa400087,0x00000000aa600087,
	0x00000000aa800087,0x00000000aaa00087,0x00000000aac00087,0x00000000aae00087,
	0x00000000ab000087,0x00000000ab200087,0x00000000ab400087,0x00000000ab600087,
	0x00000000ab800087,0x00000000aba00087,0x00000000abc00087,0x00000000abe00087,
	0x00000000ac000087,0x00000000ac200087,0x00000000ac400087,0x00000000ac600087,
	0x00000000ac800087,0x00000000aca00087,0x00000000acc00087,0x00000000ace00087,
	0x00000000ad000087,0x00000000ad200087,0x00000000ad400087,0x00000000ad600087,
	0x00000000ad800087,0x00000000ada00087,0x00000000adc00087,0x00000000ade00087,
	0x00000000ae000087,0x00000000ae200087,0x00000000ae400087,0x00000000ae600087,
	0x00000000ae800087,0x00000000aea00087,0x00000000aec00087,0x00000000aee00087,
	0x00000000af000087,0x00000000af200087,0x00000000af400087,0x00000000af600087,
	0x00000000af800087,0x00000000afa00087,0x00000000afc00087,0x00000000afe00087,
	0x00000000b0000087,0x00000000b0200087,0x00000000b0400087,0x00000000b0600087,
	0x00000000b0800087,0x00000000b0a00087,0x00000000b0c00087,0x00000000b0e00087,
	0x00000000b1000087,0x00000000b1200087,0x00000000b1400087,0x00000000b1600087,
	0x00000000b1800087,0x00000000b1a00087,0x00000000b1c00087,0x00000000b1e00087,
	0x00000000b2000087,0x00000000b2200087,0x00000000b2400087,0x00000000b2600087,
	0x00000000b2800087,0x00000000b2a00087,0x00000000b2c00087,0x00000000b2e00087,
	0x00000000b3000087,0x00000000b3200087,0x00000000b3400087,0x00000000b3600087,
	0x00000000b3800087,0x00000000b3a00087,0x00000000b3c00087,0x00000000b3e00087,
	0x00000000b4000087,0x00000000b4200087,0x00000000b4400087,0x00000000b4600087,
	0x00000000b4800087,0x00000000b4a00087,0x00000000b4c00087,0x00000000b4e00087,
	0x00000000b5000087,0x00000000b5200087,0x00000000b5400087,0x00000000b5600087,
	0x00000000b5800087,0x00000000b5a00087,0x00000000b5c00087,0x00000000b5e00087,
	0x00000000b6000087,0x00000000b6200087,0x00000000b6400087,0x00000000b6600087,
	0x00000000b6800087,0x00000000b6a00087,0x00000000b6c00087,0x00000000b6e00087,
	0x00000000b7000087,0x00000000b7200087,0x00000000b7400087,0x00000000b7600087,
	0x00000000b7800087,0x00000000b7a00087,0x00000000b7c00087,0x00000000b7e00087,
	0x00000000b8000087,0x00000000b8200087,0x00000000b8400087,0x00000000b8600087,
	0x00000000b8800087,0x00000000b8a00087,0x00000000b8c00087,0x00000000b8e00087,
	0x00000000b9000087,0x00000000b9200087,0x00000000b9400087,0x00000000b9600087,
	0x00000000b9800087,0x00000000b9a00087,0x00000000b9c00087,0x00000000b9e00087,
	0x00000000ba000087,0x00000000ba200087,0x00000000ba400087,0x00000000ba600087,
	0x00000000ba800087,0x00000000baa00087,0x00000000bac00087,0x00000000bae00087,
	0x00000000bb000087,0x00000000bb200087,0x00000000bb400087,0x00000000bb600087,
	0x00000000bb800087,0x00000000bba00087,0x00000000bbc00087,0x00000000bbe00087,
	0x00000000bc000087,0x00000000bc200087,0x00000000bc400087,0x00000000bc600087,
	0x00000000bc800087,0x00000000bca00087,0x00000000bcc00087,0x00000000bce00087,
	0x00000000bd000087,0x00000000bd200087,0x00000000bd400087,0x00000000bd600087,
	0x00000000bd800087,0x00000000bda00087,0x00000000bdc00087,0x00000000bde00087,
	0x00000000be000087,0x00000000be200087,0x00000000be400087,0x00000000be600087,
	0x00000000be800087,0x00000000bea00087,0x00000000bec00087,0x00000000bee00087,
	0x00000000bf000087,0x00000000bf200087,0x00000000bf400087,0x00000000bf600087,
	0x00000000bf800087,0x00000000bfa00087,0x00000000bfc00087,0x00000000bfe00087,
	0x00000000c0000087,0x00000000c0200087,0x00000000c0400087,0x00000000c0600087,
	0x00000000c0800087,0x00000000c0a00087,0x00000000c0c00087,0x00000000c0e00087,
	0x00000000c1000087,0x00000000c1200087,0x00000000c1400087,0x00000000c1600087,
	0x00000000c1800087,0x00000000c1a00087,0x00000000c1c00087,0x00000000c1e00087,
	0x00000000c2000087,0x00000000c2200087,0x00000000c2400087,0x00000000c2600087,
	0x00000000c2800087,0x00000000c2a00087,0x00000000c2c00087,0x00000000c2e00087,
	0x00000000c3000087,0x00000000c3200087,0x00000000c3400087,0x00000000c3600087,
	0x00000000c3800087,0x00000000c3a00087,0x00000000c3c00087,0x00000000c3e00087,
	0x00000000c4000087,0x00000000c4200087,0x00000000c4400087,0x00000000c4600087,
	0x00000000c4800087,0x00000000c4a00087,0x00000000c4c00087,0x00000000c4e00087,
	0x00000000c5000087,0x00000000c5200087,0x00000000c5400087,0x00000000c5600087,
	0x00000000c5800087,0x00000000c5a00087,0x00000000c5c00087,0x00000000c5e00087,
	0x00000000c6000087,0x00000000c6200087,0x00000000c6400087,0x00000000c6600087,
	0x00000000c6800087,0x00000000c6a00087,0x00000000c6c00087,0x00000000c6e00087,
	0x00000000c7000087,0x00000000c7200087,0x00000000c7400087,0x00000000c7600087,
	0x00000000c7800087,0x00000000c7a00087,0x00000000c7c00087,0x00000000c7e00087,
	0x00000000c8000087,0x00000000c8200087,0x00000000c8400087,0x00000000c8600087,
	0x00000000c8800087,0x00000000c8a00087,0x00000000c8c00087,0x00000000c8e00087,
	0x00000000c9000087,0x00000000c9200087,0x00000000c9400087,0x00000000c9600087,
	0x00000000c9800087,0x00000000c9a00087,0x00000000c9c00087,0x00000000c9e00087,
	0x00000000ca000087,0x00000000ca200087,0x00000000ca400087,0x00000000ca600087,
	0x00000000ca800087,0x00000000caa00087,0x00000000cac00087,0x00000000cae00087,
	0x00000000cb000087,0x00000000cb200087,0x00000000cb400087,0x00000000cb600087,
	0x00000000cb800087,0x00000000cba00087,0x00000000cbc00087,0x00000000cbe00087,
	0x00000000cc000087,0x00000000cc200087,0x00000000cc400087,0x00000000cc600087,
	0x00000000cc800087,0x00000000cca00087,0x00000000ccc00087,0x00000000cce00087,
	0x00000000cd000087,0x00000000cd200087,0x00000000cd400087,0x00000000cd600087,
	0x00000000cd800087,0x00000000cda00087,0x00000000cdc00087,0x00000000cde00087,
	0x00000000ce000087,0x00000000ce200087,0x00000000ce400087,0x00000000ce600087,
	0x00000000ce800087,0x00000000cea00087,0x00000000cec00087,0x00000000cee00087,
	0x00000000cf000087,0x00000000cf200087,0x00000000cf400087,0x00000000cf600087,
	0x00000000cf800087,0x00000000cfa00087,0x00000000cfc00087,0x00000000cfe00087,
	0x00000000d0000087,0x00000000d0200087,0x00000000d0400087,0x00000000d0600087,
	0x00000000d0800087,0x00000000d0a00087,0x00000000d0c00087,0x00000000d0e00087,
	0x00000000d1000087,0x00000000d1200087,0x00000000d1400087,0x00000000d1600087,
	0x00000000d1800087,0x00000000d1a00087,0x00000000d1c00087,0x00000000d1e00087,
	0x00000000d2000087,0x00000000d2200087,0x00000000d2400087,0x00000000d2600087,
	0x00000000d2800087,0x00000000d2a00087,0x00000000d2c00087,0x00000000d2e00087,
	0x00000000d3000087,0x00000000d3200087,0x00000000d3400087,0x00000000d3600087,
	0x00000000d3800087,0x00000000d3a00087,0x00000000d3c00087,0x00000000d3e00087,
	0x00000000d4000087,0x00000000d4200087,0x00000000d4400087,0x00000000d4600087,
	0x00000000d4800087,0x00000000d4a00087,0x00000000d4c00087,0x00000000d4e00087,
	0x00000000d5000087,0x00000000d5200087,0x00000000d5400087,0x00000000d5600087,
	0x00000000d5800087,0x00000000d5a00087,0x00000000d5c00087,0x00000000d5e00087,
	0x00000000d6000087,0x00000000d6200087,0x00000000d6400087,0x00000000d6600087,
	0x00000000d6800087,0x00000000d6a00087,0x00000000d6c00087,0x00000000d6e00087,
	0x00000000d7000087,0x00000000d7200087,0x00000000d7400087,0x00000000d7600087,
	0x00000000d7800087,0x00000000d7a00087,0x00000000d7c00087,0x00000000d7e00087,
	0x00000000d8000087,0x00000000d8200087,0x00000000d8400087,0x00000000d8600087,
	0x00000000d8800087,0x00000000d8a00087,0x00000000d8c00087,0x00000000d8e00087,
	0x00000000d9000087,0x00000000d9200087,0x00000000d9400087,0x00000000d9600087,
	0x00000000d9800087,0x00000000d9a00087,0x00000000d9c00087,0x00000000d9e00087,
	0x00000000da000087,0x00000000da200087,0x00000000da400087,0x00000000da600087,
	0x00000000da800087,0x00000000daa00087,0x00000000dac00087,0x00000000dae00087,
	0x00000000db000087,0x00000000db200087,0x00000000db400087,0x00000000db600087,
	0x00000000db800087,0x00000000dba00087,0x00000000dbc00087,0x00000000dbe00087,
	0x00000000dc000087,0x00000000dc200087,0x00000000dc400087,0x00000000dc600087,
	0x00000000dc800087,0x00000000dca00087,0x00000000dcc00087,0x00000000dce00087,
	0x00000000dd000087,0x00000000dd200087,0x00000000dd400087,0x00000000dd600087,
	0x00000000dd800087,0x00000000dda00087,0x00000000ddc00087,0x00000000dde00087,
	0x00000000de000087,0x00000000de200087,0x00000000de400087,0x00000000de600087,
	0x00000000de800087,0x00000000dea00087,0x00000000dec00087,0x00000000dee00087,
	0x00000000df000087,0x00000000df200087,0x00000000df400087,0x00000000df600087,
	0x00000000df800087,0x00000000dfa00087,0x00000000dfc00087,0x00000000dfe00087,
	0x00000000e0000087,0x00000000e0200087,0x00000000e0400087,0x00000000e0600087,
	0x00000000e0800087,0x00000000e0a00087,0x00000000e0c00087,0x00000000e0e00087,
	0x00000000e1000087,0x00000000e1200087,0x00000000e1400087,0x00000000e1600087,
	0x00000000e1800087,0x00000000e1a00087,0x00000000e1c00087,0x00000000e1e00087,
	0x00000000e2000087,0x00000000e2200087,0x00000000e2400087,0x00000000e2600087,
	0x00000000e2800087,0x00000000e2a00087,0x00000000e2c00087,0x00000000e2e00087,
	0x00000000e3000087,0x00000000e3200087,0x00000000e3400087,0x00000000e3600087,
	0x00000000e3800087,0x00000000e3a00087,0x00000000e3c00087,0x00000000e3e00087,
	0x00000000e4000087,0x00000000e4200087,0x00000000e4400087,0x00000000e4600087,
	0x00000000e4800087,0x00000000e4a00087,0x00000000e4c00087,0x00000000e4e00087,
	0x00000000e5000087,0x00000000e5200087,0x00000000e5400087,0x00000000e5600087,
	0x00000000e5800087,0x00000000e5a00087,0x00000000e5c00087,0x00000000e5e00087,
	0x00000000e6000087,0x00000000e6200087,0x00000000e6400087,0x00000000e6600087,
	0x00000000e6800087,0x00000000e6a00087,0x00000000e6c00087,0x00000000e6e00087,
	0x00000000e7000087,0x00000000e7200087,0x00000000e7400087,0x00000000e7600087,
	0x00000000e7800087,0x00000000e7a00087,0x00000000e7c00087,0x00000000e7e00087,
	0x00000000e8000087,0x00000000e8200087,0x00000000e8400087,0x00000000e8600087,
	0x00000000e8800087,0x00000000e8a00087,0x00000000e8c00087,0x00000000e8e00087,
	0x00000000e9000087,0x00000000e9200087,0x00000000e9400087,0x00000000e9600087,
	0x00000000e9800087,0x00000000e9a00087,0x00000000e9c00087,0x00000000e9e00087,
	0x00000000ea000087,0x00000000ea200087,0x00000000ea400087,0x00000000ea600087,
	0x00000000ea800087,0x00000000eaa00087,0x00000000eac00087,0x00000000eae00087,
	0x00000000eb000087,0x00000000eb200087,0x00000000eb400087,0x00000000eb600087,
	0x00000000eb800087,0x00000000eba00087,0x00000000ebc00087,0x00000000ebe00087,
	0x00000000ec000087,0x00000000ec200087,0x00000000ec400087,0x00000000ec600087,
	0x00000000ec800087,0x00000000eca00087,0x00000000ecc00087,0x00000000ece00087,
	0x00000000ed000087,0x00000000ed200087,0x00000000ed400087,0x00000000ed600087,
	0x00000000ed800087,0x00000000eda00087,0x00000000edc00087,0x00000000ede00087,
	0x00000000ee000087,0x00000000ee200087,0x00000000ee400087,0x00000000ee600087,
	0x00000000ee800087,0x00000000eea00087,0x00000000eec00087,0x00000000eee00087,
	0x00000000ef000087,0x00000000ef200087,0x00000000ef400087,0x00000000ef600087,
	0x00000000ef800087,0x00000000efa00087,0x00000000efc00087,0x00000000efe00087,
	0x00000000f0000087,0x00000000f0200087,0x00000000f0400087,0x00000000f0600087,
	0x00000000f0800087,0x00000000f0a00087,0x00000000f0c00087,0x00000000f0e00087,
	0x00000000f1000087,0x00000000f1200087,0x00000000f1400087,0x00000000f1600087,
	0x00000000f1800087,0x00000000f1a00087,0x00000000f1c00087,0x00000000f1e00087,
	0x00000000f2000087,0x00000000f2200087,0x00000000f2400087,0x00000000f2600087,
	0x00000000f2800087,0x00000000f2a00087,0x00000000f2c00087,0x00000000f2e00087,
	0x00000000f3000087,0x00000000f3200087,0x00000000f3400087,0x00000000f3600087,
	0x00000000f3800087,0x00000000f3a00087,0x00000000f3c00087,0x00000000f3e00087,
	0x00000000f4000087,0x00000000f4200087,0x00000000f4400087,0x00000000f4600087,
	0x00000000f4800087,0x00000000f4a00087,0x00000000f4c00087,0x00000000f4e00087,
	0x00000000f5000087,0x00000000f5200087,0x00000000f5400087,0x00000000f5600087,
	0x00000000f5800087,0x00000000f5a00087,0x00000000f5c00087,0x00000000f5e00087,
	0x00000000f6000087,0x00000000f6200087,0x00000000f6400087,0x00000000f6600087,
	0x00000000f6800087,0x00000000f6a00087,0x00000000f6c00087,0x00000000f6e00087,
	0x00000000f7000087,0x00000000f7200087,0x00000000f7400087,0x00000000f7600087,
	0x00000000f7800087,0x00000000f7a00087,0x00000000f7c00087,0x00000000f7e00087,
	0x00000000f8000087,0x00000000f8200087,0x00000000f8400087,0x00000000f8600087,
	0x00000000f8800087,0x00000000f8a00087,0x00000000f8c00087,0x00000000f8e00087,
	0x00000000f9000087,0x00000000f9200087,0x00000000f9400087,0x00000000f9600087,
	0x00000000f9800087,0x00000000f9a00087,0x00000000f9c00087,0x00000000f9e00087,
	0x00000000fa000087,0x00000000fa200087,0x00000000fa400087,0x00000000fa600087,
	0x00000000fa800087,0x00000000faa00087,0x00000000fac00087,0x00000000fae00087,
	0x00000000fb000087,0x00000000fb200087,0x00000000fb400087,0x00000000fb600087,
	0x00000000fb800087,0x00000000fba00087,0x00000000fbc00087,0x00000000fbe00087,
	0x00000000fc000087,0x00000000fc200087,0x00000000fc400087,0x00000000fc600087,
	0x00000000fc800087,0x00000000fca00087,0x00000000fcc00087,0x00000000fce00087,
	0x00000000fd000087,0x00000000fd200087,0x00000000fd400087,0x00000000fd600087,
	0x00000000fd800087,0x00000000fda00087,0x00000000fdc00087,0x00000000fde00087,
	0x00000000fe000087,0x00000000fe200087,0x00000000fe400087,0x00000000fe600087,
	0x00000000fe800087,0x00000000fea00087,0x00000000fec00097,0x00000000fee00097,
	0x00000000ff000097,0x00000000ff200097,0x00000000ff400097,0x00000000ff600097,
	0x00000000ff800097,0x00000000ffa00097,0x00000000ffc00097,0x00000000ffe00097,
};

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pdpt[PAE_MAXPTRS_PER_PDPT] = {
    ((u64)(&_xcprimeon_init_pdt[0]) + (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER) ),
    ((u64)(&_xcprimeon_init_pdt[512]) + (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER) ),
    ((u64)(&_xcprimeon_init_pdt[1024]) + (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER) ),
    ((u64)(&_xcprimeon_init_pdt[1536]) + (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER) ),
    0
};

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pml4t[PAE_MAXPTRS_PER_PDPT] = {
    ((u64)(&_xcprimeon_init_pdpt) + (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER) ),
    0
};


__attribute__(( aligned(16) )) static u64 _xcprimeon_init_gdt_start[]  = {
	0x0000000000000000ULL,	//NULL descriptor
	0x00af9b000000ffffULL,	//CPL-0 64-bit code descriptor (CS64)
	0x00af93000000ffffULL,	//CPL-0 64-bit data descriptor (DS/SS/ES/FS/GS)
};

__attribute__(( aligned(16) )) static arch_x86_gdtdesc_t _xcprimeon_init_gdt  = {
	.size=sizeof(_xcprimeon_init_gdt_start)-1,
	.base=&_xcprimeon_init_gdt_start,
};


__attribute__((naked)) __attribute__ ((section(".hic_entrystub"))) __attribute__(( align(4096) )) void xcprimeon_arch_entry(void) {

	asm volatile (
                    ".code32 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 0x80, 1, 0x90\r\n" //TODO: should really be sizeof(mle_hdr_t)
					"_xcprimeon_start: \r\n"

					"movw %%ds, %%ax \r\n"
					"movw %%ax, %%es \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"

					"movl $0x10200000, %%esp \r\n" //TODO: get rid of hard-coded stack top

    				"movl %%cr4, %%eax \r\n"
   					"orl $0x00000030, %%eax \r\n"
   					"movl %%eax, %%cr4 \r\n"

                    "movl %0, %%eax \r\n"
                    "movl %%eax, %%cr3 \r\n"

                    "movl $0xc0000080, %%ecx \r\n"
                    "rdmsr \r\n"
                    "orl $0x00000100, %%eax \r\n"
                    "orl $0x00000800, %%eax \r\n"
                    "wrmsr \r\n"

                    "movl $0x80000015, %%eax \r\n"
                    "movl %%eax, %%cr0 \r\n"

                    "movl %1, %%esi \r\n"
                    "lgdt (%%esi) \r\n"

                    "pushl $8 \r\n"
                    "pushl $_xcprimeon_start64 \r\n"
                    "lret \r\n"

                    ".code64 \r\n"
                    "_xcprimeon_start64: \r\n"

					"movw $0x10, %%ax \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"
					"movw %%ax, %%ds \r\n"
					"movw %%ax, %%es \r\n"

					"xorq %%rsp, %%rsp \r\n"
					"movl $0x10200000, %%esp \r\n" //TODO: get rid of hard-coded stack top

                    "jmp xmhfhic_entry \r\n"
			    :
			    : "i" (&_xcprimeon_init_pml4t), "i" (&_xcprimeon_init_gdt)
                :
	);
}



void xmhfhic_entry(void){
    u64 pgtblbase;

#if !defined(__XMHF_VERIFICATION__)
	//initialize debugging early on
	xmhfhw_platform_serial_init((char *)&xcbootinfo->debugcontrol_buffer);


	//[debug] print relevant startup info.
	_XDPRINTF_("%s: alive and starting...\n", __FUNCTION__);

	_XDPRINTF_("    xcbootinfo at = 0x%08x\n", (u32)xcbootinfo);
	_XDPRINTF_("	numE820Entries=%u\n", xcbootinfo->memmapinfo_numentries);
	_XDPRINTF_("	system memory map buffer at 0x%08x\n", (u32)&xcbootinfo->memmapinfo_buffer);
	_XDPRINTF_("	numCPUEntries=%u\n", xcbootinfo->cpuinfo_numentries);
	_XDPRINTF_("	cpuinfo buffer at 0x%08x\n", (u32)&xcbootinfo->cpuinfo_buffer);
	_XDPRINTF_("	XMHF size= %u bytes\n", __TARGET_SIZE_XMHF);
	_XDPRINTF_("	OS bootmodule at 0x%08x, size=%u bytes\n",
		xcbootinfo->richguest_bootmodule_base, xcbootinfo->richguest_bootmodule_size);
    _XDPRINTF_("\tcmdline = \"%s\"\n", xcbootinfo->cmdline_buffer);
	_XDPRINTF_("SL: runtime at 0x%08x; size=0x%08x bytes\n", __TARGET_BASE_XMHF, __TARGET_SIZE_XMHF);
	_XDPRINTF_("SL: XMHF_BOOTINFO at 0x%08x, magic=0x%08x\n", (u32)xcbootinfo, xcbootinfo->magic);
	HALT_ON_ERRORCOND(xcbootinfo->magic == RUNTIME_PARAMETER_BLOCK_MAGIC);
 	_XDPRINTF_("\nNumber of E820 entries = %u", xcbootinfo->memmapinfo_numentries);
	{
		u32 i;
		for(i=0; i < (u32)xcbootinfo->memmapinfo_numentries; i++){
			_XDPRINTF_("\n0x%08x%08x, size=0x%08x%08x (%u)",
			  xcbootinfo->memmapinfo_buffer[i].baseaddr_high, xcbootinfo->memmapinfo_buffer[i].baseaddr_low,
			  xcbootinfo->memmapinfo_buffer[i].length_high, xcbootinfo->memmapinfo_buffer[i].length_low,
			  xcbootinfo->memmapinfo_buffer[i].type);
		}
  	}
#endif

    //initialize slab info table based on setup data
    xmhfhic_arch_setup_slab_info();

    //sanity check HIC (hardware) requirements
    xmhfhic_arch_sanity_check_requirements();

    //setup slab system device allocation and device page tables
    //xmhfhic_arch_setup_slab_device_allocation();

    //setup slab memory page tables
    //xmhfhic_arch_setup_slab_mem_page_tables();

    //setup base CPU data structures
    xmhfhic_arch_setup_base_cpu_data_structures();

    //setup SMP and move on to xmhfhic_smp_entry
    xmhfhic_arch_switch_to_smp();

    //we should never get here
    _XDPRINTF_("Should never be here. Halting!\n");
    HALT();
}


void xmhfhic_smp_entry(u64 cpuid){
    bool isbsp = (cpuid & 0x8000000000000000ULL) ? true : false;
    #if defined (__XMHF_VERIFICATION__)
    cpuid = 0;
    isbsp = true;
    #endif // defined

    _XDPRINTF_("%s[%u,%u]: rsp=%016llx. Starting...\n",
            __FUNCTION__, cpuid, isbsp, read_rsp());

    xmhf_hic_arch_setup_cpu_state(cpuid);

    //relinquish HIC initialization and move on to the first slab
    //xmhfhic_arch_relinquish_control_to_init_slab(cpuid);

    _XDPRINTF_("%s[%u,%u]: Should never be here. Halting!\n", __FUNCTION__, cpuid, isbsp);
    HALT();

}



//////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////
// setup slab info

void xmhfhic_arch_setup_slab_info(void){

    //initialize slab info table
    {
        u32 i;

        for(i=0; i < XMHF_HIC_MAX_SLABS; i++){

            _xmhfhic_common_slab_info_table[i].slab_inuse = true;
            _xmhfhic_common_slab_info_table[i].slab_privilegemask =
                _xmhfhic_init_setupdata_slab_caps[i].slab_privilegemask;
            _xmhfhic_common_slab_info_table[i].slab_callcaps =
                _xmhfhic_init_setupdata_slab_caps[i].slab_callcaps;
            _xmhfhic_common_slab_info_table[i].slab_uapicaps =
                _xmhfhic_init_setupdata_slab_caps[i].slab_uapicaps;


            #if !defined(__XMHF_VERIFICATION__)
            memcpy(&_xmhfhic_common_slab_info_table[i].slab_devices,
                   &_xmhfhic_init_setupdata_slab_caps[i].slab_devices,
                   sizeof(_xmhfhic_common_slab_info_table[0].slab_devices));

            memcpy(_xmhfhic_common_slab_info_table[i].slab_physmem_extents,
                   _xmhfhic_init_setupdata_slab_physmem_extents[i],
                   sizeof(_xmhfhic_common_slab_info_table[0].slab_physmem_extents));
            #endif

            _xmhfhic_common_slab_info_table[i].entrystub = _xmhfhic_common_slab_info_table[i].slab_physmem_extents[0].addr_start;

            //arch. specific
            _xmhfhic_common_slab_info_table[i].archdata.slabtype =
                _xmhfhic_init_setupdata_slab_caps[i].slab_archparams;

            _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_initialized=false;
            _xmhfhic_common_slab_info_table[i].archdata.devpgtbl_initialized=false;

            #if !defined(__XMHF_VERIFICATION__)
            {
                u32 j;
                u64 *slab_stackhdr = (u64 *)_xmhfhic_common_slab_info_table[i].slab_physmem_extents[3].addr_start;
                if(slab_stackhdr){
                    for(j=0; j < MAX_PLATFORM_CPUS; j++)
                        _xmhfhic_common_slab_info_table[i].archdata.slabtos[j]=slab_stackhdr[j];
                }
            }
            #endif

        }
    }


    #if !defined (__XMHF_VERIFICATION__)
    //initialize HIC physical memory extents
    memcpy(_xmhfhic_common_hic_physmem_extents,
           _xmhfhic_init_setupdata_hic_physmem_extents,
           sizeof(_xmhfhic_common_hic_physmem_extents));
    #endif

    #if !defined (__XMHF_VERIFICATION__)
	//print out HIC section information
    {
		_XDPRINTF_("xmhfhic section info:\n");
		_XDPRINTF_("  xmhfhic sharedro(%08x-%08x)\n", _xmhfhic_common_hic_physmem_extents[0].addr_start, _xmhfhic_common_hic_physmem_extents[0].addr_end);
		_XDPRINTF_("  xmhfhic code(%08x-%08x)\n", _xmhfhic_common_hic_physmem_extents[1].addr_start, _xmhfhic_common_hic_physmem_extents[1].addr_end);
		_XDPRINTF_("  xmhfhic rwdata(%08x-%08x)\n", _xmhfhic_common_hic_physmem_extents[2].addr_start, _xmhfhic_common_hic_physmem_extents[2].addr_end);
		_XDPRINTF_("  xmhfhic rodata(%08x-%08x)\n", _xmhfhic_common_hic_physmem_extents[3].addr_start, _xmhfhic_common_hic_physmem_extents[3].addr_end);
		_XDPRINTF_("  xmhfhic stack(%08x-%08x)\n", _xmhfhic_common_hic_physmem_extents[4].addr_start, _xmhfhic_common_hic_physmem_extents[4].addr_end);

    }

	//print out slab table
	{
			u32 i;

			for(i=0; i < XMHF_HIC_MAX_SLABS; i++){
				_XDPRINTF_("slab %u: dumping slab header\n", i);
				_XDPRINTF_("	slabtype=%08x\n", _xmhfhic_common_slab_info_table[i].archdata.slabtype);
				_XDPRINTF_("	slab_inuse=%s\n", ( _xmhfhic_common_slab_info_table[i].slab_inuse ? "true" : "false") );
				//_XDPRINTF_("	slab_macmid=%08x\n", _xmhfhic_common_slab_info_table[i].slab_macmid);
				_XDPRINTF_("	slab_privilegemask=%08x\n", _xmhfhic_common_slab_info_table[i].slab_privilegemask);
				_XDPRINTF_("	slab_callcaps=%08x\n", _xmhfhic_common_slab_info_table[i].slab_callcaps);
				_XDPRINTF_("	slab_devices=%s\n", ( _xmhfhic_common_slab_info_table[i].slab_devices.desc_valid ? "true" : "false") );
				//_XDPRINTF_("	slab_tos=%08x\n", _xmhfhic_common_slab_info_table[i].slab_tos);
				_XDPRINTF_("  slab_code(%08x-%08x)\n", _xmhfhic_common_slab_info_table[i].slab_physmem_extents[0].addr_start, _xmhfhic_common_slab_info_table[i].slab_physmem_extents[0].addr_end);
				_XDPRINTF_("  slab_rwdata(%08x-%08x)\n", _xmhfhic_common_slab_info_table[i].slab_physmem_extents[1].addr_start, _xmhfhic_common_slab_info_table[i].slab_physmem_extents[1].addr_end);
				_XDPRINTF_("  slab_rodata(%08x-%08x)\n", _xmhfhic_common_slab_info_table[i].slab_physmem_extents[2].addr_start, _xmhfhic_common_slab_info_table[i].slab_physmem_extents[2].addr_end);
				_XDPRINTF_("  slab_stack(%08x-%08x)\n", _xmhfhic_common_slab_info_table[i].slab_physmem_extents[3].addr_start, _xmhfhic_common_slab_info_table[i].slab_physmem_extents[3].addr_end);
				_XDPRINTF_("  slab_dmadata(%08x-%08x)\n", _xmhfhic_common_slab_info_table[i].slab_physmem_extents[4].addr_start, _xmhfhic_common_slab_info_table[i].slab_physmem_extents[4].addr_end);
				_XDPRINTF_("  slab_entrystub=%08x\n", _xmhfhic_common_slab_info_table[i].entrystub);

                {
                    u32 j;

                    for(j=0; j < MAX_PLATFORM_CPUS; j++)
                        _XDPRINTF_("     CPU %u: stack TOS=%016llx\n", j,
                               _xmhfhic_common_slab_info_table[i].archdata.slabtos[j]);
                }

		}
	}
    #endif



}








///////////////////////////////////////////////////////////////
// sanity check HIC (hardware) requirements
void xmhfhic_arch_sanity_check_requirements(void){
	u32 cpu_vendor;

	//grab CPU vendor
	cpu_vendor = xmhf_baseplatform_arch_getcpuvendor();
	if (cpu_vendor != CPU_VENDOR_INTEL){
		_XDPRINTF_("%s: not an Intel CPU but running VMX backend. Halting!\n", __FUNCTION__);
		HALT();
	}

	//check VMX support
	{
		u32	cpu_features;
		u32 res0,res1,res2;

		cpuid(0x1, &res0, &res1, &cpu_features, &res2);

		if ( ( cpu_features & (1<<5) ) == 0 ){
			_XDPRINTF_("No VMX support. Halting!\n");
			HALT();
		}
	}

	//we require unrestricted guest and EPT support, bail out if we don't have it
    {
        u64 msr_procctls2 = rdmsr64(IA32_VMX_PROCBASED_CTLS2_MSR);
        if( !( (msr_procctls2 >> 32) & 0x80 ) ){
            _XDPRINTF_("%s: need unrestricted guest support but did not find any!\n", __FUNCTION__);
            HALT();
        }

        if( !( (msr_procctls2 >> 32) & 0x2) ){
            _XDPRINTF_("%s: need EPTt support but did not find any!\n", __FUNCTION__);
            HALT();
        }

    }


}























//////////////////////////////////////////////////////////////////////////////
//setup slab device allocation (sda)


__attribute__((aligned(4096))) static vtd_ret_entry_t _vtd_ret[VTD_RET_MAXPTRS];
__attribute__((aligned(4096))) static vtd_cet_entry_t _vtd_cet[VTD_RET_MAXPTRS][VTD_CET_MAXPTRS];

static vtd_drhd_handle_t vtd_drhd_maxhandle=0;
static u32 vtd_pagewalk_level = VTD_PAGEWALK_NONE;
static bool vtd_initialized = false;

static u64 _platform_x86pc_vtd_setup_retcet(void){
    u32 i, j;

    for(i=0; i< VTD_RET_MAXPTRS; i++){
        _vtd_ret[i].qwords[0] = _vtd_ret[i].qwords[1] = 0ULL;
        _vtd_ret[i].fields.p = 1;
        _vtd_ret[i].fields.ctp = ((u64)&_vtd_cet[i] >> 12);

        for(j=0; j < VTD_CET_MAXPTRS; j++){
            _vtd_cet[i][j].qwords[0] = _vtd_cet[i][j].qwords[1] = 0ULL;
        }
    }

    return (u64)&_vtd_ret;
}

//initialize vtd hardware and setup vtd_drhd_maxhandle and _vtd_pagewalk_level
//to appropriate values. if everything went well set vtd_initialized to true
static bool _platform_x86pc_vtd_initialize(void){
    u64 vtd_ret_addr;
	vtd_drhd_handle_t drhd_handle;
	u32 vtd_dmar_table_physical_address=0;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i, b, d, f;

    //if we already setup vtd then simply return true
    if(vtd_initialized)
        return true;

	//setup basic RET/CET structure; will initially prevent DMA reads and writes
	//for the entire system
    vtd_ret_addr = _platform_x86pc_vtd_setup_retcet();

	//scan for available DRHD units in the platform
	if(!xmhfhw_platform_x86pc_vtd_scanfor_drhd_units(&vtd_drhd_maxhandle, &vtd_dmar_table_physical_address)){
        _XDPRINTF_("%s: unable to scan for DRHD units. bailing out!\n", __FUNCTION__);
		return false;
	}

    _XDPRINTF_("%s: maxhandle = %u, dmar table addr=0x%08x\n", __FUNCTION__,
                (u32)vtd_drhd_maxhandle, (u32)vtd_dmar_table_physical_address);

	//initialize all DRHD units
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
   		VTD_CAP_REG cap;

		_XDPRINTF_("%s: Setting up DRHD unit %u...\n", __FUNCTION__, drhd_handle);

		if(!xmhfhw_platform_x86pc_vtd_drhd_initialize(drhd_handle) ){
            _XDPRINTF_("%s: error setting up DRHD unit %u. bailing out!\n", __FUNCTION__, drhd_handle);
			return false;
		}

        //read and store DRHD supported page-walk length
        cap.value = xmhfhw_platform_x86pc_vtd_drhd_reg_read(drhd_handle, VTD_CAP_REG_OFF);
        if(cap.bits.sagaw & 0x2){
            if(vtd_pagewalk_level == VTD_PAGEWALK_NONE || vtd_pagewalk_level == VTD_PAGEWALK_3LEVEL){
                vtd_pagewalk_level = VTD_PAGEWALK_3LEVEL;
                _XDPRINTF_("%s: DRHD unit %u - 3-level page-walk\n", __FUNCTION__, drhd_handle);
            }else{
                _XDPRINTF_("%s: Halting: mixed hardware supported page-walk lengths\n",
                            __FUNCTION__);
                HALT();
            }
        }

        if(cap.bits.sagaw & 0x4){
            if(vtd_pagewalk_level == VTD_PAGEWALK_NONE || vtd_pagewalk_level == VTD_PAGEWALK_4LEVEL){
                vtd_pagewalk_level = VTD_PAGEWALK_4LEVEL;
                _XDPRINTF_("%s: DRHD unit %u - 4-level page-walk\n", __FUNCTION__, drhd_handle);
            }else{
                _XDPRINTF_("%s: Halting: mixed hardware supported page-walk lengths\n",
                            __FUNCTION__);
                HALT();
            }
        }


		//set DRHD root entry table
		if(!xmhfhw_platform_x86pc_vtd_drhd_set_root_entry_table(drhd_handle, vtd_ret_addr))
			return false;

		//invalidate caches
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;

		//enable VT-d translation
		xmhfhw_platform_x86pc_vtd_drhd_enable_translation(drhd_handle);

		//disable PMRs now (since DMA protection is active via translation)
		xmhfhw_platform_x86pc_vtd_drhd_disable_pmr(drhd_handle);

		_XDPRINTF_("%s: Successfully setup DRHD unit %u\n", __FUNCTION__, drhd_handle);
	}

	//zap VT-d presence in ACPI table...
	//TODO: we need to be a little elegant here. eventually need to setup
	//EPT/NPTs such that the DMAR pages are unmapped for the guest
	xmhfhw_sysmemaccess_writeu32(vtd_dmar_table_physical_address, 0UL);


    _XDPRINTF_("%s: final page-walk level=%u\n", __FUNCTION__, vtd_pagewalk_level);

    vtd_initialized = true;

    return true;
}

#if !defined (__XMHF_VERIFICATION__)
static vtd_slpgtbl_handle_t _platform_x86pc_vtd_setup_slpgtbl(u32 slabid){
    vtd_slpgtbl_handle_t retval = {0, 0};
    u32 i, j, k, paddr=0;

    //sanity check partition index
    if(slabid > XMHF_HIC_MAX_SLABS){
        _XDPRINTF_("%s: Error: slabid (%u) > XMHF_HIC_MAX_SLABS(%u). bailing out!\n", __FUNCTION__, slabid, XMHF_HIC_MAX_SLABS);
        return retval;
    }


    //setup device memory access for the partition
    _dbuf_devpgtbl[slabid].pml4t[0].fields.r = 1;
    _dbuf_devpgtbl[slabid].pml4t[0].fields.w = 1;
    _dbuf_devpgtbl[slabid].pml4t[0].fields.slpdpt =
        ((u64)_dbuf_devpgtbl[slabid].pdpt >> 12);

    for(i=0; i < PAE_PTRS_PER_PDPT; i++){
        _dbuf_devpgtbl[slabid].pdpt[i].fields.r = 1;
        _dbuf_devpgtbl[slabid].pdpt[i].fields.w = 1;
        _dbuf_devpgtbl[slabid].pdpt[i].fields.slpdt =
            ((u64)_dbuf_devpgtbl[slabid].pdt[i] >> 12);

        for(j=0; j < PAE_PTRS_PER_PDT; j++){
            _dbuf_devpgtbl[slabid].pdt[i][j].fields.r = 1;
            _dbuf_devpgtbl[slabid].pdt[i][j].fields.w = 1;
            _dbuf_devpgtbl[slabid].pdt[i][j].fields.slpt =
                ((u64)_dbuf_devpgtbl[slabid].pt[i][j] >> 12);

            for(k=0; k < PAE_PTRS_PER_PT; k++){
                _dbuf_devpgtbl[slabid].pt[i][j][k].fields.r = 1;
                _dbuf_devpgtbl[slabid].pt[i][j][k].fields.w = 1;
                _dbuf_devpgtbl[slabid].pt[i][j][k].fields.pageaddr = ((u64)paddr >> 12);
                paddr += PAGE_SIZE_4K;
            }
        }
    }

    //populate device page tables pml4t, pdpt, pdt and pt pointers in slab info table
    _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl_pml4t = &_dbuf_devpgtbl[slabid].pml4t;
    _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl_pdpt = &_dbuf_devpgtbl[slabid].pdpt;
    _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl_pdt = &_dbuf_devpgtbl[slabid].pdt;
    _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl_pt = &_dbuf_devpgtbl[slabid].pt;



    /*//setup device memory access for the partition
    _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pml4t[0].fields.r = 1;
    _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pml4t[0].fields.w = 1;
    _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pml4t[0].fields.slpdpt = ((u64)&_xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdpt >> 12);

    for(i=0; i < PAE_PTRS_PER_PDPT; i++){
        _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdpt[i].fields.r = 1;
        _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdpt[i].fields.w = 1;
        _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdpt[i].fields.slpdt = ((u64)&_xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdt[i] >> 12);

        for(j=0; j < PAE_PTRS_PER_PDT; j++){
            _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdt[i][j].fields.r = 1;
            _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdt[i][j].fields.w = 1;
            _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdt[i][j].fields.slpt = ((u64)&_xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pt[i][j] >> 12);

            for(k=0; k < PAE_PTRS_PER_PT; k++){
                _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pt[i][j][k].fields.r = 1;
                _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pt[i][j][k].fields.w = 1;
                _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pt[i][j][k].fields.pageaddr = ((u64)paddr >> 12);
                paddr += PAGE_SIZE_4K;
            }
        }
    }*/

    retval.addr_vtd_pml4t = _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl_pml4t;
    retval.addr_vtd_pdpt = _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl_pdpt;

    return retval;
}
#endif

//static xc_platformdevice_desc_t __xmhfhic_arch_initializeandenumeratedevices(context_desc_t context_desc){
static slab_platformdevices_t __xmhfhic_arch_initializeandenumeratedevices(void){
    slab_platformdevices_t result;
    u32 b, d, f;

    result.desc_valid = false;
    result.numdevices = 0;

    //initialize vtd hardware (if it has not been initialized already)
    if(!_platform_x86pc_vtd_initialize())
        return result;

    //enumerate PCI bus to find out all the devices
	//bus numbers range from 0-255, device from 0-31 and function from 0-7
	for(b=0; b < PCI_BUS_MAX; b++){
		for(d=0; d < PCI_DEVICE_MAX; d++){
			for(f=0; f < PCI_FUNCTION_MAX; f++){
				u32 vendor_id, device_id;

				//read device and vendor ids, if no device then both will be 0xFFFF
				xmhf_baseplatform_arch_x86_pci_type1_read(b, d, f, PCI_CONF_HDR_IDX_VENDOR_ID, sizeof(u16), &vendor_id);
				xmhf_baseplatform_arch_x86_pci_type1_read(b, d, f, PCI_CONF_HDR_IDX_DEVICE_ID, sizeof(u16), &device_id);
				if(vendor_id == 0xFFFF && device_id == 0xFFFF)
					break;

                result.arch_desc[result.numdevices].pci_bus=b;
                result.arch_desc[result.numdevices].pci_device=d;
                result.arch_desc[result.numdevices].pci_function=f;
                result.arch_desc[result.numdevices].vendor_id=vendor_id;
                result.arch_desc[result.numdevices].device_id=device_id;

                result.numdevices++;
			}
		}
	}

    result.desc_valid = true;
    return result;
}


static bool __xmhfhic_arch_sda_allocdevices_to_slab(u64 slabid, slab_platformdevices_t device_descs){
	vtd_drhd_handle_t drhd_handle;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i;

    if(!vtd_initialized)
        return false;

    if(!device_descs.desc_valid)
        return true;

    #if !defined (__XMHF_VERIFICATION__)
    //initialize slab device page tables (if it has not been initialized already)
    if( !_xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl_initialized ){
        vtd_slpgtbl_handle = _platform_x86pc_vtd_setup_slpgtbl(slabid);

        if(vtd_slpgtbl_handle.addr_vtd_pml4t == 0 &&
            vtd_slpgtbl_handle.addr_vtd_pdpt == 0){
            _XDPRINTF_("%s: unable to initialize vt-d pagetables for slab %u\n", __FUNCTION__, slabid);
            return false;
        }

        _xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl_initialized=true;
    }
    #endif


    for(i=0; i < device_descs.numdevices; i++){
        u32 b=device_descs.arch_desc[i].pci_bus;
        u32 d=device_descs.arch_desc[i].pci_device;
        u32 f=device_descs.arch_desc[i].pci_function;

        //sanity check b, d, f triad
        if ( !(b < PCI_BUS_MAX &&
               d < PCI_DEVICE_MAX &&
               f < PCI_FUNCTION_MAX) )
            return false;

        //b is our index into ret
        // (d* PCI_FUNCTION_MAX) + f = index into the cet
        #if !defined(__XMHF_VERIFICATION__)
        if(vtd_pagewalk_level == VTD_PAGEWALK_4LEVEL){
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.slptptr = ((u64)_xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pml4t >> 12);
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.aw = 2; //4-level
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.did = (slabid + 1); //domain
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.p = 1; //present
        }else if (vtd_pagewalk_level == VTD_PAGEWALK_3LEVEL){
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.slptptr = ((u64)_xmhfhic_common_slab_info_table[slabid].archdata.devpgtbl.pdpt >> 12);
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.aw = 1; //3-level
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.did = (slabid + 1); //domain
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.p = 1; //present
        }else{ //unknown page walk length, fail
            return false;
        }
        #endif
    }


	//invalidate vtd caches
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;
	}

    return true;
}


static bool __xmhfhic_arch_sda_deallocdevices_from_slab(u64 slabid, slab_platformdevices_t device_descs){
	vtd_drhd_handle_t drhd_handle;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i;

    if(!vtd_initialized)
        return false;

    for(i=0; i < device_descs.numdevices; i++){
        u32 b=device_descs.arch_desc[i].pci_bus;
        u32 d=device_descs.arch_desc[i].pci_device;
        u32 f=device_descs.arch_desc[i].pci_function;

        //sanity check b, d, f triad
        if ( !(b < PCI_BUS_MAX &&
               d < PCI_DEVICE_MAX &&
               f < PCI_FUNCTION_MAX) )
            return false;

        //b is our index into ret
        // (d* PCI_FUNCTION_MAX) + f = index into the cet
        _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].qwords[0] = 0;
        _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].qwords[1] = 0;
    }

	//invalidate vtd caches
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;
	}

    //TODO: update slab info to remove the devices from slab_devices

    return true;
}



static void __xmhfhic_x86vmxx86pc_postdrt(void){
	txt_heap_t *txt_heap;
	os_mle_data_t *os_mle_data;

	txt_heap = get_txt_heap();
	_XDPRINTF_("SL: txt_heap = 0x%08x\n", (u32)txt_heap);
	os_mle_data = get_os_mle_data_start((txt_heap_t*)((u32)txt_heap));
	_XDPRINTF_("SL: os_mle_data = 0x%08x\n", (u32)os_mle_data);

	// restore pre-SENTER MTRRs that were overwritten for SINIT launch
	if(!validate_mtrrs(&(os_mle_data->saved_mtrr_state))) {
		_XDPRINTF_("SECURITY FAILURE: validate_mtrrs() failed.\n");
		HALT();
	}
	_XDPRINTF_("SL: Validated MTRRs\n");

	xmhfhw_cpu_x86_restore_mtrrs(&(os_mle_data->saved_mtrr_state));
    _XDPRINTF_("SL: Restored MTRRs\n");
}


static slab_platformdevices_t __xmhfhic_arch_sda_get_devices_for_slab(u64 slabid, slab_platformdevices_t devices){
    slab_platformdevices_t retval;

    retval.desc_valid=false;
    retval.numdevices=0;

    //for now detect rich guest slab and allocate all platform devices to it
    if(_xmhfhic_common_slab_info_table[slabid].slab_devices.desc_valid &&
        _xmhfhic_common_slab_info_table[slabid].slab_devices.numdevices == 0xFFFFFFFFFFFFFFFFULL)
        return devices;
    else
        return retval;
}

void xmhfhic_arch_setup_slab_device_allocation(void){
    u32 i;
    slab_platformdevices_t ddescs;

#if defined (__DRT__)
    //post DRT cleanup first
    __xmhfhic_x86vmxx86pc_postdrt();
#endif	//__DRT__

	//initialize platform bus
	xmhfhw_platform_bus_init();

	//check ACPI subsystem
	{
		ACPI_RSDP rsdp;
		if(!xmhfhw_platform_x86pc_acpi_getRSDP(&rsdp)){
			_XDPRINTF_("%s: ACPI RSDP not found, Halting!\n", __FUNCTION__);
			HALT();
		}
	}

    //intialize VT-d and enumerate system devices
    ddescs = __xmhfhic_arch_initializeandenumeratedevices();

    if(!ddescs.desc_valid){
        _XDPRINTF_("%s: Error: could not obtain platform device descriptors\n",
                    __FUNCTION__);
        HALT();
    }

    for(i=0; i < ddescs.numdevices; i++){
        _XDPRINTF_("  %02x:%02x.%1x -> vendor_id=%04x, device_id=%04x\n", ddescs.arch_desc[i].pci_bus,
          ddescs.arch_desc[i].pci_device, ddescs.arch_desc[i].pci_function,
          ddescs.arch_desc[i].vendor_id, ddescs.arch_desc[i].device_id);
    }


    //TODO: for each slab, parse the list of devices allocated to it and allocate
    //the device to the slab
    for(i=0; i < XMHF_HIC_MAX_SLABS; i++){
        slab_platformdevices_t slab_ddescs;

        slab_ddescs = __xmhfhic_arch_sda_get_devices_for_slab(i, ddescs);

        if(slab_ddescs.desc_valid){
            _XDPRINTF_("%s: Allocating %u devices to slab %u...\n",
                            __FUNCTION__, slab_ddescs.numdevices, i);


            if(!__xmhfhic_arch_sda_allocdevices_to_slab(i, slab_ddescs)){
                    _XDPRINTF_("%s: Halting.unable to allocate devices to slab %u\n",
                                __FUNCTION__, i);
                    HALT();
            }
        }else{
            _XDPRINTF_("%s: No devices to allocate for slab %u...\n",
                            __FUNCTION__, i);
        }
    }

}





















//////////////////////////////////////////////////////////////////////////////
// setup slab memory page tables (smt)


#define	_SLAB_SPATYPE_OTHER_SLAB_MASK			(0xF0)

#define	_SLAB_SPATYPE_OTHER_SLAB_CODE			(0xF0)
#define	_SLAB_SPATYPE_OTHER_SLAB_RWDATA			(0xF1)
#define _SLAB_SPATYPE_OTHER_SLAB_RODATA			(0xF2)
#define _SLAB_SPATYPE_OTHER_SLAB_STACK			(0xF3)
#define _SLAB_SPATYPE_OTHER_SLAB_DMADATA        (0xF4)

#define	_SLAB_SPATYPE_SLAB_CODE					(0x0)
#define	_SLAB_SPATYPE_SLAB_RWDATA				(0x1)
#define _SLAB_SPATYPE_SLAB_RODATA				(0x2)
#define _SLAB_SPATYPE_SLAB_STACK				(0x3)
#define _SLAB_SPATYPE_SLAB_DMADATA				(0x4)

#define _SLAB_SPATYPE_HIC           			(0x5)
#define _SLAB_SPATYPE_HIC_SHAREDRO     			(0x6)

#define _SLAB_SPATYPE_OTHER	    				(0xFF00)

static u32 __xmhfhic_hyp_slab_getspatype(u64 slab_index, u32 spa){
	u64 i;

	//slab memory regions
	for(i=0; i < XMHF_HIC_MAX_SLABS; i++){
		u64 mask = (i == slab_index) ? 0 : _SLAB_SPATYPE_OTHER_SLAB_MASK;

		if(spa >= _xmhfhic_common_slab_info_table[i].slab_physmem_extents[0].addr_start && spa < _xmhfhic_common_slab_info_table[i].slab_physmem_extents[0].addr_end)
			return _SLAB_SPATYPE_SLAB_CODE | mask;
		if(spa >= _xmhfhic_common_slab_info_table[i].slab_physmem_extents[1].addr_start && spa < _xmhfhic_common_slab_info_table[i].slab_physmem_extents[1].addr_end)
			return _SLAB_SPATYPE_SLAB_RWDATA | mask;
		if(spa >= _xmhfhic_common_slab_info_table[i].slab_physmem_extents[2].addr_start && spa < _xmhfhic_common_slab_info_table[i].slab_physmem_extents[2].addr_end)
			return _SLAB_SPATYPE_SLAB_RODATA | mask;
		if(spa >= _xmhfhic_common_slab_info_table[i].slab_physmem_extents[3].addr_start && spa < _xmhfhic_common_slab_info_table[i].slab_physmem_extents[3].addr_end)
			return _SLAB_SPATYPE_SLAB_STACK | mask;
		if(spa >= _xmhfhic_common_slab_info_table[i].slab_physmem_extents[4].addr_start && spa < _xmhfhic_common_slab_info_table[i].slab_physmem_extents[4].addr_end)
			return _SLAB_SPATYPE_SLAB_DMADATA | mask;
	}

	//HIC shared ro region
	//TODO: add per shared data variable access policy rather than entire section
	if(spa >= _xmhfhic_common_hic_physmem_extents[0].addr_start && spa < _xmhfhic_common_hic_physmem_extents[0].addr_end)
		return _SLAB_SPATYPE_HIC_SHAREDRO;

	//HIC code,rodata,rwdat and stack
    if(spa >= _xmhfhic_common_hic_physmem_extents[1].addr_start && spa < _xmhfhic_common_hic_physmem_extents[1].addr_end)
		return _SLAB_SPATYPE_HIC;
    if(spa >= _xmhfhic_common_hic_physmem_extents[2].addr_start && spa < _xmhfhic_common_hic_physmem_extents[2].addr_end)
		return _SLAB_SPATYPE_HIC;
    if(spa >= _xmhfhic_common_hic_physmem_extents[3].addr_start && spa < _xmhfhic_common_hic_physmem_extents[3].addr_end)
		return _SLAB_SPATYPE_HIC;
    if(spa >= _xmhfhic_common_hic_physmem_extents[4].addr_start && spa < _xmhfhic_common_hic_physmem_extents[4].addr_end)
		return _SLAB_SPATYPE_HIC;


	return _SLAB_SPATYPE_OTHER;
}

static u64 __xmhfhic_hyp_slab_getptflagsforspa(u64 slabid, u32 spa){
	u64 flags;
	u32 spatype = __xmhfhic_hyp_slab_getspatype(slabid, spa);
	//_XDPRINTF_("\n%s: slab_index=%u, spa=%08x, spatype = %x\n", __FUNCTION__, slab_index, spa, spatype);

	switch(spatype){
		case _SLAB_SPATYPE_OTHER_SLAB_CODE:
		case _SLAB_SPATYPE_OTHER_SLAB_RWDATA:
		case _SLAB_SPATYPE_OTHER_SLAB_RODATA:
		case _SLAB_SPATYPE_OTHER_SLAB_STACK:
		case _SLAB_SPATYPE_OTHER_SLAB_DMADATA:
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE);
			break;

		case _SLAB_SPATYPE_SLAB_CODE:
			flags = (u64)(_PAGE_PRESENT | _PAGE_PSE | _PAGE_USER);
			break;
		case _SLAB_SPATYPE_SLAB_RODATA:
			flags = (u64)(_PAGE_PRESENT | _PAGE_PSE | _PAGE_NX | _PAGE_USER);
			break;
		case _SLAB_SPATYPE_SLAB_RWDATA:
		case _SLAB_SPATYPE_SLAB_STACK:
		case _SLAB_SPATYPE_SLAB_DMADATA:
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_NX | _PAGE_PSE | _PAGE_USER);
			break;

		case _SLAB_SPATYPE_HIC_SHAREDRO:
            flags = (u64)(_PAGE_PRESENT | _PAGE_RW  | _PAGE_PSE | _PAGE_USER);
			break;

        case _SLAB_SPATYPE_HIC:
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE);
			break;


		default:
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE | _PAGE_USER);
			if(spa == 0xfee00000 || spa == 0xfec00000) {
				//map some MMIO regions with Page Cache disabled
				//0xfed00000 contains Intel TXT config regs & TPM MMIO
				//0xfee00000 contains LAPIC base
				flags |= (u64)(_PAGE_PCD);
			}
			break;
	}


	return flags;
}

#if !defined (__XMHF_VERIFICATION__)
//
// initialize slab page tables for a given slab index, returns the macm base
static u64 __xmhfhic_arch_smt_slab_populate_hyp_pagetables(u64 slabid){
		u32 i, j;
		u64 default_flags = (u64)(_PAGE_PRESENT) | (u64)(_PAGE_USER) | (u64)(_PAGE_RW);

        for(i=0; i < PAE_PTRS_PER_PML4T; i++){
            //_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pml4t[i] = pae_make_pml4e(hva2spa(&_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdpt), default_flags);
            _xmhfhic_common_slab_archdata_mempgtbl_pml4t[slabid][i] = pae_make_pml4e(hva2spa(&_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdpt), default_flags);
            //    if(slabid == 0){
            //        _XDPRINTF_("pml4t[%u] = %016llx\n", i, _xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pml4t[i]);
            //    }
        }

		for(i=0; i < PAE_PTRS_PER_PDPT; i++){
			_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdpt[i] = pae_make_pdpe(hva2spa(_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdt[i]), default_flags);
            //    if(slabid == 0){
            //        _XDPRINTF_("pdpt[%u] = %016llx\n", i, _xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdpt[i]);
            //    }
		}

		//init pdts with unity mappings
		for(i=0; i < PAE_PTRS_PER_PDPT; i++){
			for(j=0; j < PAE_PTRS_PER_PDT; j++){
				u32 hva = ((i * PAE_PTRS_PER_PDT) + j) * PAGE_SIZE_2M;
				u64 spa = hva2spa((void*)hva);
				u64 flags = __xmhfhic_hyp_slab_getptflagsforspa(slabid, (u32)spa);
				_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdt[i][j] = pae_make_pde_big(spa, flags);

                //if(slabid == 0){
                //    _XDPRINTF_("pdt[%u][%u] = %016llx\n", i, j, _xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdt[i][j]);
                //}
			}
		}

		//return _xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pml4t;
		return _xmhfhic_common_slab_archdata_mempgtbl_pml4t[slabid];
}
#endif



static struct _memorytype _vmx_ept_memorytypes[MAX_MEMORYTYPE_ENTRIES]; //EPT memory types array

static void __xmhfhic_vmx_gathermemorytypes(void);
static u32 __xmhfhic_vmx_getmemorytypeforphysicalpage(u64 pagebaseaddr);
static void __xmhfhic_vmx_setupEPT(u64 guestslab_id);

#if !defined (__XMHF_VERIFICATION__)
static void __xmhfhic_guestpgtbl_setentry(u64 slabid,  u64 gpa, u64 entry){
    u64 pdpt_index = pae_get_pdpt_index(gpa);
    u64 pd_index = pae_get_pdt_index(gpa);
    u64 pt_index = pae_get_pt_index(gpa);

    _xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pt[pdpt_index][pd_index][pt_index] = entry;

	return;
}
#endif

#if !defined (__XMHF_VERIFICATION__)
static void __xmhfhic_guestpgtbl_establishshape(u64 slabid){
	u32 i, j;

    for(i=0; i < PAE_PTRS_PER_PML4T; i++)
        //_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pml4t[i] = (u64) (hva2spa((void*)_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdpt) | 0x7);
        _xmhfhic_common_slab_archdata_mempgtbl_pml4t[slabid][i] = (u64) (hva2spa((void*)_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdpt) | 0x7);

	for(i=0; i < PAE_PTRS_PER_PDPT; i++)
		_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdpt[i] = (u64) ( hva2spa((void*)_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdt[i]) | 0x7 );

	for(i=0; i < PAE_PTRS_PER_PDPT; i++){
		for(j=0; j < PAE_PTRS_PER_PDT; j++){
			_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pdt[i][j] = (u64) ( hva2spa((void*)_xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pt[i][j]) | 0x7 );
		}
	}
}
#endif


//---gather memory types for system physical memory------------------------------
static void __xmhfhic_vmx_gathermemorytypes(void){
 	u32 eax, ebx, ecx, edx;
	u32 index=0;
	u32 num_vmtrrs=0;	//number of variable length MTRRs supported by the CPU

	//0. sanity check
  	//check MTRR support
  	eax=0x00000001;
  	ecx=0x00000000;
	#ifndef __XMHF_VERIFICATION__
  	asm volatile ("cpuid\r\n"
            :"=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
            :"a"(eax), "c" (ecx));
  	#endif

  	if( !(edx & (u32)(1 << 12)) ){
  		_XDPRINTF_("\n%s: CPU does not support MTRRs!", __FUNCTION__);
  		HALT();
  	}

  	//check MTRR caps
  	rdmsr(IA32_MTRRCAP, &eax, &edx);
	num_vmtrrs = (u8)eax;
  	_XDPRINTF_("\nIA32_MTRRCAP: VCNT=%u, FIX=%u, WC=%u, SMRR=%u",
  		num_vmtrrs, ((eax & (1 << 8)) >> 8),  ((eax & (1 << 10)) >> 10),
  			((eax & (1 << 11)) >> 11));
	//sanity check that fixed MTRRs are supported
  	HALT_ON_ERRORCOND( ((eax & (1 << 8)) >> 8) );
  	//ensure number of variable MTRRs are within the maximum supported
  	HALT_ON_ERRORCOND( (num_vmtrrs <= MAX_VARIABLE_MEMORYTYPE_ENTRIES) );


	#ifndef __XMHF_VERIFICATION__
	//1. clear memorytypes array
	memset((void *)&_vmx_ept_memorytypes, 0, sizeof(struct _memorytype) * MAX_MEMORYTYPE_ENTRIES);
	#endif

	//2. grab memory types using FIXED MTRRs
    //0x00000000-0x0007FFFF
    rdmsr(IA32_MTRR_FIX64K_00000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x00000000; _vmx_ept_memorytypes[index].endaddr = 0x0000FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00010000; _vmx_ept_memorytypes[index].endaddr = 0x0001FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00020000; _vmx_ept_memorytypes[index].endaddr = 0x0002FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x00030000; _vmx_ept_memorytypes[index].endaddr = 0x0003FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x00040000; _vmx_ept_memorytypes[index].endaddr = 0x0004FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00050000; _vmx_ept_memorytypes[index].endaddr = 0x0005FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00060000; _vmx_ept_memorytypes[index].endaddr = 0x0006FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x00070000; _vmx_ept_memorytypes[index].endaddr = 0x0007FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x00080000-0x0009FFFF
  	rdmsr(IA32_MTRR_FIX16K_80000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x00080000; _vmx_ept_memorytypes[index].endaddr = 0x00083FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00084000; _vmx_ept_memorytypes[index].endaddr = 0x00087FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00088000; _vmx_ept_memorytypes[index].endaddr = 0x0008BFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x0008C000; _vmx_ept_memorytypes[index].endaddr = 0x0008FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x00090000; _vmx_ept_memorytypes[index].endaddr = 0x00093FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00094000; _vmx_ept_memorytypes[index].endaddr = 0x00097FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00098000; _vmx_ept_memorytypes[index].endaddr = 0x0009BFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x0009C000; _vmx_ept_memorytypes[index].endaddr = 0x0009FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000A0000-0x000BFFFF
	  rdmsr(IA32_MTRR_FIX16K_A0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000A0000; _vmx_ept_memorytypes[index].endaddr = 0x000A3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000A4000; _vmx_ept_memorytypes[index].endaddr = 0x000A7FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000A8000; _vmx_ept_memorytypes[index].endaddr = 0x000ABFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000AC000; _vmx_ept_memorytypes[index].endaddr = 0x000AFFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000B0000; _vmx_ept_memorytypes[index].endaddr = 0x000B3FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000B4000; _vmx_ept_memorytypes[index].endaddr = 0x000B7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000B8000; _vmx_ept_memorytypes[index].endaddr = 0x000BBFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000BC000; _vmx_ept_memorytypes[index].endaddr = 0x000BFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000C0000-0x000C7FFF
    rdmsr(IA32_MTRR_FIX4K_C0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000C0000; _vmx_ept_memorytypes[index].endaddr = 0x000C0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C1000; _vmx_ept_memorytypes[index].endaddr = 0x000C1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000C2000; _vmx_ept_memorytypes[index].endaddr = 0x000C2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000C3000; _vmx_ept_memorytypes[index].endaddr = 0x000C3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000C4000; _vmx_ept_memorytypes[index].endaddr = 0x000C4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C5000; _vmx_ept_memorytypes[index].endaddr = 0x000C5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000C6000; _vmx_ept_memorytypes[index].endaddr = 0x000C6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000C7000; _vmx_ept_memorytypes[index].endaddr = 0x000C7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000C8000-0x000C8FFF
	  rdmsr(IA32_MTRR_FIX4K_C8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000C8000; _vmx_ept_memorytypes[index].endaddr = 0x000C8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C9000; _vmx_ept_memorytypes[index].endaddr = 0x000C9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000CA000; _vmx_ept_memorytypes[index].endaddr = 0x000CAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000CB000; _vmx_ept_memorytypes[index].endaddr = 0x000CBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000CC000; _vmx_ept_memorytypes[index].endaddr = 0x000CCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000CD000; _vmx_ept_memorytypes[index].endaddr = 0x000CDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000CE000; _vmx_ept_memorytypes[index].endaddr = 0x000CEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000CF000; _vmx_ept_memorytypes[index].endaddr = 0x000CFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000D0000-0x000D7FFF
    rdmsr(IA32_MTRR_FIX4K_D0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000D0000; _vmx_ept_memorytypes[index].endaddr = 0x000D0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D1000; _vmx_ept_memorytypes[index].endaddr = 0x000D1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000D2000; _vmx_ept_memorytypes[index].endaddr = 0x000D2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000D3000; _vmx_ept_memorytypes[index].endaddr = 0x000D3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000D4000; _vmx_ept_memorytypes[index].endaddr = 0x000D4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D5000; _vmx_ept_memorytypes[index].endaddr = 0x000D5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000D6000; _vmx_ept_memorytypes[index].endaddr = 0x000D6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000D7000; _vmx_ept_memorytypes[index].endaddr = 0x000D7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000D8000-0x000DFFFF
  	rdmsr(IA32_MTRR_FIX4K_D8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000D8000; _vmx_ept_memorytypes[index].endaddr = 0x000D8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D9000; _vmx_ept_memorytypes[index].endaddr = 0x000D9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000DA000; _vmx_ept_memorytypes[index].endaddr = 0x000DAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000DB000; _vmx_ept_memorytypes[index].endaddr = 0x000DBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000DC000; _vmx_ept_memorytypes[index].endaddr = 0x000DCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000DD000; _vmx_ept_memorytypes[index].endaddr = 0x000DDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000DE000; _vmx_ept_memorytypes[index].endaddr = 0x000DEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000DF000; _vmx_ept_memorytypes[index].endaddr = 0x000DFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000E0000-0x000E7FFF
    rdmsr(IA32_MTRR_FIX4K_E0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000E0000; _vmx_ept_memorytypes[index].endaddr = 0x000E0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E1000; _vmx_ept_memorytypes[index].endaddr = 0x000E1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000E2000; _vmx_ept_memorytypes[index].endaddr = 0x000E2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000E3000; _vmx_ept_memorytypes[index].endaddr = 0x000E3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000E4000; _vmx_ept_memorytypes[index].endaddr = 0x000E4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E5000; _vmx_ept_memorytypes[index].endaddr = 0x000E5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000E6000; _vmx_ept_memorytypes[index].endaddr = 0x000E6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000E7000; _vmx_ept_memorytypes[index].endaddr = 0x000E7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000E8000-0x000EFFFF
	  rdmsr(IA32_MTRR_FIX4K_E8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000E8000; _vmx_ept_memorytypes[index].endaddr = 0x000E8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E9000; _vmx_ept_memorytypes[index].endaddr = 0x000E9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000EA000; _vmx_ept_memorytypes[index].endaddr = 0x000EAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000EB000; _vmx_ept_memorytypes[index].endaddr = 0x000EBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000EC000; _vmx_ept_memorytypes[index].endaddr = 0x000ECFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000ED000; _vmx_ept_memorytypes[index].endaddr = 0x000EDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000EE000; _vmx_ept_memorytypes[index].endaddr = 0x000EEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000EF000; _vmx_ept_memorytypes[index].endaddr = 0x000EFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000F0000-0x000F7FFF
  	rdmsr(IA32_MTRR_FIX4K_F0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000F0000; _vmx_ept_memorytypes[index].endaddr = 0x000F0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F1000; _vmx_ept_memorytypes[index].endaddr = 0x000F1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000F2000; _vmx_ept_memorytypes[index].endaddr = 0x000F2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000F3000; _vmx_ept_memorytypes[index].endaddr = 0x000F3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000F4000; _vmx_ept_memorytypes[index].endaddr = 0x000F4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F5000; _vmx_ept_memorytypes[index].endaddr = 0x000F5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000F6000; _vmx_ept_memorytypes[index].endaddr = 0x000F6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000F7000; _vmx_ept_memorytypes[index].endaddr = 0x000F7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000F8000-0x000FFFFF
  	rdmsr(IA32_MTRR_FIX4K_F8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000F8000; _vmx_ept_memorytypes[index].endaddr = 0x000F8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F9000; _vmx_ept_memorytypes[index].endaddr = 0x000F9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000FA000; _vmx_ept_memorytypes[index].endaddr = 0x000FAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000FB000; _vmx_ept_memorytypes[index].endaddr = 0x000FBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000FC000; _vmx_ept_memorytypes[index].endaddr = 0x000FCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000FD000; _vmx_ept_memorytypes[index].endaddr = 0x000FDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000FE000; _vmx_ept_memorytypes[index].endaddr = 0x000FEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000FF000; _vmx_ept_memorytypes[index].endaddr = 0x000FFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);


	//3. grab memory types using variable length MTRRs
	{
		u64 paddrmask = 0x0000000FFFFFFFFFULL; //36-bits physical address, TODO: need to make this dynamic
		u64 vMTRR_base, vMTRR_mask;
		u32 msrval=IA32_MTRR_PHYSBASE0;
		u32 i;

		for(i=0; i < num_vmtrrs; i++){
			rdmsr(msrval, &eax, &edx);
			vMTRR_base = ((u64)edx << 32) | (u64)eax;
			msrval++;
			rdmsr(msrval, &eax, &edx);
			vMTRR_mask = ((u64)edx << 32) | (u64)eax;
			msrval++;
			if( (vMTRR_mask & ((u64)1 << 11)) ){
				_vmx_ept_memorytypes[index].startaddr = (vMTRR_base & (u64)0xFFFFFFFFFFFFF000ULL);
				_vmx_ept_memorytypes[index].endaddr = (vMTRR_base & (u64)0xFFFFFFFFFFFFF000ULL) +
					(u64) (~(vMTRR_mask & (u64)0xFFFFFFFFFFFFF000ULL) &
						paddrmask);
				_vmx_ept_memorytypes[index++].type = ((u32)vMTRR_base & (u32)0x000000FF);
			}else{
				_vmx_ept_memorytypes[index++].invalid = 1;
			}
		}
	}

	_XDPRINTF_("\n%s: gathered MTRR details, number of entries=%u", __FUNCTION__, index);
	HALT_ON_ERRORCOND( index <= (MAX_MEMORYTYPE_ENTRIES+1) );

  //[debug: dump the contents of _vmx_ept_memorytypes]
  //{
  //  int i;
  //  for(i=0; i < MAX_MEMORYTYPE_ENTRIES; i++){
  //    _XDPRINTF_("\nrange  0x%016llx-0x%016llx (type=%u)",
  //      _vmx_ept_memorytypes[i].startaddr, _vmx_ept_memorytypes[i].endaddr, _vmx_ept_memorytypes[i].type);
  //  }
  //}


}

//---get memory type for a given physical page address--------------------------
//
//11.11.4.1 MTRR Precedences
//  0. if MTRRs are not enabled --> MTRR_TYPE_UC
//  if enabled then
     //if physaddr < 1MB use fixed MTRR ranges return type
     //else if within a valid variable range MTRR then
        //if a single match, return type
        //if two or more and one is UC, return UC
        //if two or more and WB and WT, return WT
        //else invalid combination
     //else
       // return default memory type
//
static u32 __xmhfhic_vmx_getmemorytypeforphysicalpage(u64 pagebaseaddr){
 int i;
 u32 prev_type= MTRR_TYPE_RESV;

  //check if page base address under 1M, if so used FIXED MTRRs
  if(pagebaseaddr < (1024*1024)){
    for(i=0; i < MAX_FIXED_MEMORYTYPE_ENTRIES; i++){
      if( pagebaseaddr >= _vmx_ept_memorytypes[i].startaddr && (pagebaseaddr+PAGE_SIZE_4K-1) <= _vmx_ept_memorytypes[i].endaddr )
        return _vmx_ept_memorytypes[i].type;
    }

    _XDPRINTF_("\n%s: endaddr < 1M and unmatched fixed MTRR. Halt!", __FUNCTION__);
    HALT();
  }

  //page base address is above 1M, use VARIABLE MTRRs
  for(i= MAX_FIXED_MEMORYTYPE_ENTRIES; i < MAX_MEMORYTYPE_ENTRIES; i++){
    if( pagebaseaddr >= _vmx_ept_memorytypes[i].startaddr && (pagebaseaddr+PAGE_SIZE_4K-1) <= _vmx_ept_memorytypes[i].endaddr &&
          (!_vmx_ept_memorytypes[i].invalid) ){
       if(_vmx_ept_memorytypes[i].type == MTRR_TYPE_UC){
        prev_type = MTRR_TYPE_UC;
       }else if(_vmx_ept_memorytypes[i].type == MTRR_TYPE_WT && prev_type != MTRR_TYPE_UC){
        prev_type = MTRR_TYPE_WT;
       }else{
        if(prev_type != MTRR_TYPE_UC && prev_type != MTRR_TYPE_WT){
          if(prev_type == MTRR_TYPE_RESV){
            prev_type = _vmx_ept_memorytypes[i].type;
          }else{
            _XDPRINTF_("\nprev_type=%u, _vmx_ept_memorytypes=%u", prev_type, _vmx_ept_memorytypes[i].type);
            HALT_ON_ERRORCOND ( prev_type == _vmx_ept_memorytypes[i].type);
          }
        }
       }
    }
  }

  if(prev_type == MTRR_TYPE_RESV)
    prev_type = MTRR_TYPE_WB; //todo: need to dynamically get the default MTRR (usually WB)

  return prev_type;
}


//---setup EPT for VMX----------------------------------------------------------
static void __xmhfhic_vmx_setupEPT(u64 slabid){
	u64 p_table_value;
	u64 gpa;
    //slab_retval_t srval;

	for(gpa=0; gpa < ADDR_4GB; gpa += PAGE_SIZE_4K){
		u32 memorytype = __xmhfhic_vmx_getmemorytypeforphysicalpage((u64)gpa);
		//make XMHF physical pages inaccessible
		//if( (gpa >= (__TARGET_BASE_XMHF)) &&
		//	(gpa < (__TARGET_BASE_XMHF + __TARGET_SIZE_XMHF)) ){
		//	p_table_value = (u64) (gpa)  | ((u64)memorytype << 3) | (u64)0x0 ;	//not-present
		//}else{
			if(memorytype == 0)
				p_table_value = (u64) (gpa)  | ((u64)memorytype << 3) |  (u64)0x7 ;	//present, UC
			else
				p_table_value = (u64) (gpa)  | ((u64)6 << 3) | (u64)0x7 ;	//present, WB, track host MTRR
		//}

        __xmhfhic_guestpgtbl_setentry(slabid, gpa, p_table_value);

	}
}


static u64 __xmhfhic_arch_smt_slab_populate_guest_pagetables(u64 slabid){

    __xmhfhic_guestpgtbl_establishshape(slabid);

	__xmhfhic_vmx_setupEPT(slabid);

    //return _xmhfhic_common_slab_info_table[slabid].archdata.mempgtbl_pml4t;
    return _xmhfhic_common_slab_archdata_mempgtbl_pml4t[slabid];
}


void xmhfhic_arch_setup_slab_mem_page_tables(void){

	_XDPRINTF_("%s: starting...\n", __FUNCTION__);

    //gather memory types for EPT (for guest slabs)
    __xmhfhic_vmx_gathermemorytypes();

	//setup slab memory page tables
	{
		u32 i;
		for(i=0; i < XMHF_HIC_MAX_SLABS; i++){
				_XDPRINTF_("slab %u: pml4t=%016llx, pdpt=%016llx, pdt[0]=%016llx, pdt[1]=%016llx, pdt[2]=%016llx, pdt[3]=%016llx\n", i,
                    _xmhfhic_common_slab_archdata_mempgtbl_pml4t[i],
                    _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_pdpt,
                    _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_pdt[0],
                    _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_pdt[1],
                    _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_pdt[2],
                    _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_pdt[3]
               );

                switch(_xmhfhic_common_slab_info_table[i].archdata.slabtype){
                    case HIC_SLAB_X86VMXX86PC_HYPERVISOR:{
                        _XDPRINTF_("  HYPERVISOR slab: populating page tables\n");

                        #if 1
                        _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_cr3 = __xmhfhic_arch_smt_slab_populate_hyp_pagetables(i) | (u32)(i+1) | 0x8000000000000000ULL;
                        #else
                        _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_cr3 = __xmhfhic_arch_smt_slab_populate_hyp_pagetables(i);
                        #endif
                    }
                    break;

                    case HIC_SLAB_X86VMXX86PC_GUEST:{
                        _XDPRINTF_("  GUEST slab: populating page tables\n");

                        _xmhfhic_common_slab_info_table[i].archdata.mempgtbl_cr3 = __xmhfhic_arch_smt_slab_populate_guest_pagetables(i) | 0x1E;
                    }
                    break;

                    default: //unallocated slab or an unknown slabtype
                        break;
                }

		}

	}

	_XDPRINTF_("%s: setup slab memory page tables\n", __FUNCTION__);

}































//////////////////////////////////////////////////////////////////////////////
// switch to smp

static bool __xmhfhic_ap_entry(void) __attribute__((naked));
static void __xmhfhic_smp_cpu_x86_smpinitialize_commonstart(void);
static u64 _xcsmp_ap_entry_lock = 1;
static mtrr_state_t _mtrrs;
static u64 _ap_cr3=0;

__attribute__(( aligned(16) )) static u64 _xcsmp_ap_init_gdt_start[]  = {
	0x0000000000000000ULL,	//NULL descriptor
	0x00af9b000000ffffULL,	//CPL-0 64-bit code descriptor (CS64)
	0x00af93000000ffffULL,	//CPL-0 64-bit data descriptor (DS/SS/ES/FS/GS)
};

__attribute__(( aligned(16) )) static arch_x86_gdtdesc_t _xcsmp_ap_init_gdt  = {
	.size=sizeof(_xcsmp_ap_init_gdt_start)-1,
	.base=&_xcsmp_ap_init_gdt_start,
};

__attribute__((naked)) static void _ap_bootstrap_code(void) {

    asm volatile (
           " .code32 \r\n"
           " movw %0, %%ax \r\n"
           " movw %%ax, %%ds \r\n"

           " movl %1, %%ebx \r\n"
           " movl (%%ebx), %%ebx \r\n"

           " jmpl *%%ebx \r\n"
           " hlt \r\n"
           " .balign 4096 \r\n"
           ".code64"
            :
            : "i" (__DS_CPL0),
              "i" ((X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_entrypoint))
            :

        );
}


static void __xmhfhic_smp_cpu_x86_savecpumtrrstate(void){
	xmhfhw_cpu_x86_save_mtrrs(&_mtrrs);
}

static void __xmhfhic_smp_cpu_x86_restorecpumtrrstate(void){
	xmhfhw_cpu_x86_restore_mtrrs(&_mtrrs);
}


//wake up APs using the LAPIC by sending the INIT-SIPI-SIPI IPI sequence
static void __xmhfhic_smp_cpu_x86_wakeupAPs(void){
	u32 eax, edx;
	volatile u32 *icr;

	//read LAPIC base address from MSR
	rdmsr(MSR_APIC_BASE, &eax, &edx);
	HALT_ON_ERRORCOND( edx == 0 ); //APIC is below 4G

	//construct the command register address (offset 0x300)
	icr = (u32 *) (((u32)eax & 0xFFFFF000UL) + 0x300);

	//our AP boot-strap code is at physical memory location 0x10000.
	//so use 0x10 as the vector (0x10000/0x1000 = 0x10)

	//send INIT
	*icr = 0x000c4500UL;

	xmhf_baseplatform_arch_x86_udelay(10000);

	//wait for command completion
	{
		u32 val;
		do{
		  val = *icr;
		}while( (val & 0x1000) );
	}

	//send SIPI (twice as per the MP protocol)
	{
		int i;
		for(i=0; i < 2; i++){
			*icr = 0x000c4610UL;
			xmhf_baseplatform_arch_x86_udelay(200);
			//wait for command completion
			{
			  u32 val;
			  do{
				val = *icr;
			  }while( (val & 0x1000) );
			}
		}
	}

}



//wake up application processors (cores) in the system
static void __xmhfhic_smp_container_vmx_wakeupAPs(void){
    static x86smp_apbootstrapdata_t apdata;

    apdata.ap_cr3 = read_cr3();
    apdata.ap_cr4 = read_cr4();
    apdata.ap_entrypoint = (u32)&__xmhfhic_ap_entry;
    apdata.ap_gdtdesc_limit = sizeof(apdata.ap_gdt) - 1;
    apdata.ap_gdtdesc_base = (X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_gdt);
    apdata.ap_cs_selector = __CS_CPL0;
    apdata.ap_eip = (X86SMP_APBOOTSTRAP_CODESEG << 4);
    apdata.ap_gdt[0] = 0x0000000000000000ULL;
    apdata.ap_gdt[1] = 0x00cf9a000000ffffULL;
    apdata.ap_gdt[2] = 0x00cf92000000ffffULL;

    _XDPRINTF_("%s: sizeof(apdata)=%u bytes\n", __FUNCTION__, sizeof(apdata));
    _XDPRINTF_("  apdata.ap_gdtdesc_limit at %08x\n", &apdata.ap_gdtdesc_limit);
    _XDPRINTF_("  apdata.ap_gdt at %08x\n", &apdata.ap_gdt);

    memcpy((void *)(X86SMP_APBOOTSTRAP_DATASEG << 4), (void *)&apdata, sizeof(apdata));

    memcpy((void *)(X86SMP_APBOOTSTRAP_CODESEG << 4), (void *)&_ap_bootstrap_code, PAGE_SIZE_4K);

#if defined (__DRT__)
    {
        txt_heap_t *txt_heap;
        os_mle_data_t *os_mle_data;
        mle_join_t *mle_join;
        sinit_mle_data_t *sinit_mle_data;
        os_sinit_data_t *os_sinit_data;

        txt_heap = get_txt_heap();
        os_mle_data = get_os_mle_data_start(txt_heap);
        sinit_mle_data = get_sinit_mle_data_start(txt_heap);
        os_sinit_data = get_os_sinit_data_start(txt_heap);

        // enable SMIs on BSP before waking APs (which will enable them on APs)
        // because some SMM may take immediate SMI and hang if AP gets in first
        //_XDPRINTF_("Enabling SMIs on BSP\n");
        //__getsec_smctrl();

        mle_join = (mle_join_t *)((u32)(X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_gdtdesc_limit));

        _XDPRINTF_("\nBSP: mle_join.gdt_limit = %x", mle_join->gdt_limit);
        _XDPRINTF_("\nBSP: mle_join.gdt_base = %x", mle_join->gdt_base);
        _XDPRINTF_("\nBSP: mle_join.seg_sel = %x", mle_join->seg_sel);
        _XDPRINTF_("\nBSP: mle_join.entry_point = %x", mle_join->entry_point);

        write_priv_config_reg(TXTCR_MLE_JOIN, (uint64_t)(unsigned long)mle_join);

        if (os_sinit_data->capabilities.rlp_wake_monitor) {
            _XDPRINTF_("\nBSP: joining RLPs to MLE with MONITOR wakeup");
            _XDPRINTF_("\nBSP: rlp_wakeup_addr = 0x%x", sinit_mle_data->rlp_wakeup_addr);
            *((uint32_t *)(unsigned long)(sinit_mle_data->rlp_wakeup_addr)) = 0x01;
        }else {
            _XDPRINTF_("\nBSP: joining RLPs to MLE with GETSEC[WAKEUP]");
            __getsec_wakeup();
            _XDPRINTF_("\nBSP: GETSEC[WAKEUP] completed");
        }
    }

#else //!__DRT__

    _XDPRINTF_("\nBSP: Using APIC to awaken APs...");
    __xmhfhic_smp_cpu_x86_wakeupAPs();
    _XDPRINTF_("\nBSP: APs should be awake.");

#endif


}

//initialize SMP
static bool __xmhfhic_smp_arch_smpinitialize(void){
	u32 i;

    //save cpu MTRR state which we will later replicate on all APs
	#if !defined(__XMHF_VERIFICATION__)
	__xmhfhic_smp_cpu_x86_savecpumtrrstate();
    #endif

    //save page table base which we will later replicate on all APs
    _ap_cr3 = read_cr3();

	//wake up APS
	if(xcbootinfo->cpuinfo_numentries > 1){
	  __xmhfhic_smp_container_vmx_wakeupAPs();
	}

	//fall through to common code
	_XDPRINTF_("%s: Relinquishing BSP thread and moving to common...\n", __FUNCTION__);
	__xmhfhic_smp_cpu_x86_smpinitialize_commonstart();

	_XDPRINTF_("%s:%u: Must never get here. Halting\n", __FUNCTION__, __LINE__);
	HALT();

}

//return 1 if the calling CPU is the BSP
static bool __xmhfhic_smp_cpu_x86_isbsp(void){
  u32 eax, edx;
  //read LAPIC base address from MSR
  rdmsr(MSR_APIC_BASE, &eax, &edx);
  HALT_ON_ERRORCOND( edx == 0 ); //APIC is below 4G

  if(eax & 0x100)
    return true;
  else
    return false;
}


//common function which is entered by all CPUs upon SMP initialization
//note: this is specific to the x86 architecture backend
void __xmhfhic_smp_cpu_x86_smpinitialize_commonstart(void){
	u64 cpuid;
	#if !defined(__XMHF_VERIFICATION__)
	cpuid  = __xmhfhic_x86vmx_cpuidtable[xmhf_baseplatform_arch_x86_getcpulapicid()];
    #endif

    xmhfhic_smp_entry(cpuid);
}



static bool __xmhfhic_ap_entry(void) __attribute__((naked)){

    asm volatile(
                    ".code32 \r\n"
					"_xcsmp_ap_start: \r\n"

					"movw %%ds, %%ax \r\n"
					"movw %%ax, %%es \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"

    				"movl %%cr4, %%eax \r\n"
   					"orl $0x00000030, %%eax \r\n"
   					"movl %%eax, %%cr4 \r\n"

                    "movl %0, %%ebx \r\n"
                    "movl (%%ebx), %%ebx \r\n"
                    "movl %%ebx, %%cr3 \r\n"

                    "movl $0xc0000080, %%ecx \r\n"
                    "rdmsr \r\n"
                    "orl $0x00000100, %%eax \r\n"
                    "orl $0x00000800, %%eax \r\n"
                    "wrmsr \r\n"

                    "movl %%cr0, %%eax \r\n"
                    "orl $0x80000015, %%eax \r\n"
                    "movl %%eax, %%cr0 \r\n"

                    "movl %1, %%esi \r\n"
                    "lgdt (%%esi) \r\n"

                    "ljmp $8, $_xcsmp_ap_start64 \r\n"

                    ".code64 \r\n"
                    "_xcsmp_ap_start64: \r\n"

					"movw $0x10, %%ax \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"
					"movw %%ax, %%ds \r\n"
					"movw %%ax, %%es \r\n"

                    "movl %2, %%ecx \r\n"
                    "rdmsr \r\n"
                    "andl $0x00000FFF, %%eax \r\n"
                    "orl %3, %%eax \r\n"
                    "wrmsr \r\n"

					:
					:   "i" (&_ap_cr3), "i" (&_xcsmp_ap_init_gdt), "i" (MSR_APIC_BASE), "i" (X86SMP_LAPIC_MEMORYADDRESS)
	);



    asm volatile(
                 	"xorq %%rax, %%rax \r\n"                //RAX=0
                 	"movl %0, %%eax\r\n"                    //
					"movl (%%eax), %%eax\r\n"               //RAX(bits 0-7)=LAPIC ID
					"shr $24, %%eax\r\n"                    //RAX=LAPIC ID
                    "movq %1, %%rbx \r\n"                   //RBX=&__xmhfhic_x86vmx_cpuidtable
                    "movq (%%rbx, %%rax, 8), %%rax \r\n"    //EAX= 0-based cpu index for the CPU

					"movl %2, %%ecx \r\n"					// ecx = sizeof(_cpustack[0])
					"mull %%ecx \r\n"						// eax = sizeof(_cpustack[0]) * eax
					"addl %%ecx, %%eax \r\n"				// eax = (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"addl %3, %%eax \r\n"				    // eax = &_cpustack + (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"movl %%eax, %%esp \r\n"				// esp = top of stack for the cpu

                    "jmp __xmhfhic_smp_cpu_x86_smpinitialize_commonstart \r\n"

					:
					:   "i" (X86SMP_LAPIC_ID_MEMORYADDRESS),
                        "i" (&__xmhfhic_x86vmx_cpuidtable),
                        "i" (sizeof(_init_cpustacks[0])),
                        "i" (&_init_cpustacks)

                    :
	);


}


void xmhfhic_arch_switch_to_smp(void){
	//initialize cpu table and total platform CPUs
	{
	    u32 i, j;
	    for(i=0; i < MAX_X86_APIC_ID; i++)
            __xmhfhic_x86vmx_cpuidtable[i] = 0xFFFFFFFFFFFFFFFFULL;

	    for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            u64 value = i;

            if(xcbootinfo->cpuinfo_buffer[i].isbsp)
                value |= 0x8000000000000000ULL;

            //XXX: TODO sanity check xcbootinfo->cpuinfo_buffer[i].lapic_id < MAX_X86_APIC_ID
            __xmhfhic_x86vmx_cpuidtable[xcbootinfo->cpuinfo_buffer[i].lapic_id] = value;
        }
	}

    __xmhfhic_smp_arch_smpinitialize();

}























/////////////////////////////////////////////////////////////////////
// setup base CPU data structures

//initialize GDT
static void __xmhfhic_x86vmx_initializeGDT(void){
		u32 i;

		for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            TSSENTRY *t;
            u32 tss_base=(u32)&__xmhfhic_x86vmx_tss[i];

            //TSS descriptor
            t= (TSSENTRY *)&__xmhfhic_x86vmx_gdt_start[(__TRSEL/8)+(i*2)];
            t->attributes1= 0xE9;
            t->limit16_19attributes2= 0x0;
            t->baseAddr0_15= (u16)(tss_base & 0x0000FFFF);
            t->baseAddr16_23= (u8)((tss_base & 0x00FF0000) >> 16);
            t->baseAddr24_31= (u8)((tss_base & 0xFF000000) >> 24);
            t->limit0_15=0x67;
		}

}

//initialize IDT
static void __xmhfhic_x86vmx_initializeIDT(void){
	u32 i;

	for(i=0; i < EMHF_XCPHANDLER_MAXEXCEPTIONS; i++){
		__xmhfhic_x86vmx_idt_start[i].isrLow= (u16)__xmhfhic_exceptionstubs[i];
		__xmhfhic_x86vmx_idt_start[i].isrHigh= (u16) ( (u32)__xmhfhic_exceptionstubs[i] >> 16 );
		__xmhfhic_x86vmx_idt_start[i].isrSelector = __CS_CPL0;
		__xmhfhic_x86vmx_idt_start[i].count=0x0;
		__xmhfhic_x86vmx_idt_start[i].type=0xEE;	//32-bit interrupt gate
                                //present=1, DPL=11b, system=0, type=1110b
        __xmhfhic_x86vmx_idt_start[i].offset3263=0;
        __xmhfhic_x86vmx_idt_start[i].reserved=0;
	}

}


//initialize TSS
static void __xmhfhic_x86vmx_initializeTSS(void){
		u32 i;

		//initialize TSS descriptors for all CPUs
		for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            tss_t *tss= (tss_t *)__xmhfhic_x86vmx_tss[i];
            tss->rsp0 = (u64) ( &__xmhfhic_x86vmx_tss_stack[i] + sizeof(__xmhfhic_x86vmx_tss_stack[0]) );
		}
}


void xmhfhic_arch_setup_base_cpu_data_structures(void){

    //initialize GDT
    #if !defined(__XMHF_VERIFICATION__)
    __xmhfhic_x86vmx_initializeGDT();
    #endif

    //initialize IDT
    __xmhfhic_x86vmx_initializeIDT();

    //initialize TSS
    __xmhfhic_x86vmx_initializeTSS();

}
















//////////////////////////////////////////////////////////////////////////////
// setup cpu state for hic





//load GDT and initialize segment registers
static void __xmhfhic_x86vmx_loadGDT(u64 cpuid){

	asm volatile(
		"lgdt  %0 \r\n"
		"pushq	%1 \r\n"				// far jump to runtime entry point
		"pushq	$reloadsegs \r\n"
		"lretq \r\n"
		"reloadsegs: \r\n"
		"movw	%2, %%ax \r\n"
		"movw	%%ax, %%ds \r\n"
		"movw	%%ax, %%es \r\n"
		"movw	%%ax, %%fs \r\n"
		"movw	%%ax, %%gs \r\n"
		"movw   %%ax, %%ss \r\n"
		: //no outputs
		: "m" (__xmhfhic_x86vmx_gdt), "i" (__CS_CPL0), "i" (__DS_CPL0)
		: "eax"
	);
}


//load IDT
static void __xmhfhic_x86vmx_loadIDT(u64 cpuid){
	//load IDT
	asm volatile(
		"lidt  %0 \r\n"
		: //no outputs
		: "m" (__xmhfhic_x86vmx_idt)
		: //no clobber
	);
}

//load TR
static void __xmhfhic_x86vmx_loadTR(u64 cpuid){
	  asm volatile(
		"movq %0, %%rax\r\n"
		"ltr %%ax\r\n"				//load TR
	     :
	     : "g"(__TRSEL + ((u32)cpuid * 16) )
	     : "rax"
	  );
}


//set IOPl to CPl-3
static void __xmhfhic_x86vmx_setIOPL3(u64 cpuid){

	asm volatile(
        "pushfq \r\n"
        "popq %%rax \r\n"
		"orq $0x3000, %%rax \r\n"					// clear flags, but set IOPL=3 (CPL-3)
		"pushq %%rax \r\n"
		"popfq \r\n"
		: //no outputs
		: //no inputs
		: "rax", "cc"
	);


}


static bool __xmhfhic_x86vmx_setupvmxstate(u64 cpuid){
    u32 cpuindex = (u32)cpuid;
	const u32 vmx_msr_area_msrs[] = {MSR_EFER, MSR_IA32_PAT}; //critical MSRs that need to be saved/restored across guest VM switches
	const unsigned int vmx_msr_area_msrs_count = (sizeof(vmx_msr_area_msrs)/sizeof(vmx_msr_area_msrs[0]));	//count of critical MSRs that need to be saved/restored across VM switches
	u32 lodword, hidword;
	u64 vmcs_phys_addr = hva2spa(__xmhfhic_x86vmx_archdata[cpuindex].vmx_vmcs_region);


	//save contents of VMX MSRs as well as MSR EFER and EFCR
	{
		u32 i;
		u32 eax, edx;
		for(i=0; i < IA32_VMX_MSRCOUNT; i++){
			rdmsr( (IA32_VMX_BASIC_MSR + i), &eax, &edx);
			__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[i] = (u64)edx << 32 | (u64) eax;
		}

		rdmsr(MSR_EFER, &eax, &edx);
		__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_efer = (u64)edx << 32 | (u64) eax;
		rdmsr(MSR_EFCR, &eax, &edx);
		__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_efcr = (u64)edx << 32 | (u64) eax;
  	}

    write_cr4( read_cr4() |  CR4_VMXE);

#if 0
	//enter VMX root operation using VMXON
	{
		u32 retval=0;
		u64 vmxonregion_paddr = hva2spa((void*)__xmhfhic_x86vmx_archdata[cpuindex].vmx_vmxon_region);
		//set VMCS rev id
		*((u32 *)__xmhfhic_x86vmx_archdata[cpuindex].vmx_vmxon_region) = (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_BASIC_MSR];

		asm volatile( "vmxon %1 \n"
				 "jbe vmfail \n"
				 "movl $0x1, %%eax \n"
				 "movl %%eax, %0 \n"
				 "jmp vmsuccess \n"
				 "vmfail: \n"
				 "movl $0x0, %%eax \n"
				 "movl %%eax, %0 \n"
				 "vmsuccess: \n"
		   : "=m" (retval)
		   : "m"(vmxonregion_paddr)
		   : "eax");

		if(!retval){
			_XDPRINTF_("%s(%u): unable to enter VMX root operation\n", __FUNCTION__, (u32)cpuid);
			return false;
		}
	}

	//clear VMCS
	if(!__vmx_vmclear((u64)vmcs_phys_addr))
		return false;

	//set VMCS revision id
	*((u32 *)__xmhfhic_x86vmx_archdata[cpuindex].vmx_vmcs_region) = (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_BASIC_MSR];

	//load VMPTR
	if(!__vmx_vmptrld((u64)vmcs_phys_addr))
		return false;
#endif // 0


	//setup host state
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_CR0, read_cr0());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_CR4, read_cr4());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_CR3, read_cr3());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_CS_SELECTOR, read_segreg_cs());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_DS_SELECTOR, read_segreg_ds());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_ES_SELECTOR, read_segreg_es());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_FS_SELECTOR, read_segreg_fs());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_GS_SELECTOR, read_segreg_gs());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_SS_SELECTOR, read_segreg_ss());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_TR_SELECTOR, read_tr_sel());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_GDTR_BASE, xmhf_baseplatform_arch_x86_getgdtbase());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_IDTR_BASE, xmhf_baseplatform_arch_x86_getidtbase());
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_TR_BASE, xmhf_baseplatform_arch_x86_gettssbase());

	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_RIP, __xmhfhic_rtm_intercept_stub);

	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_RSP, read_rsp());
	rdmsr(IA32_SYSENTER_CS_MSR, &lodword, &hidword);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_SYSENTER_CS, lodword);
	rdmsr(IA32_SYSENTER_ESP_MSR, &lodword, &hidword);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_SYSENTER_ESP, (((u64)hidword << 32) | (u64)lodword));
	rdmsr(IA32_SYSENTER_EIP_MSR, &lodword, &hidword);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_SYSENTER_EIP, (((u64)hidword << 32) | (u64)lodword));
	rdmsr(IA32_MSR_FS_BASE, &lodword, &hidword);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_FS_BASE, (((u64)hidword << 32) | (u64)lodword) );
	rdmsr(IA32_MSR_GS_BASE, &lodword, &hidword);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_GS_BASE, (((u64)hidword << 32) | (u64)lodword) );

	//xmhfhw_cpu_x86vmx_vmwrite(VMCS_HOST_IA32_EFER_FULL, rdmsr64(MSR_EFER));

	//setup default VMX controls
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_PIN_BASED, (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_PINBASED_CTLS_MSR]);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_CPU_BASED, (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_PROCBASED_CTLS_MSR]);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_CONTROLS, (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_EXIT_CTLS_MSR]);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_CONTROLS, (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_ENTRY_CTLS_MSR]);

    //64-bit host
  	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_CONTROLS, (u32)(xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_EXIT_CONTROLS) | (1 << 9)) );

	//IO bitmap support
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_IO_BITMAPA_ADDRESS_FULL, hva2spa(__xmhfhic_x86vmx_archdata[cpuindex].vmx_iobitmap_region[0] ));
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_IO_BITMAPB_ADDRESS_FULL, hva2spa(__xmhfhic_x86vmx_archdata[cpuindex].vmx_iobitmap_region[1] ));
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_CPU_BASED, (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_CPU_BASED) | (u64)(1 << 25)) );

	//MSR bitmap support
	//xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_MSR_BITMAPS_ADDRESS_FULL, hva2spa(__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrbitmaps_region ));
	//xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_CPU_BASED, (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_CPU_BASED) | (u64)(1 << 28)) );


	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_PAGEFAULT_ERRORCODE_MASK, 0x00000000);
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_PAGEFAULT_ERRORCODE_MATCH, 0x00000000);
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_EXCEPTION_BITMAP, 0);
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_CR3_TARGET_COUNT, 0);

	//activate secondary processor controls
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_SECCPU_BASED, (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_PROCBASED_CTLS2_MSR]);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_CPU_BASED, (u32) (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_CPU_BASED) | (u64)(1 << 31)) );

	//setup unrestricted guest
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_SECCPU_BASED, (u32)(xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_SECCPU_BASED) | (u64)(1 << 7)) );

	//setup VMCS link pointer
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_VMCS_LINK_POINTER_FULL, 0xFFFFFFFFFFFFFFFFULL);

	//setup NMI intercept for core-quiescing
	//XXX: needs to go in xcinit/richguest slab
	//xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_PIN_BASED, (u32)(xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_PIN_BASED) | (u64)(1 << 3) ) );

	//trap access to CR0 fixed 1-bits
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_CR0_MASK, (u32)(((((u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_CR0_FIXED0_MSR] & ~(CR0_PE)) & ~(CR0_PG)) | CR0_CD) | CR0_NW) );

	//trap access to CR4 fixed bits (this includes the VMXE bit)
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_CR4_MASK, (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_CR4_FIXED0_MSR]);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_CR4_SHADOW, (u64)CR4_VMXE);

	//setup memory protection
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_SECCPU_BASED, (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_SECCPU_BASED) | (u64)(1 <<1) | (u64)(1 << 5)) );
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VPID, 0); //[need to populate in trampoline]
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_EPT_POINTER_FULL, 0); // [need to populate in trampoline]
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VMX_CPU_BASED, (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_CPU_BASED) & (u64)~(1 << 15) & (u64)~(1 << 16)) );

	xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CR0, (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_CR0_FIXED0_MSR]);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_CR0_SHADOW, xmhfhw_cpu_x86vmx_vmread(VMCS_GUEST_CR0));

	xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CR4, (u32)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msrs[INDEX_IA32_VMX_CR4_FIXED0_MSR]);

	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_EXCEPTION_ERRORCODE, 0);
	xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_INTERRUPTION_INFORMATION, 0);


    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_RSP, 0); //[need to populate in trampoline]

    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_RIP, 0); // [need to populate in trampoline]
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ACTIVITY_STATE, 0);
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_RFLAGS, (1 <<1) | (EFLAGS_IOPL));
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_INTERRUPTIBILITY, 0);


    //IDTR
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_IDTR_BASE, 0);
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_IDTR_LIMIT, 0);



    //LDTR, unusable
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_LDTR_BASE, 0);
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_LDTR_LIMIT, 0);
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_LDTR_SELECTOR, 0);
    xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_LDTR_ACCESS_RIGHTS, 0x10000);




    //64-bit specific guest slab setup
    {

        //Critical MSR load/store
        {
            u32 i;
            msr_entry_t *hmsr = (msr_entry_t *)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_host_region;
            msr_entry_t *gmsr = (msr_entry_t *)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_guest_region;

            //store host and guest initial values of the critical MSRs
            for(i=0; i < vmx_msr_area_msrs_count; i++){
                u32 msr, eax, edx;
                msr = vmx_msr_area_msrs[i];
                rdmsr(msr, &eax, &edx);

                //host MSR values will be what we get from RDMSR
                hmsr[i].index = msr;
                hmsr[i].data = ((u64)edx << 32) | (u64)eax;

                //adjust and populate guest MSR values according to the MSR
                gmsr[i].index = msr;
                gmsr[i].data = ((u64)edx << 32) | (u64)eax;
                switch(msr){
                    case MSR_EFER:{
                        //gmsr[i].data = gmsr[i].data & (u64)~(1ULL << EFER_LME);
                        //gmsr[i].data = gmsr[i].data & (u64)~(1ULL << EFER_LMA);
                        //gmsr[i].data = gmsr[i].data & (u64)~(1ULL << EFER_SCE);
                        //gmsr[i].data = gmsr[i].data & (u64)~(1ULL << EFER_NXE);
                        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_IA32_EFER_FULL, gmsr[i].data);

                    }
                    break;

                    default:
                        break;
                }

            }

            //host MSR load on exit, we store it ourselves before entry
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_MSR_LOAD_ADDRESS_FULL, hva2spa((void*)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_host_region));
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_MSR_LOAD_COUNT, vmx_msr_area_msrs_count);

            //guest MSR load on entry, store on exit
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_MSR_LOAD_ADDRESS_FULL, hva2spa((void*)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_guest_region));
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_MSR_LOAD_COUNT, vmx_msr_area_msrs_count);
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_MSR_STORE_ADDRESS_FULL, hva2spa((void*)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_guest_region));
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_MSR_STORE_COUNT, vmx_msr_area_msrs_count);

        }


        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CR4, (xmhfhw_cpu_x86vmx_vmread(VMCS_GUEST_CR4) | CR4_PAE | CR4_PSE) );

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_CONTROLS, (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_ENTRY_CONTROLS) | (1 << 9)) );
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_CONTROLS, (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_ENTRY_CONTROLS) | (1 << 15)) );

        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_PDPTE0_FULL, _guestslab1_init_pdpt[0] );
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_PDPTE1_FULL, _guestslab1_init_pdpt[1] );
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_PDPTE2_FULL, _guestslab1_init_pdpt[2] );
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_PDPTE3_FULL, _guestslab1_init_pdpt[3] );


        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CR3, &_guestslab1_init_pml4t );


        //TR, should be usable for VMX to work, but not used by guest
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_TR_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_TR_LIMIT, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_TR_SELECTOR, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_TR_ACCESS_RIGHTS, 0x8B);

        //CS, DS, ES, FS, GS and SS segments
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CS_SELECTOR, 0x8);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CS_ACCESS_RIGHTS, 0xa09b);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_DS_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_DS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_DS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_DS_ACCESS_RIGHTS, 0xa093);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ES_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ES_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ES_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ES_ACCESS_RIGHTS, 0xa093);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_FS_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_FS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_FS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_FS_ACCESS_RIGHTS, 0xa093);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GS_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GS_ACCESS_RIGHTS, 0xa093);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_SS_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_SS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_SS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_SS_ACCESS_RIGHTS, 0xa093);


        //GDTR
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GDTR_BASE, &_guestslab1_init_gdt_start);
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GDTR_LIMIT, (sizeof(_guestslab1_init_gdt_start)-1) );


    }

/*    //32-bit specific guest slab setup
    {

        //Critical MSR load/store
        {
            u32 i;
            msr_entry_t *hmsr = (msr_entry_t *)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_host_region;
            msr_entry_t *gmsr = (msr_entry_t *)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_guest_region;

            //store host and guest initial values of the critical MSRs
            for(i=0; i < vmx_msr_area_msrs_count; i++){
                u32 msr, eax, edx;
                msr = vmx_msr_area_msrs[i];
                rdmsr(msr, &eax, &edx);

                //host MSR values will be what we get from RDMSR
                hmsr[i].index = msr;
                hmsr[i].data = ((u64)edx << 32) | (u64)eax;

                //adjust and populate guest MSR values according to the MSR
                gmsr[i].index = msr;
                gmsr[i].data = ((u64)edx << 32) | (u64)eax;
                switch(msr){
                    case MSR_EFER:{
                        gmsr[i].data = gmsr[i].data & (u64)~(1ULL << EFER_LME);
                        gmsr[i].data = gmsr[i].data & (u64)~(1ULL << EFER_LMA);
                        gmsr[i].data = gmsr[i].data & (u64)~(1ULL << EFER_SCE);
                        gmsr[i].data = gmsr[i].data & (u64)~(1ULL << EFER_NXE);
                    }
                    break;

                    default:
                        break;
                }

            }

            //host MSR load on exit, we store it ourselves before entry
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_MSR_LOAD_ADDRESS_FULL, hva2spa((void*)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_host_region));
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_MSR_LOAD_COUNT, vmx_msr_area_msrs_count);

            //guest MSR load on entry, store on exit
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_MSR_LOAD_ADDRESS_FULL, hva2spa((void*)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_guest_region));
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_MSR_LOAD_COUNT, vmx_msr_area_msrs_count);
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_MSR_STORE_ADDRESS_FULL, hva2spa((void*)__xmhfhic_x86vmx_archdata[cpuindex].vmx_msr_area_guest_region));
            xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_EXIT_MSR_STORE_COUNT, vmx_msr_area_msrs_count);

        }


        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CR4, (xmhfhw_cpu_x86vmx_vmread(VMCS_GUEST_CR4) | CR4_PAE | CR4_PSE) );

        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_CONTROLS, (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_ENTRY_CONTROLS) | (1 << 9)) );
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_VM_ENTRY_CONTROLS, (xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_ENTRY_CONTROLS) | (1 << 15)) );

        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_PDPTE0_FULL, _guestslab1_init_pdpt[0] );
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_PDPTE1_FULL, _guestslab1_init_pdpt[1] );
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_PDPTE2_FULL, _guestslab1_init_pdpt[2] );
        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_PDPTE3_FULL, _guestslab1_init_pdpt[3] );


        //xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CR3, &_guestslab1_init_pml4t );
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CR3, 0 );


        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CR0, (xmhfhw_cpu_x86vmx_vmread(VMCS_GUEST_CR0) & ~(CR0_PG) ) );
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_CONTROL_CR0_SHADOW, xmhfhw_cpu_x86vmx_vmread(VMCS_GUEST_CR0));

        //TR, should be usable for VMX to work, but not used by guest
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_TR_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_TR_LIMIT, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_TR_SELECTOR, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_TR_ACCESS_RIGHTS, 0x8B);

        //CS, DS, ES, FS, GS and SS segments
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CS_SELECTOR, 0x8);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_CS_ACCESS_RIGHTS, 0xc09b);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_DS_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_DS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_DS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_DS_ACCESS_RIGHTS, 0xc093);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ES_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ES_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ES_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_ES_ACCESS_RIGHTS, 0xc093);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_FS_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_FS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_FS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_FS_ACCESS_RIGHTS, 0xc093);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GS_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_GS_ACCESS_RIGHTS, 0xc093);

        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_SS_SELECTOR, 0x10);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_SS_BASE, 0);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_SS_LIMIT, 0xFFFFFFFFUL);
        xmhfhw_cpu_x86vmx_vmwrite(VMCS_GUEST_SS_ACCESS_RIGHTS, 0xc093);



    }
*/


















	/*_XDPRINTF_("%s: vmcs pinbased=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_PIN_BASED));
	_XDPRINTF_("%s: pinbase MSR=%016llx\n", __FUNCTION__, _cpustate_archdatavmx[context_desc.cpu_desc.cpu_index].vmx_msrs[INDEX_IA32_VMX_PINBASED_CTLS_MSR]);
	_XDPRINTF_("%s: cpu_based vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_CPU_BASED));
	_XDPRINTF_("%s: cpu_based MSR=%016llx\n", __FUNCTION__, _cpustate_archdatavmx[context_desc.cpu_desc.cpu_index].vmx_msrs[INDEX_IA32_VMX_PROCBASED_CTLS_MSR]);
	_XDPRINTF_("%s: seccpu_based vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VMX_SECCPU_BASED));
	_XDPRINTF_("%s: seccpu_based MSR=%016llx\n", __FUNCTION__, _cpustate_archdatavmx[context_desc.cpu_desc.cpu_index].vmx_msrs[INDEX_IA32_VMX_PROCBASED_CTLS2_MSR]);
	_XDPRINTF_("%s: entrycontrols vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_ENTRY_CONTROLS));
	_XDPRINTF_("%s: entrycontrols MSR=%016llx\n", __FUNCTION__, _cpustate_archdatavmx[context_desc.cpu_desc.cpu_index].vmx_msrs[INDEX_IA32_VMX_ENTRY_CTLS_MSR]);
	_XDPRINTF_("%s: exitcontrols vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_EXIT_CONTROLS));
	_XDPRINTF_("%s: exitcontrols MSR=%016llx\n", __FUNCTION__, _cpustate_archdatavmx[context_desc.cpu_desc.cpu_index].vmx_msrs[INDEX_IA32_VMX_EXIT_CTLS_MSR]);
	_XDPRINTF_("%s: iobitmapa vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_IO_BITMAPA_ADDRESS_FULL));
	_XDPRINTF_("%s: iobitmapb vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_IO_BITMAPB_ADDRESS_FULL));
	_XDPRINTF_("%s: msrbitmap load vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_ENTRY_MSR_LOAD_ADDRESS_FULL));
	_XDPRINTF_("%s: msrbitmap store vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_EXIT_MSR_STORE_ADDRESS_FULL));
	_XDPRINTF_("%s: msrbitmap exit load vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_VM_EXIT_MSR_LOAD_ADDRESS_FULL));
	_XDPRINTF_("%s: ept pointer vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_EPT_POINTER_FULL));
    */
	_XDPRINTF_("%s: CR0 vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_GUEST_CR0));
	_XDPRINTF_("%s: CR4 vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_GUEST_CR4));
	_XDPRINTF_("%s: CR0 mask vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_CR0_MASK));
	_XDPRINTF_("%s: CR4 mask vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_CR4_MASK));
	_XDPRINTF_("%s: CR0 shadow vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_CR0_SHADOW));
	_XDPRINTF_("%s: CR4 shadow vmcs=%016llx\n", __FUNCTION__, xmhfhw_cpu_x86vmx_vmread(VMCS_CONTROL_CR4_SHADOW));


    return true;
}



void xmhf_hic_arch_setup_cpu_state(u64 cpuid){

	//replicate common MTRR state on this CPU
	#if !defined (__XMHF_VERIFICATION__)
	__xmhfhic_smp_cpu_x86_restorecpumtrrstate();
    #endif

    //load GDT
    __xmhfhic_x86vmx_loadGDT(cpuid);
    _XDPRINTF_("%s[%u]: GDT loaded\n", __FUNCTION__, (u32)cpuid);

    //load TR
    __xmhfhic_x86vmx_loadTR(cpuid);
    _XDPRINTF_("%s[%u]: TR loaded\n", __FUNCTION__, (u32)cpuid);

    //load IDT
    __xmhfhic_x86vmx_loadIDT(cpuid);
    _XDPRINTF_("%s[%u]: IDT loaded\n", __FUNCTION__, (u32)cpuid);

    //turn on CR0.WP bit for supervisor mode write protection
    write_cr0(read_cr0() | CR0_WP);
    _XDPRINTF_("%s[%u]: Enabled supervisor mode write protection\n", __FUNCTION__, (u32)cpuid);

    //set IOPL3
    __xmhfhic_x86vmx_setIOPL3(cpuid);
    _XDPRINTF_("%s[%u]: set IOPL to CPL-3\n", __FUNCTION__, (u32)cpuid);


    //set LAPIC base address to preferred address
    {
        u64 msrapic = rdmsr64(MSR_APIC_BASE);
        wrmsr64(MSR_APIC_BASE, ((msrapic & 0x0000000000000FFFULL) | X86SMP_LAPIC_MEMORYADDRESS));
    }
    _XDPRINTF_("%s[%u]: set LAPIC base address to %016llx\n", __FUNCTION__, (u32)cpuid, rdmsr64(MSR_APIC_BASE));

	//turn on NX protections
	{
		u32 eax, edx;
		rdmsr(MSR_EFER, &eax, &edx);
		eax |= (1 << EFER_NXE);
		wrmsr(MSR_EFER, eax, edx);
	}
    _XDPRINTF_("%s[%u]: NX protections enabled\n", __FUNCTION__, (u32)cpuid);

#if 1
	//enable PCIDE support
	{
		write_cr4(read_cr4() | CR4_PCIDE);
	}
    _XDPRINTF_("%s[%u]: PCIDE enabled\n", __FUNCTION__, (u32)cpuid);
#endif

	//set OSXSAVE bit in CR4 to enable us to pass-thru XSETBV intercepts
	//when the CPU supports XSAVE feature
	if(xmhf_baseplatform_arch_x86_cpuhasxsavefeature()){
        write_cr4(read_cr4() | CR4_OSXSAVE);
        _XDPRINTF_("%s[%u]: XSETBV passthrough enabled\n", __FUNCTION__, (u32)cpuid);
	}


	//set bit 5 (EM) of CR0 to be VMX compatible in case of Intel cores
	write_cr0(read_cr0() | 0x20);
    _XDPRINTF_("%s[%u]: Set CR0.EM to be VMX compatible\n", __FUNCTION__, (u32)cpuid);


    //setup SYSENTER/SYSEXIT mechanism
    {
        wrmsr(IA32_SYSENTER_CS_MSR, __CS_CPL0, 0);
        wrmsr(IA32_SYSENTER_EIP_MSR, (u32)&__xmhfhic_rtm_trampoline_stub, 0);
        wrmsr(IA32_SYSENTER_ESP_MSR, ((u32)__xmhfhic_rtm_trampoline_stack[(u32)cpuid] + MAX_PLATFORM_CPUSTACK_SIZE), 0);
    }
    _XDPRINTF_("%s: setup SYSENTER/SYSEXIT mechanism\n", __FUNCTION__);
    _XDPRINTF_("SYSENTER CS=%016llx\n", rdmsr64(IA32_SYSENTER_CS_MSR));
    _XDPRINTF_("SYSENTER RIP=%016llx\n", rdmsr64(IA32_SYSENTER_EIP_MSR));
    _XDPRINTF_("SYSENTER RSP=%016llx\n", rdmsr64(IA32_SYSENTER_ESP_MSR));

    //setup VMX state
    if(!__xmhfhic_x86vmx_setupvmxstate(cpuid)){
        _XDPRINTF_("%s[%u]: Unable to set VMX state. Halting!\n", __FUNCTION__, (u32)cpuid);
        HALT();
    }
    _XDPRINTF_("%s[%u]: Setup VMX state\n", __FUNCTION__, (u32)cpuid);

}





























/////////////////////////////////////////////////////////////////////////////
// relinquish HIC initialization and move on to the first slab
void xmhfhic_arch_relinquish_control_to_init_slab(u64 cpuid){

    _XDPRINTF_("%s[%u]: proceeding to call init slab at %x\n", __FUNCTION__, (u32)cpuid,
                _xmhfhic_common_slab_info_table[XMHF_HYP_SLAB_XCINIT].entrystub);


    //switch page tables to init slab pagetables
    asm volatile(
         "movq %0, %%rax \r\n"
         "movq %%rax, %%cr3 \r\n"
        :
        : "m" (_xmhfhic_common_slab_info_table[XMHF_HYP_SLAB_XCINIT].archdata.mempgtbl_cr3)
        : "rax"
    );

    _XDPRINTF_("%s[%u]: switched page tables\n", __FUNCTION__, (u32)cpuid);


    /*

    RDI = iparams
    RSI = iparams_size
    RDX = slab entrystub; used for SYSEXIT
    RCX = slab entrystub stack TOS for the CPU; used for SYSEXIT
    R8 = oparams
    R9 = oparams_size
    R10 = src_slabid
    R11 = cpuid

    */

    asm volatile(
         "movq %0, %%rdi \r\n"
         "movq %1, %%rsi \r\n"
         "movq %2, %%rdx \r\n"
         "movq %3, %%rcx \r\n"
         "movq %4, %%r8 \r\n"
         "movq %5, %%r9 \r\n"
         "movq %6, %%r10 \r\n"
         "movq %7, %%r11 \r\n"

         "sysexitq \r\n"
         //"int $0x03 \r\n"
        :
        : "i" (NULL),
          "i" (0),
          "m" (_xmhfhic_common_slab_info_table[XMHF_HYP_SLAB_XCINIT].entrystub),
          "m" (_xmhfhic_common_slab_info_table[XMHF_HYP_SLAB_XCINIT].archdata.slabtos[(u32)cpuid]),
          "i" (NULL),
          "i" (0),
          "i" (0xFFFFFFFFFFFFFFFFULL),
          "m" (cpuid)


        : "rdi", "rsi", "rdx", "rcx", "r8", "r9", "r10", "r11"
    );

    _XDPRINTF_("%s[%u]: Should never come here. Halting!\n", __FUNCTION__, (u32)cpuid);
    HALT();
}





#if 0

    //debug
    _XDPRINTF_("Halting!\n");
    _XDPRINTF_("XMHF Tester Finished!\n");
    HALT();

#endif // 0
