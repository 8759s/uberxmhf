/*
 * @XMHF_LICENSE_HEADER_START@
 *
 * eXtensible, Modular Hypervisor Framework (XMHF)
 * Copyright (c) 2009-2012 Carnegie Mellon University
 * Copyright (c) 2010-2012 VDG Inc.
 * All Rights Reserved.
 *
 * Developed by: XMHF Team
 *               Carnegie Mellon University / CyLab
 *               VDG Inc.
 *               http://xmhf.org
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in
 * the documentation and/or other materials provided with the
 * distribution.
 *
 * Neither the names of Carnegie Mellon or VDG Inc, nor the names of
 * its contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @XMHF_LICENSE_HEADER_END@
 */

/**
 * XMHF core primeon slab (xcprimeon), x86-vmx-x86pc backend
 * author: amit vasudevan (amitvasudevan@acm.org)
 */

#include <xmhf.h>
#include <xmhf-core.h>
#include <xmhf-debug.h>

#include <xcprimeon.h>

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pdt[(PAE_PTRS_PER_PDPT*PAE_PTRS_PER_PDT)] = {
	0x0000000000000081,0x0000000000200081,0x0000000000400081,0x0000000000600081,
	0x0000000000800081,0x0000000000a00081,0x0000000000c00081,0x0000000000e00081,
	0x0000000001000081,0x0000000001200081,0x0000000001400081,0x0000000001600081,
	0x0000000001800081,0x0000000001a00081,0x0000000001c00081,0x0000000001e00081,
	0x0000000002000081,0x0000000002200081,0x0000000002400081,0x0000000002600081,
	0x0000000002800081,0x0000000002a00081,0x0000000002c00081,0x0000000002e00081,
	0x0000000003000081,0x0000000003200081,0x0000000003400081,0x0000000003600081,
	0x0000000003800081,0x0000000003a00081,0x0000000003c00081,0x0000000003e00081,
	0x0000000004000081,0x0000000004200081,0x0000000004400081,0x0000000004600081,
	0x0000000004800081,0x0000000004a00081,0x0000000004c00081,0x0000000004e00081,
	0x0000000005000081,0x0000000005200081,0x0000000005400081,0x0000000005600081,
	0x0000000005800081,0x0000000005a00081,0x0000000005c00081,0x0000000005e00081,
	0x0000000006000081,0x0000000006200081,0x0000000006400081,0x0000000006600081,
	0x0000000006800081,0x0000000006a00081,0x0000000006c00081,0x0000000006e00081,
	0x0000000007000081,0x0000000007200081,0x0000000007400081,0x0000000007600081,
	0x0000000007800081,0x0000000007a00081,0x0000000007c00081,0x0000000007e00081,
	0x0000000008000081,0x0000000008200081,0x0000000008400081,0x0000000008600081,
	0x0000000008800081,0x0000000008a00081,0x0000000008c00081,0x0000000008e00081,
	0x0000000009000081,0x0000000009200081,0x0000000009400081,0x0000000009600081,
	0x0000000009800081,0x0000000009a00081,0x0000000009c00081,0x0000000009e00081,
	0x000000000a000081,0x000000000a200081,0x000000000a400081,0x000000000a600081,
	0x000000000a800081,0x000000000aa00081,0x000000000ac00081,0x000000000ae00081,
	0x000000000b000081,0x000000000b200081,0x000000000b400081,0x000000000b600081,
	0x000000000b800081,0x000000000ba00081,0x000000000bc00081,0x000000000be00081,
	0x000000000c000081,0x000000000c200081,0x000000000c400081,0x000000000c600081,
	0x000000000c800081,0x000000000ca00081,0x000000000cc00081,0x000000000ce00081,
	0x000000000d000081,0x000000000d200081,0x000000000d400081,0x000000000d600081,
	0x000000000d800081,0x000000000da00081,0x000000000dc00081,0x000000000de00081,
	0x000000000e000081,0x000000000e200081,0x000000000e400081,0x000000000e600081,
	0x000000000e800081,0x000000000ea00081,0x000000000ec00081,0x000000000ee00081,
	0x000000000f000081,0x000000000f200081,0x000000000f400081,0x000000000f600081,
	0x000000000f800081,0x000000000fa00081,0x000000000fc00081,0x000000000fe00081,
	0x0000000010000081,0x0000000010200081,0x0000000010400081,0x0000000010600081,
	0x0000000010800081,0x0000000010a00081,0x0000000010c00081,0x0000000010e00081,
	0x0000000011000081,0x0000000011200081,0x0000000011400081,0x0000000011600081,
	0x0000000011800081,0x0000000011a00081,0x0000000011c00081,0x0000000011e00081,
	0x0000000012000081,0x0000000012200081,0x0000000012400081,0x0000000012600081,
	0x0000000012800081,0x0000000012a00081,0x0000000012c00081,0x0000000012e00081,
	0x0000000013000081,0x0000000013200081,0x0000000013400081,0x0000000013600081,
	0x0000000013800081,0x0000000013a00081,0x0000000013c00081,0x0000000013e00081,
	0x0000000014000081,0x0000000014200081,0x0000000014400081,0x0000000014600081,
	0x0000000014800081,0x0000000014a00081,0x0000000014c00081,0x0000000014e00081,
	0x0000000015000081,0x0000000015200081,0x0000000015400081,0x0000000015600081,
	0x0000000015800081,0x0000000015a00081,0x0000000015c00081,0x0000000015e00081,
	0x0000000016000081,0x0000000016200081,0x0000000016400081,0x0000000016600081,
	0x0000000016800081,0x0000000016a00081,0x0000000016c00081,0x0000000016e00081,
	0x0000000017000081,0x0000000017200081,0x0000000017400081,0x0000000017600081,
	0x0000000017800081,0x0000000017a00081,0x0000000017c00081,0x0000000017e00081,
	0x0000000018000081,0x0000000018200081,0x0000000018400081,0x0000000018600081,
	0x0000000018800081,0x0000000018a00081,0x0000000018c00081,0x0000000018e00081,
	0x0000000019000081,0x0000000019200081,0x0000000019400081,0x0000000019600081,
	0x0000000019800081,0x0000000019a00081,0x0000000019c00081,0x0000000019e00081,
	0x000000001a000081,0x000000001a200081,0x000000001a400081,0x000000001a600081,
	0x000000001a800081,0x000000001aa00081,0x000000001ac00081,0x000000001ae00081,
	0x000000001b000081,0x000000001b200081,0x000000001b400081,0x000000001b600081,
	0x000000001b800081,0x000000001ba00081,0x000000001bc00081,0x000000001be00081,
	0x000000001c000081,0x000000001c200081,0x000000001c400081,0x000000001c600081,
	0x000000001c800081,0x000000001ca00081,0x000000001cc00081,0x000000001ce00081,
	0x000000001d000081,0x000000001d200081,0x000000001d400081,0x000000001d600081,
	0x000000001d800081,0x000000001da00081,0x000000001dc00081,0x000000001de00081,
	0x000000001e000081,0x000000001e200081,0x000000001e400081,0x000000001e600081,
	0x000000001e800081,0x000000001ea00081,0x000000001ec00081,0x000000001ee00081,
	0x000000001f000081,0x000000001f200081,0x000000001f400081,0x000000001f600081,
	0x000000001f800081,0x000000001fa00081,0x000000001fc00081,0x000000001fe00081,
	0x0000000020000081,0x0000000020200081,0x0000000020400081,0x0000000020600081,
	0x0000000020800081,0x0000000020a00081,0x0000000020c00081,0x0000000020e00081,
	0x0000000021000081,0x0000000021200081,0x0000000021400081,0x0000000021600081,
	0x0000000021800081,0x0000000021a00081,0x0000000021c00081,0x0000000021e00081,
	0x0000000022000081,0x0000000022200081,0x0000000022400081,0x0000000022600081,
	0x0000000022800081,0x0000000022a00081,0x0000000022c00081,0x0000000022e00081,
	0x0000000023000081,0x0000000023200081,0x0000000023400081,0x0000000023600081,
	0x0000000023800081,0x0000000023a00081,0x0000000023c00081,0x0000000023e00081,
	0x0000000024000081,0x0000000024200081,0x0000000024400081,0x0000000024600081,
	0x0000000024800081,0x0000000024a00081,0x0000000024c00081,0x0000000024e00081,
	0x0000000025000081,0x0000000025200081,0x0000000025400081,0x0000000025600081,
	0x0000000025800081,0x0000000025a00081,0x0000000025c00081,0x0000000025e00081,
	0x0000000026000081,0x0000000026200081,0x0000000026400081,0x0000000026600081,
	0x0000000026800081,0x0000000026a00081,0x0000000026c00081,0x0000000026e00081,
	0x0000000027000081,0x0000000027200081,0x0000000027400081,0x0000000027600081,
	0x0000000027800081,0x0000000027a00081,0x0000000027c00081,0x0000000027e00081,
	0x0000000028000081,0x0000000028200081,0x0000000028400081,0x0000000028600081,
	0x0000000028800081,0x0000000028a00081,0x0000000028c00081,0x0000000028e00081,
	0x0000000029000081,0x0000000029200081,0x0000000029400081,0x0000000029600081,
	0x0000000029800081,0x0000000029a00081,0x0000000029c00081,0x0000000029e00081,
	0x000000002a000081,0x000000002a200081,0x000000002a400081,0x000000002a600081,
	0x000000002a800081,0x000000002aa00081,0x000000002ac00081,0x000000002ae00081,
	0x000000002b000081,0x000000002b200081,0x000000002b400081,0x000000002b600081,
	0x000000002b800081,0x000000002ba00081,0x000000002bc00081,0x000000002be00081,
	0x000000002c000081,0x000000002c200081,0x000000002c400081,0x000000002c600081,
	0x000000002c800081,0x000000002ca00081,0x000000002cc00081,0x000000002ce00081,
	0x000000002d000081,0x000000002d200081,0x000000002d400081,0x000000002d600081,
	0x000000002d800081,0x000000002da00081,0x000000002dc00081,0x000000002de00081,
	0x000000002e000081,0x000000002e200081,0x000000002e400081,0x000000002e600081,
	0x000000002e800081,0x000000002ea00081,0x000000002ec00081,0x000000002ee00081,
	0x000000002f000081,0x000000002f200081,0x000000002f400081,0x000000002f600081,
	0x000000002f800081,0x000000002fa00081,0x000000002fc00081,0x000000002fe00081,
	0x0000000030000081,0x0000000030200081,0x0000000030400081,0x0000000030600081,
	0x0000000030800081,0x0000000030a00081,0x0000000030c00081,0x0000000030e00081,
	0x0000000031000081,0x0000000031200081,0x0000000031400081,0x0000000031600081,
	0x0000000031800081,0x0000000031a00081,0x0000000031c00081,0x0000000031e00081,
	0x0000000032000081,0x0000000032200081,0x0000000032400081,0x0000000032600081,
	0x0000000032800081,0x0000000032a00081,0x0000000032c00081,0x0000000032e00081,
	0x0000000033000081,0x0000000033200081,0x0000000033400081,0x0000000033600081,
	0x0000000033800081,0x0000000033a00081,0x0000000033c00081,0x0000000033e00081,
	0x0000000034000081,0x0000000034200081,0x0000000034400081,0x0000000034600081,
	0x0000000034800081,0x0000000034a00081,0x0000000034c00081,0x0000000034e00081,
	0x0000000035000081,0x0000000035200081,0x0000000035400081,0x0000000035600081,
	0x0000000035800081,0x0000000035a00081,0x0000000035c00081,0x0000000035e00081,
	0x0000000036000081,0x0000000036200081,0x0000000036400081,0x0000000036600081,
	0x0000000036800081,0x0000000036a00081,0x0000000036c00081,0x0000000036e00081,
	0x0000000037000081,0x0000000037200081,0x0000000037400081,0x0000000037600081,
	0x0000000037800081,0x0000000037a00081,0x0000000037c00081,0x0000000037e00081,
	0x0000000038000081,0x0000000038200081,0x0000000038400081,0x0000000038600081,
	0x0000000038800081,0x0000000038a00081,0x0000000038c00081,0x0000000038e00081,
	0x0000000039000081,0x0000000039200081,0x0000000039400081,0x0000000039600081,
	0x0000000039800081,0x0000000039a00081,0x0000000039c00081,0x0000000039e00081,
	0x000000003a000081,0x000000003a200081,0x000000003a400081,0x000000003a600081,
	0x000000003a800081,0x000000003aa00081,0x000000003ac00081,0x000000003ae00081,
	0x000000003b000081,0x000000003b200081,0x000000003b400081,0x000000003b600081,
	0x000000003b800081,0x000000003ba00081,0x000000003bc00081,0x000000003be00081,
	0x000000003c000081,0x000000003c200081,0x000000003c400081,0x000000003c600081,
	0x000000003c800081,0x000000003ca00081,0x000000003cc00081,0x000000003ce00081,
	0x000000003d000081,0x000000003d200081,0x000000003d400081,0x000000003d600081,
	0x000000003d800081,0x000000003da00081,0x000000003dc00081,0x000000003de00081,
	0x000000003e000081,0x000000003e200081,0x000000003e400081,0x000000003e600081,
	0x000000003e800081,0x000000003ea00081,0x000000003ec00081,0x000000003ee00081,
	0x000000003f000081,0x000000003f200081,0x000000003f400081,0x000000003f600081,
	0x000000003f800081,0x000000003fa00081,0x000000003fc00081,0x000000003fe00081,
	0x0000000040000081,0x0000000040200081,0x0000000040400081,0x0000000040600081,
	0x0000000040800081,0x0000000040a00081,0x0000000040c00081,0x0000000040e00081,
	0x0000000041000081,0x0000000041200081,0x0000000041400081,0x0000000041600081,
	0x0000000041800081,0x0000000041a00081,0x0000000041c00081,0x0000000041e00081,
	0x0000000042000081,0x0000000042200081,0x0000000042400081,0x0000000042600081,
	0x0000000042800081,0x0000000042a00081,0x0000000042c00081,0x0000000042e00081,
	0x0000000043000081,0x0000000043200081,0x0000000043400081,0x0000000043600081,
	0x0000000043800081,0x0000000043a00081,0x0000000043c00081,0x0000000043e00081,
	0x0000000044000081,0x0000000044200081,0x0000000044400081,0x0000000044600081,
	0x0000000044800081,0x0000000044a00081,0x0000000044c00081,0x0000000044e00081,
	0x0000000045000081,0x0000000045200081,0x0000000045400081,0x0000000045600081,
	0x0000000045800081,0x0000000045a00081,0x0000000045c00081,0x0000000045e00081,
	0x0000000046000081,0x0000000046200081,0x0000000046400081,0x0000000046600081,
	0x0000000046800081,0x0000000046a00081,0x0000000046c00081,0x0000000046e00081,
	0x0000000047000081,0x0000000047200081,0x0000000047400081,0x0000000047600081,
	0x0000000047800081,0x0000000047a00081,0x0000000047c00081,0x0000000047e00081,
	0x0000000048000081,0x0000000048200081,0x0000000048400081,0x0000000048600081,
	0x0000000048800081,0x0000000048a00081,0x0000000048c00081,0x0000000048e00081,
	0x0000000049000081,0x0000000049200081,0x0000000049400081,0x0000000049600081,
	0x0000000049800081,0x0000000049a00081,0x0000000049c00081,0x0000000049e00081,
	0x000000004a000081,0x000000004a200081,0x000000004a400081,0x000000004a600081,
	0x000000004a800081,0x000000004aa00081,0x000000004ac00081,0x000000004ae00081,
	0x000000004b000081,0x000000004b200081,0x000000004b400081,0x000000004b600081,
	0x000000004b800081,0x000000004ba00081,0x000000004bc00081,0x000000004be00081,
	0x000000004c000081,0x000000004c200081,0x000000004c400081,0x000000004c600081,
	0x000000004c800081,0x000000004ca00081,0x000000004cc00081,0x000000004ce00081,
	0x000000004d000081,0x000000004d200081,0x000000004d400081,0x000000004d600081,
	0x000000004d800081,0x000000004da00081,0x000000004dc00081,0x000000004de00081,
	0x000000004e000081,0x000000004e200081,0x000000004e400081,0x000000004e600081,
	0x000000004e800081,0x000000004ea00081,0x000000004ec00081,0x000000004ee00081,
	0x000000004f000081,0x000000004f200081,0x000000004f400081,0x000000004f600081,
	0x000000004f800081,0x000000004fa00081,0x000000004fc00081,0x000000004fe00081,
	0x0000000050000081,0x0000000050200081,0x0000000050400081,0x0000000050600081,
	0x0000000050800081,0x0000000050a00081,0x0000000050c00081,0x0000000050e00081,
	0x0000000051000081,0x0000000051200081,0x0000000051400081,0x0000000051600081,
	0x0000000051800081,0x0000000051a00081,0x0000000051c00081,0x0000000051e00081,
	0x0000000052000081,0x0000000052200081,0x0000000052400081,0x0000000052600081,
	0x0000000052800081,0x0000000052a00081,0x0000000052c00081,0x0000000052e00081,
	0x0000000053000081,0x0000000053200081,0x0000000053400081,0x0000000053600081,
	0x0000000053800081,0x0000000053a00081,0x0000000053c00081,0x0000000053e00081,
	0x0000000054000081,0x0000000054200081,0x0000000054400081,0x0000000054600081,
	0x0000000054800081,0x0000000054a00081,0x0000000054c00081,0x0000000054e00081,
	0x0000000055000081,0x0000000055200081,0x0000000055400081,0x0000000055600081,
	0x0000000055800081,0x0000000055a00081,0x0000000055c00081,0x0000000055e00081,
	0x0000000056000081,0x0000000056200081,0x0000000056400081,0x0000000056600081,
	0x0000000056800081,0x0000000056a00081,0x0000000056c00081,0x0000000056e00081,
	0x0000000057000081,0x0000000057200081,0x0000000057400081,0x0000000057600081,
	0x0000000057800081,0x0000000057a00081,0x0000000057c00081,0x0000000057e00081,
	0x0000000058000081,0x0000000058200081,0x0000000058400081,0x0000000058600081,
	0x0000000058800081,0x0000000058a00081,0x0000000058c00081,0x0000000058e00081,
	0x0000000059000081,0x0000000059200081,0x0000000059400081,0x0000000059600081,
	0x0000000059800081,0x0000000059a00081,0x0000000059c00081,0x0000000059e00081,
	0x000000005a000081,0x000000005a200081,0x000000005a400081,0x000000005a600081,
	0x000000005a800081,0x000000005aa00081,0x000000005ac00081,0x000000005ae00081,
	0x000000005b000081,0x000000005b200081,0x000000005b400081,0x000000005b600081,
	0x000000005b800081,0x000000005ba00081,0x000000005bc00081,0x000000005be00081,
	0x000000005c000081,0x000000005c200081,0x000000005c400081,0x000000005c600081,
	0x000000005c800081,0x000000005ca00081,0x000000005cc00081,0x000000005ce00081,
	0x000000005d000081,0x000000005d200081,0x000000005d400081,0x000000005d600081,
	0x000000005d800081,0x000000005da00081,0x000000005dc00081,0x000000005de00081,
	0x000000005e000081,0x000000005e200081,0x000000005e400081,0x000000005e600081,
	0x000000005e800081,0x000000005ea00081,0x000000005ec00081,0x000000005ee00081,
	0x000000005f000081,0x000000005f200081,0x000000005f400081,0x000000005f600081,
	0x000000005f800081,0x000000005fa00081,0x000000005fc00081,0x000000005fe00081,
	0x0000000060000081,0x0000000060200081,0x0000000060400081,0x0000000060600081,
	0x0000000060800081,0x0000000060a00081,0x0000000060c00081,0x0000000060e00081,
	0x0000000061000081,0x0000000061200081,0x0000000061400081,0x0000000061600081,
	0x0000000061800081,0x0000000061a00081,0x0000000061c00081,0x0000000061e00081,
	0x0000000062000081,0x0000000062200081,0x0000000062400081,0x0000000062600081,
	0x0000000062800081,0x0000000062a00081,0x0000000062c00081,0x0000000062e00081,
	0x0000000063000081,0x0000000063200081,0x0000000063400081,0x0000000063600081,
	0x0000000063800081,0x0000000063a00081,0x0000000063c00081,0x0000000063e00081,
	0x0000000064000081,0x0000000064200081,0x0000000064400081,0x0000000064600081,
	0x0000000064800081,0x0000000064a00081,0x0000000064c00081,0x0000000064e00081,
	0x0000000065000081,0x0000000065200081,0x0000000065400081,0x0000000065600081,
	0x0000000065800081,0x0000000065a00081,0x0000000065c00081,0x0000000065e00081,
	0x0000000066000081,0x0000000066200081,0x0000000066400081,0x0000000066600081,
	0x0000000066800081,0x0000000066a00081,0x0000000066c00081,0x0000000066e00081,
	0x0000000067000081,0x0000000067200081,0x0000000067400081,0x0000000067600081,
	0x0000000067800081,0x0000000067a00081,0x0000000067c00081,0x0000000067e00081,
	0x0000000068000081,0x0000000068200081,0x0000000068400081,0x0000000068600081,
	0x0000000068800081,0x0000000068a00081,0x0000000068c00081,0x0000000068e00081,
	0x0000000069000081,0x0000000069200081,0x0000000069400081,0x0000000069600081,
	0x0000000069800081,0x0000000069a00081,0x0000000069c00081,0x0000000069e00081,
	0x000000006a000081,0x000000006a200081,0x000000006a400081,0x000000006a600081,
	0x000000006a800081,0x000000006aa00081,0x000000006ac00081,0x000000006ae00081,
	0x000000006b000081,0x000000006b200081,0x000000006b400081,0x000000006b600081,
	0x000000006b800081,0x000000006ba00081,0x000000006bc00081,0x000000006be00081,
	0x000000006c000081,0x000000006c200081,0x000000006c400081,0x000000006c600081,
	0x000000006c800081,0x000000006ca00081,0x000000006cc00081,0x000000006ce00081,
	0x000000006d000081,0x000000006d200081,0x000000006d400081,0x000000006d600081,
	0x000000006d800081,0x000000006da00081,0x000000006dc00081,0x000000006de00081,
	0x000000006e000081,0x000000006e200081,0x000000006e400081,0x000000006e600081,
	0x000000006e800081,0x000000006ea00081,0x000000006ec00081,0x000000006ee00081,
	0x000000006f000081,0x000000006f200081,0x000000006f400081,0x000000006f600081,
	0x000000006f800081,0x000000006fa00081,0x000000006fc00081,0x000000006fe00081,
	0x0000000070000081,0x0000000070200081,0x0000000070400081,0x0000000070600081,
	0x0000000070800081,0x0000000070a00081,0x0000000070c00081,0x0000000070e00081,
	0x0000000071000081,0x0000000071200081,0x0000000071400081,0x0000000071600081,
	0x0000000071800081,0x0000000071a00081,0x0000000071c00081,0x0000000071e00081,
	0x0000000072000081,0x0000000072200081,0x0000000072400081,0x0000000072600081,
	0x0000000072800081,0x0000000072a00081,0x0000000072c00081,0x0000000072e00081,
	0x0000000073000081,0x0000000073200081,0x0000000073400081,0x0000000073600081,
	0x0000000073800081,0x0000000073a00081,0x0000000073c00081,0x0000000073e00081,
	0x0000000074000081,0x0000000074200081,0x0000000074400081,0x0000000074600081,
	0x0000000074800081,0x0000000074a00081,0x0000000074c00081,0x0000000074e00081,
	0x0000000075000081,0x0000000075200081,0x0000000075400081,0x0000000075600081,
	0x0000000075800081,0x0000000075a00081,0x0000000075c00081,0x0000000075e00081,
	0x0000000076000081,0x0000000076200081,0x0000000076400081,0x0000000076600081,
	0x0000000076800081,0x0000000076a00081,0x0000000076c00081,0x0000000076e00081,
	0x0000000077000081,0x0000000077200081,0x0000000077400081,0x0000000077600081,
	0x0000000077800081,0x0000000077a00081,0x0000000077c00081,0x0000000077e00081,
	0x0000000078000081,0x0000000078200081,0x0000000078400081,0x0000000078600081,
	0x0000000078800081,0x0000000078a00081,0x0000000078c00081,0x0000000078e00081,
	0x0000000079000081,0x0000000079200081,0x0000000079400081,0x0000000079600081,
	0x0000000079800081,0x0000000079a00081,0x0000000079c00081,0x0000000079e00081,
	0x000000007a000081,0x000000007a200081,0x000000007a400081,0x000000007a600081,
	0x000000007a800081,0x000000007aa00081,0x000000007ac00081,0x000000007ae00081,
	0x000000007b000081,0x000000007b200081,0x000000007b400081,0x000000007b600081,
	0x000000007b800081,0x000000007ba00081,0x000000007bc00081,0x000000007be00081,
	0x000000007c000081,0x000000007c200081,0x000000007c400081,0x000000007c600081,
	0x000000007c800081,0x000000007ca00081,0x000000007cc00081,0x000000007ce00081,
	0x000000007d000081,0x000000007d200081,0x000000007d400081,0x000000007d600081,
	0x000000007d800081,0x000000007da00081,0x000000007dc00081,0x000000007de00081,
	0x000000007e000081,0x000000007e200081,0x000000007e400081,0x000000007e600081,
	0x000000007e800081,0x000000007ea00081,0x000000007ec00081,0x000000007ee00081,
	0x000000007f000081,0x000000007f200081,0x000000007f400081,0x000000007f600081,
	0x000000007f800081,0x000000007fa00081,0x000000007fc00081,0x000000007fe00081,
	0x0000000080000081,0x0000000080200081,0x0000000080400081,0x0000000080600081,
	0x0000000080800081,0x0000000080a00081,0x0000000080c00081,0x0000000080e00081,
	0x0000000081000081,0x0000000081200081,0x0000000081400081,0x0000000081600081,
	0x0000000081800081,0x0000000081a00081,0x0000000081c00081,0x0000000081e00081,
	0x0000000082000081,0x0000000082200081,0x0000000082400081,0x0000000082600081,
	0x0000000082800081,0x0000000082a00081,0x0000000082c00081,0x0000000082e00081,
	0x0000000083000081,0x0000000083200081,0x0000000083400081,0x0000000083600081,
	0x0000000083800081,0x0000000083a00081,0x0000000083c00081,0x0000000083e00081,
	0x0000000084000081,0x0000000084200081,0x0000000084400081,0x0000000084600081,
	0x0000000084800081,0x0000000084a00081,0x0000000084c00081,0x0000000084e00081,
	0x0000000085000081,0x0000000085200081,0x0000000085400081,0x0000000085600081,
	0x0000000085800081,0x0000000085a00081,0x0000000085c00081,0x0000000085e00081,
	0x0000000086000081,0x0000000086200081,0x0000000086400081,0x0000000086600081,
	0x0000000086800081,0x0000000086a00081,0x0000000086c00081,0x0000000086e00081,
	0x0000000087000081,0x0000000087200081,0x0000000087400081,0x0000000087600081,
	0x0000000087800081,0x0000000087a00081,0x0000000087c00081,0x0000000087e00081,
	0x0000000088000081,0x0000000088200081,0x0000000088400081,0x0000000088600081,
	0x0000000088800081,0x0000000088a00081,0x0000000088c00081,0x0000000088e00081,
	0x0000000089000081,0x0000000089200081,0x0000000089400081,0x0000000089600081,
	0x0000000089800081,0x0000000089a00081,0x0000000089c00081,0x0000000089e00081,
	0x000000008a000081,0x000000008a200081,0x000000008a400081,0x000000008a600081,
	0x000000008a800081,0x000000008aa00081,0x000000008ac00081,0x000000008ae00081,
	0x000000008b000081,0x000000008b200081,0x000000008b400081,0x000000008b600081,
	0x000000008b800081,0x000000008ba00081,0x000000008bc00081,0x000000008be00081,
	0x000000008c000081,0x000000008c200081,0x000000008c400081,0x000000008c600081,
	0x000000008c800081,0x000000008ca00081,0x000000008cc00081,0x000000008ce00081,
	0x000000008d000081,0x000000008d200081,0x000000008d400081,0x000000008d600081,
	0x000000008d800081,0x000000008da00081,0x000000008dc00081,0x000000008de00081,
	0x000000008e000081,0x000000008e200081,0x000000008e400081,0x000000008e600081,
	0x000000008e800081,0x000000008ea00081,0x000000008ec00081,0x000000008ee00081,
	0x000000008f000081,0x000000008f200081,0x000000008f400081,0x000000008f600081,
	0x000000008f800081,0x000000008fa00081,0x000000008fc00081,0x000000008fe00081,
	0x0000000090000081,0x0000000090200081,0x0000000090400081,0x0000000090600081,
	0x0000000090800081,0x0000000090a00081,0x0000000090c00081,0x0000000090e00081,
	0x0000000091000081,0x0000000091200081,0x0000000091400081,0x0000000091600081,
	0x0000000091800081,0x0000000091a00081,0x0000000091c00081,0x0000000091e00081,
	0x0000000092000081,0x0000000092200081,0x0000000092400081,0x0000000092600081,
	0x0000000092800081,0x0000000092a00081,0x0000000092c00081,0x0000000092e00081,
	0x0000000093000081,0x0000000093200081,0x0000000093400081,0x0000000093600081,
	0x0000000093800081,0x0000000093a00081,0x0000000093c00081,0x0000000093e00081,
	0x0000000094000081,0x0000000094200081,0x0000000094400081,0x0000000094600081,
	0x0000000094800081,0x0000000094a00081,0x0000000094c00081,0x0000000094e00081,
	0x0000000095000081,0x0000000095200081,0x0000000095400081,0x0000000095600081,
	0x0000000095800081,0x0000000095a00081,0x0000000095c00081,0x0000000095e00081,
	0x0000000096000081,0x0000000096200081,0x0000000096400081,0x0000000096600081,
	0x0000000096800081,0x0000000096a00081,0x0000000096c00081,0x0000000096e00081,
	0x0000000097000081,0x0000000097200081,0x0000000097400081,0x0000000097600081,
	0x0000000097800081,0x0000000097a00081,0x0000000097c00081,0x0000000097e00081,
	0x0000000098000081,0x0000000098200081,0x0000000098400081,0x0000000098600081,
	0x0000000098800081,0x0000000098a00081,0x0000000098c00081,0x0000000098e00081,
	0x0000000099000081,0x0000000099200081,0x0000000099400081,0x0000000099600081,
	0x0000000099800081,0x0000000099a00081,0x0000000099c00081,0x0000000099e00081,
	0x000000009a000081,0x000000009a200081,0x000000009a400081,0x000000009a600081,
	0x000000009a800081,0x000000009aa00081,0x000000009ac00081,0x000000009ae00081,
	0x000000009b000081,0x000000009b200081,0x000000009b400081,0x000000009b600081,
	0x000000009b800081,0x000000009ba00081,0x000000009bc00081,0x000000009be00081,
	0x000000009c000081,0x000000009c200081,0x000000009c400081,0x000000009c600081,
	0x000000009c800081,0x000000009ca00081,0x000000009cc00081,0x000000009ce00081,
	0x000000009d000081,0x000000009d200081,0x000000009d400081,0x000000009d600081,
	0x000000009d800081,0x000000009da00081,0x000000009dc00081,0x000000009de00081,
	0x000000009e000081,0x000000009e200081,0x000000009e400081,0x000000009e600081,
	0x000000009e800081,0x000000009ea00081,0x000000009ec00081,0x000000009ee00081,
	0x000000009f000081,0x000000009f200081,0x000000009f400081,0x000000009f600081,
	0x000000009f800081,0x000000009fa00081,0x000000009fc00081,0x000000009fe00081,
	0x00000000a0000081,0x00000000a0200081,0x00000000a0400081,0x00000000a0600081,
	0x00000000a0800081,0x00000000a0a00081,0x00000000a0c00081,0x00000000a0e00081,
	0x00000000a1000081,0x00000000a1200081,0x00000000a1400081,0x00000000a1600081,
	0x00000000a1800081,0x00000000a1a00081,0x00000000a1c00081,0x00000000a1e00081,
	0x00000000a2000081,0x00000000a2200081,0x00000000a2400081,0x00000000a2600081,
	0x00000000a2800081,0x00000000a2a00081,0x00000000a2c00081,0x00000000a2e00081,
	0x00000000a3000081,0x00000000a3200081,0x00000000a3400081,0x00000000a3600081,
	0x00000000a3800081,0x00000000a3a00081,0x00000000a3c00081,0x00000000a3e00081,
	0x00000000a4000081,0x00000000a4200081,0x00000000a4400081,0x00000000a4600081,
	0x00000000a4800081,0x00000000a4a00081,0x00000000a4c00081,0x00000000a4e00081,
	0x00000000a5000081,0x00000000a5200081,0x00000000a5400081,0x00000000a5600081,
	0x00000000a5800081,0x00000000a5a00081,0x00000000a5c00081,0x00000000a5e00081,
	0x00000000a6000081,0x00000000a6200081,0x00000000a6400081,0x00000000a6600081,
	0x00000000a6800081,0x00000000a6a00081,0x00000000a6c00081,0x00000000a6e00081,
	0x00000000a7000081,0x00000000a7200081,0x00000000a7400081,0x00000000a7600081,
	0x00000000a7800081,0x00000000a7a00081,0x00000000a7c00081,0x00000000a7e00081,
	0x00000000a8000081,0x00000000a8200081,0x00000000a8400081,0x00000000a8600081,
	0x00000000a8800081,0x00000000a8a00081,0x00000000a8c00081,0x00000000a8e00081,
	0x00000000a9000081,0x00000000a9200081,0x00000000a9400081,0x00000000a9600081,
	0x00000000a9800081,0x00000000a9a00081,0x00000000a9c00081,0x00000000a9e00081,
	0x00000000aa000081,0x00000000aa200081,0x00000000aa400081,0x00000000aa600081,
	0x00000000aa800081,0x00000000aaa00081,0x00000000aac00081,0x00000000aae00081,
	0x00000000ab000081,0x00000000ab200081,0x00000000ab400081,0x00000000ab600081,
	0x00000000ab800081,0x00000000aba00081,0x00000000abc00081,0x00000000abe00081,
	0x00000000ac000081,0x00000000ac200081,0x00000000ac400081,0x00000000ac600081,
	0x00000000ac800081,0x00000000aca00081,0x00000000acc00081,0x00000000ace00081,
	0x00000000ad000081,0x00000000ad200081,0x00000000ad400081,0x00000000ad600081,
	0x00000000ad800081,0x00000000ada00081,0x00000000adc00081,0x00000000ade00081,
	0x00000000ae000081,0x00000000ae200081,0x00000000ae400081,0x00000000ae600081,
	0x00000000ae800081,0x00000000aea00081,0x00000000aec00081,0x00000000aee00081,
	0x00000000af000081,0x00000000af200081,0x00000000af400081,0x00000000af600081,
	0x00000000af800081,0x00000000afa00081,0x00000000afc00081,0x00000000afe00081,
	0x00000000b0000081,0x00000000b0200081,0x00000000b0400081,0x00000000b0600081,
	0x00000000b0800081,0x00000000b0a00081,0x00000000b0c00081,0x00000000b0e00081,
	0x00000000b1000081,0x00000000b1200081,0x00000000b1400081,0x00000000b1600081,
	0x00000000b1800081,0x00000000b1a00081,0x00000000b1c00081,0x00000000b1e00081,
	0x00000000b2000081,0x00000000b2200081,0x00000000b2400081,0x00000000b2600081,
	0x00000000b2800081,0x00000000b2a00081,0x00000000b2c00081,0x00000000b2e00081,
	0x00000000b3000081,0x00000000b3200081,0x00000000b3400081,0x00000000b3600081,
	0x00000000b3800081,0x00000000b3a00081,0x00000000b3c00081,0x00000000b3e00081,
	0x00000000b4000081,0x00000000b4200081,0x00000000b4400081,0x00000000b4600081,
	0x00000000b4800081,0x00000000b4a00081,0x00000000b4c00081,0x00000000b4e00081,
	0x00000000b5000081,0x00000000b5200081,0x00000000b5400081,0x00000000b5600081,
	0x00000000b5800081,0x00000000b5a00081,0x00000000b5c00081,0x00000000b5e00081,
	0x00000000b6000081,0x00000000b6200081,0x00000000b6400081,0x00000000b6600081,
	0x00000000b6800081,0x00000000b6a00081,0x00000000b6c00081,0x00000000b6e00081,
	0x00000000b7000081,0x00000000b7200081,0x00000000b7400081,0x00000000b7600081,
	0x00000000b7800081,0x00000000b7a00081,0x00000000b7c00081,0x00000000b7e00081,
	0x00000000b8000081,0x00000000b8200081,0x00000000b8400081,0x00000000b8600081,
	0x00000000b8800081,0x00000000b8a00081,0x00000000b8c00081,0x00000000b8e00081,
	0x00000000b9000081,0x00000000b9200081,0x00000000b9400081,0x00000000b9600081,
	0x00000000b9800081,0x00000000b9a00081,0x00000000b9c00081,0x00000000b9e00081,
	0x00000000ba000081,0x00000000ba200081,0x00000000ba400081,0x00000000ba600081,
	0x00000000ba800081,0x00000000baa00081,0x00000000bac00081,0x00000000bae00081,
	0x00000000bb000081,0x00000000bb200081,0x00000000bb400081,0x00000000bb600081,
	0x00000000bb800081,0x00000000bba00081,0x00000000bbc00081,0x00000000bbe00081,
	0x00000000bc000081,0x00000000bc200081,0x00000000bc400081,0x00000000bc600081,
	0x00000000bc800081,0x00000000bca00081,0x00000000bcc00081,0x00000000bce00081,
	0x00000000bd000081,0x00000000bd200081,0x00000000bd400081,0x00000000bd600081,
	0x00000000bd800081,0x00000000bda00081,0x00000000bdc00081,0x00000000bde00081,
	0x00000000be000081,0x00000000be200081,0x00000000be400081,0x00000000be600081,
	0x00000000be800081,0x00000000bea00081,0x00000000bec00081,0x00000000bee00081,
	0x00000000bf000081,0x00000000bf200081,0x00000000bf400081,0x00000000bf600081,
	0x00000000bf800081,0x00000000bfa00081,0x00000000bfc00081,0x00000000bfe00081,
	0x00000000c0000081,0x00000000c0200081,0x00000000c0400081,0x00000000c0600081,
	0x00000000c0800081,0x00000000c0a00081,0x00000000c0c00081,0x00000000c0e00081,
	0x00000000c1000081,0x00000000c1200081,0x00000000c1400081,0x00000000c1600081,
	0x00000000c1800081,0x00000000c1a00081,0x00000000c1c00081,0x00000000c1e00081,
	0x00000000c2000081,0x00000000c2200081,0x00000000c2400081,0x00000000c2600081,
	0x00000000c2800081,0x00000000c2a00081,0x00000000c2c00081,0x00000000c2e00081,
	0x00000000c3000081,0x00000000c3200081,0x00000000c3400081,0x00000000c3600081,
	0x00000000c3800081,0x00000000c3a00081,0x00000000c3c00081,0x00000000c3e00081,
	0x00000000c4000081,0x00000000c4200081,0x00000000c4400081,0x00000000c4600081,
	0x00000000c4800081,0x00000000c4a00081,0x00000000c4c00081,0x00000000c4e00081,
	0x00000000c5000081,0x00000000c5200081,0x00000000c5400081,0x00000000c5600081,
	0x00000000c5800081,0x00000000c5a00081,0x00000000c5c00081,0x00000000c5e00081,
	0x00000000c6000081,0x00000000c6200081,0x00000000c6400081,0x00000000c6600081,
	0x00000000c6800081,0x00000000c6a00081,0x00000000c6c00081,0x00000000c6e00081,
	0x00000000c7000081,0x00000000c7200081,0x00000000c7400081,0x00000000c7600081,
	0x00000000c7800081,0x00000000c7a00081,0x00000000c7c00081,0x00000000c7e00081,
	0x00000000c8000081,0x00000000c8200081,0x00000000c8400081,0x00000000c8600081,
	0x00000000c8800081,0x00000000c8a00081,0x00000000c8c00081,0x00000000c8e00081,
	0x00000000c9000081,0x00000000c9200081,0x00000000c9400081,0x00000000c9600081,
	0x00000000c9800081,0x00000000c9a00081,0x00000000c9c00081,0x00000000c9e00081,
	0x00000000ca000081,0x00000000ca200081,0x00000000ca400081,0x00000000ca600081,
	0x00000000ca800081,0x00000000caa00081,0x00000000cac00081,0x00000000cae00081,
	0x00000000cb000081,0x00000000cb200081,0x00000000cb400081,0x00000000cb600081,
	0x00000000cb800081,0x00000000cba00081,0x00000000cbc00081,0x00000000cbe00081,
	0x00000000cc000081,0x00000000cc200081,0x00000000cc400081,0x00000000cc600081,
	0x00000000cc800081,0x00000000cca00081,0x00000000ccc00081,0x00000000cce00081,
	0x00000000cd000081,0x00000000cd200081,0x00000000cd400081,0x00000000cd600081,
	0x00000000cd800081,0x00000000cda00081,0x00000000cdc00081,0x00000000cde00081,
	0x00000000ce000081,0x00000000ce200081,0x00000000ce400081,0x00000000ce600081,
	0x00000000ce800081,0x00000000cea00081,0x00000000cec00081,0x00000000cee00081,
	0x00000000cf000081,0x00000000cf200081,0x00000000cf400081,0x00000000cf600081,
	0x00000000cf800081,0x00000000cfa00081,0x00000000cfc00081,0x00000000cfe00081,
	0x00000000d0000081,0x00000000d0200081,0x00000000d0400081,0x00000000d0600081,
	0x00000000d0800081,0x00000000d0a00081,0x00000000d0c00081,0x00000000d0e00081,
	0x00000000d1000081,0x00000000d1200081,0x00000000d1400081,0x00000000d1600081,
	0x00000000d1800081,0x00000000d1a00081,0x00000000d1c00081,0x00000000d1e00081,
	0x00000000d2000081,0x00000000d2200081,0x00000000d2400081,0x00000000d2600081,
	0x00000000d2800081,0x00000000d2a00081,0x00000000d2c00081,0x00000000d2e00081,
	0x00000000d3000081,0x00000000d3200081,0x00000000d3400081,0x00000000d3600081,
	0x00000000d3800081,0x00000000d3a00081,0x00000000d3c00081,0x00000000d3e00081,
	0x00000000d4000081,0x00000000d4200081,0x00000000d4400081,0x00000000d4600081,
	0x00000000d4800081,0x00000000d4a00081,0x00000000d4c00081,0x00000000d4e00081,
	0x00000000d5000081,0x00000000d5200081,0x00000000d5400081,0x00000000d5600081,
	0x00000000d5800081,0x00000000d5a00081,0x00000000d5c00081,0x00000000d5e00081,
	0x00000000d6000081,0x00000000d6200081,0x00000000d6400081,0x00000000d6600081,
	0x00000000d6800081,0x00000000d6a00081,0x00000000d6c00081,0x00000000d6e00081,
	0x00000000d7000081,0x00000000d7200081,0x00000000d7400081,0x00000000d7600081,
	0x00000000d7800081,0x00000000d7a00081,0x00000000d7c00081,0x00000000d7e00081,
	0x00000000d8000081,0x00000000d8200081,0x00000000d8400081,0x00000000d8600081,
	0x00000000d8800081,0x00000000d8a00081,0x00000000d8c00081,0x00000000d8e00081,
	0x00000000d9000081,0x00000000d9200081,0x00000000d9400081,0x00000000d9600081,
	0x00000000d9800081,0x00000000d9a00081,0x00000000d9c00081,0x00000000d9e00081,
	0x00000000da000081,0x00000000da200081,0x00000000da400081,0x00000000da600081,
	0x00000000da800081,0x00000000daa00081,0x00000000dac00081,0x00000000dae00081,
	0x00000000db000081,0x00000000db200081,0x00000000db400081,0x00000000db600081,
	0x00000000db800081,0x00000000dba00081,0x00000000dbc00081,0x00000000dbe00081,
	0x00000000dc000081,0x00000000dc200081,0x00000000dc400081,0x00000000dc600081,
	0x00000000dc800081,0x00000000dca00081,0x00000000dcc00081,0x00000000dce00081,
	0x00000000dd000081,0x00000000dd200081,0x00000000dd400081,0x00000000dd600081,
	0x00000000dd800081,0x00000000dda00081,0x00000000ddc00081,0x00000000dde00081,
	0x00000000de000081,0x00000000de200081,0x00000000de400081,0x00000000de600081,
	0x00000000de800081,0x00000000dea00081,0x00000000dec00081,0x00000000dee00081,
	0x00000000df000081,0x00000000df200081,0x00000000df400081,0x00000000df600081,
	0x00000000df800081,0x00000000dfa00081,0x00000000dfc00081,0x00000000dfe00081,
	0x00000000e0000081,0x00000000e0200081,0x00000000e0400081,0x00000000e0600081,
	0x00000000e0800081,0x00000000e0a00081,0x00000000e0c00081,0x00000000e0e00081,
	0x00000000e1000081,0x00000000e1200081,0x00000000e1400081,0x00000000e1600081,
	0x00000000e1800081,0x00000000e1a00081,0x00000000e1c00081,0x00000000e1e00081,
	0x00000000e2000081,0x00000000e2200081,0x00000000e2400081,0x00000000e2600081,
	0x00000000e2800081,0x00000000e2a00081,0x00000000e2c00081,0x00000000e2e00081,
	0x00000000e3000081,0x00000000e3200081,0x00000000e3400081,0x00000000e3600081,
	0x00000000e3800081,0x00000000e3a00081,0x00000000e3c00081,0x00000000e3e00081,
	0x00000000e4000081,0x00000000e4200081,0x00000000e4400081,0x00000000e4600081,
	0x00000000e4800081,0x00000000e4a00081,0x00000000e4c00081,0x00000000e4e00081,
	0x00000000e5000081,0x00000000e5200081,0x00000000e5400081,0x00000000e5600081,
	0x00000000e5800081,0x00000000e5a00081,0x00000000e5c00081,0x00000000e5e00081,
	0x00000000e6000081,0x00000000e6200081,0x00000000e6400081,0x00000000e6600081,
	0x00000000e6800081,0x00000000e6a00081,0x00000000e6c00081,0x00000000e6e00081,
	0x00000000e7000081,0x00000000e7200081,0x00000000e7400081,0x00000000e7600081,
	0x00000000e7800081,0x00000000e7a00081,0x00000000e7c00081,0x00000000e7e00081,
	0x00000000e8000081,0x00000000e8200081,0x00000000e8400081,0x00000000e8600081,
	0x00000000e8800081,0x00000000e8a00081,0x00000000e8c00081,0x00000000e8e00081,
	0x00000000e9000081,0x00000000e9200081,0x00000000e9400081,0x00000000e9600081,
	0x00000000e9800081,0x00000000e9a00081,0x00000000e9c00081,0x00000000e9e00081,
	0x00000000ea000081,0x00000000ea200081,0x00000000ea400081,0x00000000ea600081,
	0x00000000ea800081,0x00000000eaa00081,0x00000000eac00081,0x00000000eae00081,
	0x00000000eb000081,0x00000000eb200081,0x00000000eb400081,0x00000000eb600081,
	0x00000000eb800081,0x00000000eba00081,0x00000000ebc00081,0x00000000ebe00081,
	0x00000000ec000081,0x00000000ec200081,0x00000000ec400081,0x00000000ec600081,
	0x00000000ec800081,0x00000000eca00081,0x00000000ecc00081,0x00000000ece00081,
	0x00000000ed000081,0x00000000ed200081,0x00000000ed400081,0x00000000ed600081,
	0x00000000ed800081,0x00000000eda00081,0x00000000edc00081,0x00000000ede00081,
	0x00000000ee000081,0x00000000ee200081,0x00000000ee400081,0x00000000ee600081,
	0x00000000ee800081,0x00000000eea00081,0x00000000eec00081,0x00000000eee00081,
	0x00000000ef000081,0x00000000ef200081,0x00000000ef400081,0x00000000ef600081,
	0x00000000ef800081,0x00000000efa00081,0x00000000efc00081,0x00000000efe00081,
	0x00000000f0000081,0x00000000f0200081,0x00000000f0400081,0x00000000f0600081,
	0x00000000f0800081,0x00000000f0a00081,0x00000000f0c00081,0x00000000f0e00081,
	0x00000000f1000081,0x00000000f1200081,0x00000000f1400081,0x00000000f1600081,
	0x00000000f1800081,0x00000000f1a00081,0x00000000f1c00081,0x00000000f1e00081,
	0x00000000f2000081,0x00000000f2200081,0x00000000f2400081,0x00000000f2600081,
	0x00000000f2800081,0x00000000f2a00081,0x00000000f2c00081,0x00000000f2e00081,
	0x00000000f3000081,0x00000000f3200081,0x00000000f3400081,0x00000000f3600081,
	0x00000000f3800081,0x00000000f3a00081,0x00000000f3c00081,0x00000000f3e00081,
	0x00000000f4000081,0x00000000f4200081,0x00000000f4400081,0x00000000f4600081,
	0x00000000f4800081,0x00000000f4a00081,0x00000000f4c00081,0x00000000f4e00081,
	0x00000000f5000081,0x00000000f5200081,0x00000000f5400081,0x00000000f5600081,
	0x00000000f5800081,0x00000000f5a00081,0x00000000f5c00081,0x00000000f5e00081,
	0x00000000f6000081,0x00000000f6200081,0x00000000f6400081,0x00000000f6600081,
	0x00000000f6800081,0x00000000f6a00081,0x00000000f6c00081,0x00000000f6e00081,
	0x00000000f7000081,0x00000000f7200081,0x00000000f7400081,0x00000000f7600081,
	0x00000000f7800081,0x00000000f7a00081,0x00000000f7c00081,0x00000000f7e00081,
	0x00000000f8000081,0x00000000f8200081,0x00000000f8400081,0x00000000f8600081,
	0x00000000f8800081,0x00000000f8a00081,0x00000000f8c00081,0x00000000f8e00081,
	0x00000000f9000081,0x00000000f9200081,0x00000000f9400081,0x00000000f9600081,
	0x00000000f9800081,0x00000000f9a00081,0x00000000f9c00081,0x00000000f9e00081,
	0x00000000fa000081,0x00000000fa200081,0x00000000fa400081,0x00000000fa600081,
	0x00000000fa800081,0x00000000faa00081,0x00000000fac00081,0x00000000fae00081,
	0x00000000fb000081,0x00000000fb200081,0x00000000fb400081,0x00000000fb600081,
	0x00000000fb800081,0x00000000fba00081,0x00000000fbc00081,0x00000000fbe00081,
	0x00000000fc000081,0x00000000fc200081,0x00000000fc400081,0x00000000fc600081,
	0x00000000fc800081,0x00000000fca00081,0x00000000fcc00081,0x00000000fce00081,
	0x00000000fd000081,0x00000000fd200081,0x00000000fd400081,0x00000000fd600081,
	0x00000000fd800081,0x00000000fda00081,0x00000000fdc00081,0x00000000fde00081,
	0x00000000fe000081,0x00000000fe200081,0x00000000fe400081,0x00000000fe600081,
	0x00000000fe800081,0x00000000fea00081,0x00000000fec00091,0x00000000fee00091,
	0x00000000ff000091,0x00000000ff200091,0x00000000ff400091,0x00000000ff600091,
	0x00000000ff800091,0x00000000ffa00091,0x00000000ffc00091,0x00000000ffe00091,
};

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pdpt[PAE_MAXPTRS_PER_PDPT] = {
    ((u64)(&_xcprimeon_init_pdt[0]) + (u64)(_PAGE_PRESENT) ),
    ((u64)(&_xcprimeon_init_pdt[512]) + (u64)(_PAGE_PRESENT) ),
    ((u64)(&_xcprimeon_init_pdt[1024]) + (u64)(_PAGE_PRESENT) ),
    ((u64)(&_xcprimeon_init_pdt[1536]) + (u64)(_PAGE_PRESENT) ),
    0
};

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pml4t[PAE_MAXPTRS_PER_PDPT] = {
    ((u64)(&_xcprimeon_init_pdpt) + (u64)(_PAGE_PRESENT) ),
    0
};


__attribute__(( aligned(16) )) static u64 _xcprimeon_init_gdt_start[]  = {
	0x0000000000000000ULL,	//NULL descriptor
	0x00af9b000000ffffULL,	//CPL-0 64-bit code descriptor (CS64)
	0x00af93000000ffffULL,	//CPL-0 64-bit data descriptor (DS/SS/ES/FS/GS)
};

__attribute__(( aligned(16) )) static arch_x86_gdtdesc_t _xcprimeon_init_gdt  = {
	.size=sizeof(_xcprimeon_init_gdt_start)-1,
	.base=&_xcprimeon_init_gdt_start,
};


__attribute__((naked)) __attribute__ ((section(".hic_entrystub"))) __attribute__(( align(4096) )) void xcprimeon_arch_entry(void) {

	asm volatile (
                    ".code32 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 0x80, 1, 0x90\r\n" //TODO: should really be sizeof(mle_hdr_t)
					"_xcprimeon_start: \r\n"

					"movw %%ds, %%ax \r\n"
					"movw %%ax, %%es \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"

					"movl $0x10200000, %%esp \r\n" //TODO: get rid of hard-coded stack top

    				"movl %%cr4, %%eax \r\n"
   					"orl $0x00000030, %%eax \r\n"
   					"movl %%eax, %%cr4 \r\n"

                    "movl %0, %%eax \r\n"
                    "movl %%eax, %%cr3 \r\n"

                    "movl $0xc0000080, %%ecx \r\n"
                    "rdmsr \r\n"
                    "orl $0x00000100, %%eax \r\n"
                    "orl $0x00000800, %%eax \r\n"
                    "wrmsr \r\n"

                    "movl %%cr0, %%eax \r\n"
                    "orl $0x80000015, %%eax \r\n"
                    "movl %%eax, %%cr0 \r\n"

                    "movl %1, %%esi \r\n"
                    "lgdt (%%esi) \r\n"

                    "pushl $8 \r\n"
                    "pushl $_xcprimeon_start64 \r\n"
                    "lret \r\n"

                    ".code64 \r\n"
                    "_xcprimeon_start64: \r\n"

					"movw $0x10, %%ax \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"
					"movw %%ax, %%ds \r\n"
					"movw %%ax, %%es \r\n"

					"xorq %%rsp, %%rsp \r\n"
					"movl $0x10200000, %%esp \r\n" //TODO: get rid of hard-coded stack top

                    "jmp xmhfhic_entry \r\n"
			    :
			    : "i" (&_xcprimeon_init_pml4t), "i" (&_xcprimeon_init_gdt)
                :
	);
}





















/////////////////////////////////////////////////////////////////////////////
// relinquish HIC initialization and move on to the first slab
/*
void xcprimeon_arch_relinquish_control(void){

    asm volatile(
                 	"movl %0, %%eax\r\n"
					"movl (%%eax), %%eax\r\n"
					"shr $24, %%eax\r\n"
					"movl %2, %%ebx\r\n"
					"movl %1, %%ecx \r\n"
					"1: cmpl 0x0(%%ebx), %%eax\r\n"
					"jz 2f\r\n"
					"addl %3, %%ebx\r\n"
					"loop 1b \r\n"
					"hlt\r\n"								// we should never get here, if so just halt
					"2: movl 0x4(%%ebx), %%eax\r\n"			// eax = g_xc_cputable[ecx].cpu_index
					"movl %5, %%ecx \r\n"					// ecx = sizeof(_cpustack[0])
					"mull %%ecx \r\n"						// eax = sizeof(_cpustack[0]) * eax
					"addl %%ecx, %%eax \r\n"				// eax = (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"addl %4, %%eax \r\n"				    // eax = &_cpustack + (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"movl %%eax, %%esp \r\n"				// esp = top of stack for the cpu

					//"jmp xcsmp_interface \r\n"
					"hlt \r\n"
					:
					:   "i" (X86SMP_LAPIC_ID_MEMORYADDRESS), "m" (_totalcpus), "i" (&_cputable),
                        "i" (sizeof(xmhf_cputable_t)), "i" (&_init_cpustacks), "i" (sizeof(_init_cpustacks[0]))
	);

}*/























//////////////////////////////////////////////////////////////////////////////
//setup slab device allocation
typedef struct {
    __attribute__((aligned(4096))) vtd_slpgtbl_t _vtd_slpgtbl;
    bool initialized;
}__attribute__((packed)) xc_partitiondevicetable_t;

__attribute__((aligned(4096))) static  xc_partitiondevicetable_t _partitiondevtable[MAX_PRIMARY_PARTITIONS];

__attribute__((aligned(4096))) static vtd_ret_entry_t _vtd_ret[VTD_RET_MAXPTRS];
__attribute__((aligned(4096))) static vtd_cet_entry_t _vtd_cet[VTD_RET_MAXPTRS][VTD_CET_MAXPTRS];

static vtd_drhd_handle_t vtd_drhd_maxhandle=0;
static u32 vtd_pagewalk_level = VTD_PAGEWALK_NONE;
static bool vtd_initialized = false;

static u64 _platform_x86pc_vtd_setup_retcet(void){
    u32 i, j;

    for(i=0; i< VTD_RET_MAXPTRS; i++){
        _vtd_ret[i].qwords[0] = _vtd_ret[i].qwords[1] = 0ULL;
        _vtd_ret[i].fields.p = 1;
        _vtd_ret[i].fields.ctp = ((u64)&_vtd_cet[i] >> 12);

        for(j=0; j < VTD_CET_MAXPTRS; j++){
            _vtd_cet[i][j].qwords[0] = _vtd_cet[i][j].qwords[1] = 0ULL;
        }
    }

    return (u64)&_vtd_ret;
}

//initialize vtd hardware and setup vtd_drhd_maxhandle and _vtd_pagewalk_level
//to appropriate values. if everything went well set vtd_initialized to true
static bool _platform_x86pc_vtd_initialize(void){
    u64 vtd_ret_addr;
	vtd_drhd_handle_t drhd_handle;
	u32 vtd_dmar_table_physical_address=0;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i, b, d, f;

    //if we already setup vtd then simply return true
    if(vtd_initialized)
        return true;

    //initialize partition--device table
    for(i=0; i < MAX_PRIMARY_PARTITIONS; i++)
        _partitiondevtable[i].initialized = false;

	//setup basic RET/CET structure; will initially prevent DMA reads and writes
	//for the entire system
    vtd_ret_addr = _platform_x86pc_vtd_setup_retcet();

	//scan for available DRHD units in the platform
	if(!xmhfhw_platform_x86pc_vtd_scanfor_drhd_units(&vtd_drhd_maxhandle, &vtd_dmar_table_physical_address)){
        _XDPRINTF_("%s: unable to scan for DRHD units. bailing out!\n", __FUNCTION__);
		return false;
	}

    _XDPRINTF_("%s: maxhandle = %u, dmar table addr=0x%08x\n", __FUNCTION__,
                (u32)vtd_drhd_maxhandle, (u32)vtd_dmar_table_physical_address);

	//initialize all DRHD units
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
   		VTD_CAP_REG cap;

		_XDPRINTF_("%s: Setting up DRHD unit %u...\n", __FUNCTION__, drhd_handle);

		if(!xmhfhw_platform_x86pc_vtd_drhd_initialize(drhd_handle) ){
            _XDPRINTF_("%s: error setting up DRHD unit %u. bailing out!\n", __FUNCTION__, drhd_handle);
			return false;
		}

        //read and store DRHD supported page-walk length
        cap.value = xmhfhw_platform_x86pc_vtd_drhd_reg_read(drhd_handle, VTD_CAP_REG_OFF);
        if(cap.bits.sagaw & 0x2){
            if(vtd_pagewalk_level == VTD_PAGEWALK_NONE || vtd_pagewalk_level == VTD_PAGEWALK_3LEVEL){
                vtd_pagewalk_level = VTD_PAGEWALK_3LEVEL;
                _XDPRINTF_("%s: DRHD unit %u - 3-level page-walk\n", __FUNCTION__, drhd_handle);
            }else{
                _XDPRINTF_("%s: Halting: mixed hardware supported page-walk lengths\n",
                            __FUNCTION__);
                HALT();
            }
        }

        if(cap.bits.sagaw & 0x4){
            if(vtd_pagewalk_level == VTD_PAGEWALK_NONE || vtd_pagewalk_level == VTD_PAGEWALK_4LEVEL){
                vtd_pagewalk_level = VTD_PAGEWALK_4LEVEL;
                _XDPRINTF_("%s: DRHD unit %u - 4-level page-walk\n", __FUNCTION__, drhd_handle);
            }else{
                _XDPRINTF_("%s: Halting: mixed hardware supported page-walk lengths\n",
                            __FUNCTION__);
                HALT();
            }
        }


		//set DRHD root entry table
		if(!xmhfhw_platform_x86pc_vtd_drhd_set_root_entry_table(drhd_handle, vtd_ret_addr))
			return false;

		//invalidate caches
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;

		//enable VT-d translation
		xmhfhw_platform_x86pc_vtd_drhd_enable_translation(drhd_handle);

		//disable PMRs now (since DMA protection is active via translation)
		xmhfhw_platform_x86pc_vtd_drhd_disable_pmr(drhd_handle);

		_XDPRINTF_("%s: Successfully setup DRHD unit %u\n", __FUNCTION__, drhd_handle);
	}

	//zap VT-d presence in ACPI table...
	//TODO: we need to be a little elegant here. eventually need to setup
	//EPT/NPTs such that the DMAR pages are unmapped for the guest
	xmhfhw_sysmemaccess_writeu32(vtd_dmar_table_physical_address, 0UL);


    _XDPRINTF_("%s: final page-walk level=%u\n", __FUNCTION__, vtd_pagewalk_level);

    vtd_initialized = true;

    return true;
}

static vtd_slpgtbl_handle_t _platform_x86pc_vtd_setup_slpgtbl(u32 partition_index){
    vtd_slpgtbl_handle_t retval = {0, 0};
    u32 i, j, k, paddr=0;

    //sanity check partition index
    if(partition_index >= MAX_PRIMARY_PARTITIONS){
        _XDPRINTF_("%s: Error: partition_index >= MAX_PRIMARY_PARTITIONS. bailing out!\n", __FUNCTION__);
        return retval;
    }

    //setup device memory access for the partition
    _partitiondevtable[partition_index]._vtd_slpgtbl.pml4t[0].fields.r = 1;
    _partitiondevtable[partition_index]._vtd_slpgtbl.pml4t[0].fields.w = 1;
    _partitiondevtable[partition_index]._vtd_slpgtbl.pml4t[0].fields.slpdpt = ((u64)&_partitiondevtable[partition_index]._vtd_slpgtbl.pdpt >> 12);

    for(i=0; i < PAE_PTRS_PER_PDPT; i++){
        _partitiondevtable[partition_index]._vtd_slpgtbl.pdpt[i].fields.r = 1;
        _partitiondevtable[partition_index]._vtd_slpgtbl.pdpt[i].fields.w = 1;
        _partitiondevtable[partition_index]._vtd_slpgtbl.pdpt[i].fields.slpdt = ((u64)&_partitiondevtable[partition_index]._vtd_slpgtbl.pdt[i] >> 12);

        for(j=0; j < PAE_PTRS_PER_PDT; j++){
            _partitiondevtable[partition_index]._vtd_slpgtbl.pdt[i][j].fields.r = 1;
            _partitiondevtable[partition_index]._vtd_slpgtbl.pdt[i][j].fields.w = 1;
            _partitiondevtable[partition_index]._vtd_slpgtbl.pdt[i][j].fields.slpt = ((u64)&_partitiondevtable[partition_index]._vtd_slpgtbl.pt[i][j] >> 12);

            for(k=0; k < PAE_PTRS_PER_PT; k++){
                _partitiondevtable[partition_index]._vtd_slpgtbl.pt[i][j][k].fields.r = 1;
                _partitiondevtable[partition_index]._vtd_slpgtbl.pt[i][j][k].fields.w = 1;
                _partitiondevtable[partition_index]._vtd_slpgtbl.pt[i][j][k].fields.pageaddr = ((u64)paddr >> 12);
                paddr += PAGE_SIZE_4K;
            }
        }
    }

    retval.addr_vtd_pml4t = _partitiondevtable[partition_index]._vtd_slpgtbl.pml4t;
    retval.addr_vtd_pdpt = _partitiondevtable[partition_index]._vtd_slpgtbl.pdpt;

    return retval;
}

static xc_platformdevice_desc_t __xmhfhic_arch_initializeandenumeratedevices(context_desc_t context_desc){
    xc_platformdevice_desc_t result;
    u32 b, d, f;

    result.desc_valid = false;
    result.numdevices = 0;

    //initialize vtd hardware (if it has not been initialized already)
    if(!_platform_x86pc_vtd_initialize())
        return result;

    //enumerate PCI bus to find out all the devices
	//bus numbers range from 0-255, device from 0-31 and function from 0-7
	for(b=0; b < PCI_BUS_MAX; b++){
		for(d=0; d < PCI_DEVICE_MAX; d++){
			for(f=0; f < PCI_FUNCTION_MAX; f++){
				u32 vendor_id, device_id;

				//read device and vendor ids, if no device then both will be 0xFFFF
				xmhf_baseplatform_arch_x86_pci_type1_read(b, d, f, PCI_CONF_HDR_IDX_VENDOR_ID, sizeof(u16), &vendor_id);
				xmhf_baseplatform_arch_x86_pci_type1_read(b, d, f, PCI_CONF_HDR_IDX_DEVICE_ID, sizeof(u16), &device_id);
				if(vendor_id == 0xFFFF && device_id == 0xFFFF)
					break;

                result.arch_desc[result.numdevices].pci_bus=b;
                result.arch_desc[result.numdevices].pci_device=d;
                result.arch_desc[result.numdevices].pci_function=f;
                result.arch_desc[result.numdevices].vendor_id=vendor_id;
                result.arch_desc[result.numdevices].device_id=device_id;

                result.numdevices++;
			}
		}
	}

    result.desc_valid = true;
    return result;
}


static bool __xmhfhic_arch_allocdevices_to_partition(context_desc_t context_desc, xc_platformdevice_desc_t device_descs){
	vtd_drhd_handle_t drhd_handle;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i;

    if(!vtd_initialized)
        return false;


    //initialize partition device page tables (if it has not been initialized already)
    if(!_partitiondevtable[context_desc.partition_desc.partition_index].initialized){
        vtd_slpgtbl_handle = _platform_x86pc_vtd_setup_slpgtbl(context_desc.partition_desc.partition_index);

        if(vtd_slpgtbl_handle.addr_vtd_pml4t == 0 &&
            vtd_slpgtbl_handle.addr_vtd_pdpt == 0){
            _XDPRINTF_("%s: unable to initialize vt-d pagetables for partition %u\n", __FUNCTION__, context_desc.partition_desc.partition_index);
            return false;
        }

        _partitiondevtable[context_desc.partition_desc.partition_index].initialized = true;
    }


    for(i=0; i < device_descs.numdevices; i++){
        u32 b=device_descs.arch_desc[i].pci_bus;
        u32 d=device_descs.arch_desc[i].pci_device;
        u32 f=device_descs.arch_desc[i].pci_function;

        //sanity check b, d, f triad
        if ( !(b < PCI_BUS_MAX &&
               d < PCI_DEVICE_MAX &&
               f < PCI_FUNCTION_MAX) )
            return false;

        //b is our index into ret
        // (d* PCI_FUNCTION_MAX) + f = index into the cet
        if(vtd_pagewalk_level == VTD_PAGEWALK_4LEVEL){
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.slptptr = ((u64)_partitiondevtable[context_desc.partition_desc.partition_index]._vtd_slpgtbl.pml4t >> 12);
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.aw = 2; //4-level
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.did = (context_desc.partition_desc.partition_index + 1); //domain
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.p = 1; //present
        }else if (vtd_pagewalk_level == VTD_PAGEWALK_3LEVEL){
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.slptptr = ((u64)_partitiondevtable[context_desc.partition_desc.partition_index]._vtd_slpgtbl.pdpt >> 12);
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.aw = 1; //3-level
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.did = (context_desc.partition_desc.partition_index + 1); //domain
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.p = 1; //present
        }else{ //unknown page walk length, fail
            return false;
        }
    }


	//invalidate vtd caches
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;
	}

    return true;
}


static bool __xmhfhic_arch_deallocdevices_from_partition(context_desc_t context_desc, xc_platformdevice_desc_t device_descs){
	vtd_drhd_handle_t drhd_handle;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i;

    if(!vtd_initialized)
        return false;

    for(i=0; i < device_descs.numdevices; i++){
        u32 b=device_descs.arch_desc[i].pci_bus;
        u32 d=device_descs.arch_desc[i].pci_device;
        u32 f=device_descs.arch_desc[i].pci_function;

        //sanity check b, d, f triad
        if ( !(b < PCI_BUS_MAX &&
               d < PCI_DEVICE_MAX &&
               f < PCI_FUNCTION_MAX) )
            return false;

        //b is our index into ret
        // (d* PCI_FUNCTION_MAX) + f = index into the cet
        _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].qwords[0] = 0;
        _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].qwords[1] = 0;
    }

	//invalidate vtd caches
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;
	}

    return true;
}


static bool __xmhfhic_dev_arch_initialize(u32 partition_index){
    u32 i;
    xc_platformdevice_desc_t ddescs;
    context_desc_t ctx;

    ctx.cpu_desc.cpu_index = 0;
    ctx.cpu_desc.isbsp = true;
    ctx.partition_desc.partition_index = partition_index;

    ddescs = __xmhfhic_arch_initializeandenumeratedevices(ctx);

    if(!ddescs.desc_valid){
        _XDPRINTF_("%s: Error: could not obtain platform device descriptors\n",
                    __FUNCTION__);
        return false;
    }

    for(i=0; i < ddescs.numdevices; i++){
        _XDPRINTF_("  %02x:%02x.%1x -> vendor_id=%04x, device_id=%04x\n", ddescs.arch_desc[i].pci_bus,
          ddescs.arch_desc[i].pci_device, ddescs.arch_desc[i].pci_function,
          ddescs.arch_desc[i].vendor_id, ddescs.arch_desc[i].device_id);
    }

    if(!__xmhfhic_arch_allocdevices_to_partition(ctx, ddescs)){
            _XDPRINTF_("%s: Halting.unable to allocate devices to partition %u\n",
                        __FUNCTION__, partition_index);
            HALT();
    }

    return true;
}


static void __xmhfhic_x86vmxx86pc_postdrt(void){
	txt_heap_t *txt_heap;
	os_mle_data_t *os_mle_data;

	txt_heap = get_txt_heap();
	_XDPRINTF_("SL: txt_heap = 0x%08x\n", (u32)txt_heap);
	os_mle_data = get_os_mle_data_start((txt_heap_t*)((u32)txt_heap));
	_XDPRINTF_("SL: os_mle_data = 0x%08x\n", (u32)os_mle_data);

	// restore pre-SENTER MTRRs that were overwritten for SINIT launch
	if(!validate_mtrrs(&(os_mle_data->saved_mtrr_state))) {
		_XDPRINTF_("SECURITY FAILURE: validate_mtrrs() failed.\n");
		HALT();
	}
	_XDPRINTF_("SL: Validated MTRRs\n");

	xmhfhw_cpu_x86_restore_mtrrs(&(os_mle_data->saved_mtrr_state));
    _XDPRINTF_("SL: Restored MTRRs\n");
}




void xmhfhic_arch_setup_slab_device_allocation(void){

#if defined (__DRT__)
    //post DRT cleanup first
    __xmhfhic_x86vmxx86pc_postdrt();
#endif	//__DRT__

	//initialize platform bus
	xmhfhw_platform_bus_init();

	//check ACPI subsystem
	{
		ACPI_RSDP rsdp;
		if(!xmhfhw_platform_x86pc_acpi_getRSDP(&rsdp)){
			_XDPRINTF_("%s: ACPI RSDP not found, Halting!\n", __FUNCTION__);
			HALT();
		}
	}

    //initialize devices and allocate everything to the rich guest for now
    __xmhfhic_dev_arch_initialize(0);


}





















//////////////////////////////////////////////////////////////////////////////
// setup hypervisor slab page tables


__attribute__((aligned(4096))) static struct {
    u64 pml4t[PAE_MAXPTRS_PER_PML4T] __attribute__(( aligned(4096) ));
	u64 pdpt[PAE_MAXPTRS_PER_PDPT] __attribute__(( aligned(4096) ));
	u64 pdt[PAE_PTRS_PER_PDPT][PAE_PTRS_PER_PDT] __attribute__(( aligned(4096) ));
} _slab_pagetables[XMHF_HIC_HYP_SLABS_COUNT];


#define	_SLAB_SPATYPE_OTHER_SLAB_MASK			(0xF0)

#define	_SLAB_SPATYPE_OTHER_SLAB_CODE			(0xF0)
#define	_SLAB_SPATYPE_OTHER_SLAB_RODATA			(0xF1)
#define _SLAB_SPATYPE_OTHER_SLAB_RWDATA			(0xF2)
#define _SLAB_SPATYPE_OTHER_SLAB_STACK			(0xF3)

#define	_SLAB_SPATYPE_SLAB_CODE					(0x0)
#define	_SLAB_SPATYPE_SLAB_RODATA				(0x1)
#define _SLAB_SPATYPE_SLAB_RWDATA				(0x2)
#define _SLAB_SPATYPE_SLAB_STACK				(0x3)

#define _SLAB_SPATYPE_SLAB_TRAMPOLINE			(0x4)

#define _SLAB_SPATYPE_NOTASLAB					(0xFF00)

static u32 __xmhfhic_hyp_slab_getspatype(u32 slab_index, u32 spa){
/*	u32 i;

	//slab memory regions
	for(i=0; i < XMHF_SLAB_NUMBEROFSLABS; i++){
		u32 mask = (i == slab_index) ? 0 : _SLAB_SPATYPE_OTHER_SLAB_MASK;

		if(spa >= _slab_table[i].slab_code.start  && spa < _slab_table[i].slab_code.end)
			return _SLAB_SPATYPE_SLAB_CODE | mask;
		if (spa >= _slab_table[i].slab_rodata.start  && spa < _slab_table[i].slab_rodata.end)
			return _SLAB_SPATYPE_SLAB_RODATA | mask;
		if (spa >= _slab_table[i].slab_rwdata.start  && spa < _slab_table[i].slab_rwdata.end)
			return _SLAB_SPATYPE_SLAB_RWDATA | mask;
		if (spa >= _slab_table[i].slab_stack.start  && spa < _slab_table[i].slab_stack.end)
			return _SLAB_SPATYPE_SLAB_STACK | mask;
	}

	//slab shared data region
	//TODO: add per shared data variable access policy rather than entire section
	if(spa >= (u32)_slab_shareddata_memregion_start && spa < (u32)_slab_shareddata_memregion_end){
			if (slab_index == XMHF_SLAB_XCPRIMEON_INDEX || slab_index == XMHF_SLAB_XCSMP_INDEX || slab_index == XMHF_SLAB_XCEXHUB_INDEX)
				return _SLAB_SPATYPE_SLAB_RWDATA; //map read-write in initbs (GDT,TSS setup) and xcexhub (IDT setup)
			else
				return _SLAB_SPATYPE_SLAB_RODATA; //map read-only in all other slabs
	}

	//slab trampoline region
	if(spa >= (u32)_slab_trampoline_memregion_start && spa < (u32)_slab_trampoline_memregion_end){
			return _SLAB_SPATYPE_SLAB_TRAMPOLINE; //map read-only in all slabs
	}
*/

	return _SLAB_SPATYPE_NOTASLAB;
}

static u64 __xmhfhic_hyp_slab_getptflagsforspa(u32 slab_index, u32 spa){
	u64 flags;
/*	u32 spatype = _xcprimeon_slab_getspatype(slab_index, spa);
	//_XDPRINTF_("\n%s: slab_index=%u, spa=%08x, spatype = %x\n", __FUNCTION__, slab_index, spa, spatype);

	switch(spatype){
		case _SLAB_SPATYPE_OTHER_SLAB_CODE:
		case _SLAB_SPATYPE_OTHER_SLAB_RODATA:
		case _SLAB_SPATYPE_OTHER_SLAB_RWDATA:
			flags = 0;	//not-present
			break;
		case _SLAB_SPATYPE_OTHER_SLAB_STACK:
			//flags = (u64)(_PAGE_PRESENT | _PAGE_PSE | _PAGE_NX); //present | read-only | no execute | pse
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE | _PAGE_NX); //present | read-write | no execute | pse
			break;

		case _SLAB_SPATYPE_SLAB_CODE:
			flags = (u64)(_PAGE_PRESENT | _PAGE_PSE); // present | read-only | pse
			break;
		case _SLAB_SPATYPE_SLAB_RODATA:
			flags = (u64)(_PAGE_PRESENT | _PAGE_PSE | _PAGE_NX); //present | read-only | no-execute | pse
			break;
		case _SLAB_SPATYPE_SLAB_RWDATA:
		case _SLAB_SPATYPE_SLAB_STACK:
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_NX | _PAGE_PSE); //present | read-write | no-execute | pse
			break;

		case _SLAB_SPATYPE_SLAB_TRAMPOLINE:
			flags = (u64)(_PAGE_PRESENT | _PAGE_PSE); //present | read-only | pse;
			break;

		default:
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE | _PAGE_USER);
			if(spa == 0xfee00000 || spa == 0xfec00000) {
				//map some MMIO regions with Page Cache disabled
				//0xfed00000 contains Intel TXT config regs & TPM MMIO
				//0xfee00000 contains LAPIC base
				flags |= (u64)(_PAGE_PCD);
			}
			break;
	}*/

	flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE | _PAGE_USER);
			if(spa == 0xfee00000 || spa == 0xfec00000) {
				//map some MMIO regions with Page Cache disabled
				//0xfed00000 contains Intel TXT config regs & TPM MMIO
				//0xfee00000 contains LAPIC base
				flags |= (u64)(_PAGE_PCD);
			}

	return flags;
}

//
// initialize slab page tables for a given slab index, returns the macm base
static u32 __xmhfhic_hyp_slab_populate_pagetables(u32 slab_index){
		u32 i, j;
		u64 default_flags = (u64)(_PAGE_PRESENT) | (u64)(_PAGE_USER) | (u64)(_PAGE_RW);

        for(i=0; i < PAE_PTRS_PER_PML4T; i++)
            _slab_pagetables[slab_index].pml4t[i] = pae_make_pml4e(hva2spa(&_slab_pagetables[slab_index].pdpt), default_flags);

		for(i=0; i < PAE_PTRS_PER_PDPT; i++)
			_slab_pagetables[slab_index].pdpt[i] = pae_make_pdpe(hva2spa(_slab_pagetables[slab_index].pdt[i]), default_flags);

		//init pdts with unity mappings
		for(i=0; i < PAE_PTRS_PER_PDPT; i++){
			for(j=0; j < PAE_PTRS_PER_PDT; j++){
				u32 hva = ((i * PAE_PTRS_PER_PDT) + j) * PAGE_SIZE_2M;
				u64 spa = hva2spa((void*)hva);
				u64 flags = __xmhfhic_hyp_slab_getptflagsforspa(slab_index, (u32)spa);
				_slab_pagetables[slab_index].pdt[i][j] = pae_make_pde_big(spa, flags);
				//debug
				//if(slab_index == XMHF_SLAB_TESTSLAB1_INDEX && (spa >=0x10000000 && spa < 0x20000000) )
				//	_XDPRINTF_("  hva/spa=%08x, flags=%08x\n", (u32)spa, (u32)flags);
			}
		}

		return (u32)_slab_pagetables[slab_index].pml4t | (u32)(slab_index+1);
}


// initialization function for the core API interface
void __xmhfhic_arch_initialize_slab_tables(void){
	u32 pgtblbase;

	_XDPRINTF_("%s: starting...\n", __FUNCTION__);

	//[debug]
	{
		u32 i;
		for(i=0; i < XMHF_HIC_HYP_SLABS_COUNT; i++){
				_XDPRINTF_("slab %u: pdpt=%08x, pdt[0]=%08x, pdt[1]=%08x\n", i, (u32)_slab_pagetables[i].pdpt, (u32)_slab_pagetables[i].pdt[0], (u32)_slab_pagetables[i].pdt[1]);
				_XDPRINTF_("                    pdt[2]=%08x, pdt[3]=%08x\n", (u32)_slab_pagetables[i].pdt[2], (u32)_slab_pagetables[i].pdt[3]);
		}

	}

	//setup slab page tables and macm id's
	{
		u32 i;
		for(i=0; i < XMHF_HIC_HYP_SLABS_COUNT; i++)
			_slab_table[i].slab_macmid = __xmhfhic_hyp_slab_populate_pagetables(i);

	}

	_XDPRINTF_("%s: setup slab page tables and macm id's\n", __FUNCTION__);


}



void xmhfhic_arch_setup_hypervisor_slab_page_tables(void){

	//print out hypervisor slab table
	{
			u32 i;

			for(i=0; i < XMHF_HIC_HYP_SLABS_COUNT; i++){
				_XDPRINTF_("slab %u: dumping slab header\n", i);
				_XDPRINTF_("	slab_index=%u\n", _slab_table[i].slab_index);
				_XDPRINTF_("	slab_macmid=%08x\n", _slab_table[i].slab_macmid);
				_XDPRINTF_("	slab_privilegemask=%08x\n", _slab_table[i].slab_privilegemask);
				_XDPRINTF_("	slab_tos=%08x\n", _slab_table[i].slab_tos);
				_XDPRINTF_("  slab_rodata(%08x-%08x)\n", _slab_table[i].slab_rodata.start, _slab_table[i].slab_rodata.end);
				_XDPRINTF_("  slab_rwdata(%08x-%08x)\n", _slab_table[i].slab_rwdata.start, _slab_table[i].slab_rwdata.end);
				_XDPRINTF_("  slab_code(%08x-%08x)\n", _slab_table[i].slab_code.start, _slab_table[i].slab_code.end);
				_XDPRINTF_("  slab_stack(%08x-%08x)\n", _slab_table[i].slab_stack.start, _slab_table[i].slab_stack.end);
				//_XDPRINTF_("\n  slab_trampoline(%08x-%08x)", _slab_table[i].slab_trampoline.start, _slab_table[i].slab_trampoline.end);
				_XDPRINTF_("  slab_entrycr3=%08x\n", _slab_table[i].entry_cr3);
				_XDPRINTF_("  slab_entrycr3_new=%08x\n", _slab_table[i].entry_cr3_new);
		}
	}


    __xmhfhic_arch_initialize_slab_tables();

}





















///////////////////////////////////////////////////////////////////////////
// setup guest slab page tables
__attribute__((aligned(4096))) static xc_partition_hptdata_x86vmx_t _hpt_data[XMHF_HIC_GUEST_SLABS_COUNT];
static struct _memorytype _vmx_ept_memorytypes[MAX_MEMORYTYPE_ENTRIES]; //EPT memory types array

static void __xmhfhic_vmx_gathermemorytypes(void);
static u32 __xmhfhic_vmx_getmemorytypeforphysicalpage(u64 pagebaseaddr);
static void __xmhfhic_vmx_setupEPT(u64 guestslab_id);


static void __xmhfhic_guestpgtbl_setentry(u64 guestslab_id,  u64 gpa, u64 entry){
    u64 *hpt = (u64 *)_hpt_data[guestslab_id].vmx_ept_p_tables;
		u32 hpt_index = (u32)gpa / PAGE_SIZE_4K;

		hpt[hpt_index] = entry;

	return;
}

static void __xmhfhic_guestpgtbl_establishshape(u64 guestslab_id){
	u64 *pml4_table, *pdp_table, *pd_table;
	u32 i, j, paddr=0;

	pml4_table = (u64 *)_hpt_data[guestslab_id].vmx_ept_pml4_table;
	pml4_table[0] = (u64) (hva2spa((void*)_hpt_data[guestslab_id].vmx_ept_pdp_table) | 0x7);

	pdp_table = (u64 *)_hpt_data[guestslab_id].vmx_ept_pdp_table;

	for(i=0; i < PAE_PTRS_PER_PDPT; i++){
		pdp_table[i] = (u64) ( hva2spa((void*)_hpt_data[guestslab_id].vmx_ept_pd_tables + (PAGE_SIZE_4K * i)) | 0x7 );
		pd_table = (u64 *)  ((u32)_hpt_data[guestslab_id].vmx_ept_pd_tables + (PAGE_SIZE_4K * i)) ;

		for(j=0; j < PAE_PTRS_PER_PDT; j++){
			pd_table[j] = (u64) ( hva2spa((void*)_hpt_data[guestslab_id].vmx_ept_p_tables + (PAGE_SIZE_4K * ((i*PAE_PTRS_PER_PDT)+j))) | 0x7 );
		}
	}
}



//---gather memory types for system physical memory------------------------------
static void __xmhfhic_vmx_gathermemorytypes(void){
 	u32 eax, ebx, ecx, edx;
	u32 index=0;
	u32 num_vmtrrs=0;	//number of variable length MTRRs supported by the CPU

	//0. sanity check
  	//check MTRR support
  	eax=0x00000001;
  	ecx=0x00000000;
	#ifndef __XMHF_VERIFICATION__
  	asm volatile ("cpuid\r\n"
            :"=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
            :"a"(eax), "c" (ecx));
  	#endif

  	if( !(edx & (u32)(1 << 12)) ){
  		_XDPRINTF_("\n%s: CPU does not support MTRRs!", __FUNCTION__);
  		HALT();
  	}

  	//check MTRR caps
  	rdmsr(IA32_MTRRCAP, &eax, &edx);
	num_vmtrrs = (u8)eax;
  	_XDPRINTF_("\nIA32_MTRRCAP: VCNT=%u, FIX=%u, WC=%u, SMRR=%u",
  		num_vmtrrs, ((eax & (1 << 8)) >> 8),  ((eax & (1 << 10)) >> 10),
  			((eax & (1 << 11)) >> 11));
	//sanity check that fixed MTRRs are supported
  	HALT_ON_ERRORCOND( ((eax & (1 << 8)) >> 8) );
  	//ensure number of variable MTRRs are within the maximum supported
  	HALT_ON_ERRORCOND( (num_vmtrrs <= MAX_VARIABLE_MEMORYTYPE_ENTRIES) );


	#ifndef __XMHF_VERIFICATION__
	//1. clear memorytypes array
	memset((void *)&_vmx_ept_memorytypes, 0, sizeof(struct _memorytype) * MAX_MEMORYTYPE_ENTRIES);
	#endif

	//2. grab memory types using FIXED MTRRs
    //0x00000000-0x0007FFFF
    rdmsr(IA32_MTRR_FIX64K_00000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x00000000; _vmx_ept_memorytypes[index].endaddr = 0x0000FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00010000; _vmx_ept_memorytypes[index].endaddr = 0x0001FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00020000; _vmx_ept_memorytypes[index].endaddr = 0x0002FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x00030000; _vmx_ept_memorytypes[index].endaddr = 0x0003FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x00040000; _vmx_ept_memorytypes[index].endaddr = 0x0004FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00050000; _vmx_ept_memorytypes[index].endaddr = 0x0005FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00060000; _vmx_ept_memorytypes[index].endaddr = 0x0006FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x00070000; _vmx_ept_memorytypes[index].endaddr = 0x0007FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x00080000-0x0009FFFF
  	rdmsr(IA32_MTRR_FIX16K_80000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x00080000; _vmx_ept_memorytypes[index].endaddr = 0x00083FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00084000; _vmx_ept_memorytypes[index].endaddr = 0x00087FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00088000; _vmx_ept_memorytypes[index].endaddr = 0x0008BFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x0008C000; _vmx_ept_memorytypes[index].endaddr = 0x0008FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x00090000; _vmx_ept_memorytypes[index].endaddr = 0x00093FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00094000; _vmx_ept_memorytypes[index].endaddr = 0x00097FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00098000; _vmx_ept_memorytypes[index].endaddr = 0x0009BFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x0009C000; _vmx_ept_memorytypes[index].endaddr = 0x0009FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000A0000-0x000BFFFF
	  rdmsr(IA32_MTRR_FIX16K_A0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000A0000; _vmx_ept_memorytypes[index].endaddr = 0x000A3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000A4000; _vmx_ept_memorytypes[index].endaddr = 0x000A7FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000A8000; _vmx_ept_memorytypes[index].endaddr = 0x000ABFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000AC000; _vmx_ept_memorytypes[index].endaddr = 0x000AFFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000B0000; _vmx_ept_memorytypes[index].endaddr = 0x000B3FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000B4000; _vmx_ept_memorytypes[index].endaddr = 0x000B7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000B8000; _vmx_ept_memorytypes[index].endaddr = 0x000BBFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000BC000; _vmx_ept_memorytypes[index].endaddr = 0x000BFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000C0000-0x000C7FFF
    rdmsr(IA32_MTRR_FIX4K_C0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000C0000; _vmx_ept_memorytypes[index].endaddr = 0x000C0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C1000; _vmx_ept_memorytypes[index].endaddr = 0x000C1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000C2000; _vmx_ept_memorytypes[index].endaddr = 0x000C2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000C3000; _vmx_ept_memorytypes[index].endaddr = 0x000C3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000C4000; _vmx_ept_memorytypes[index].endaddr = 0x000C4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C5000; _vmx_ept_memorytypes[index].endaddr = 0x000C5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000C6000; _vmx_ept_memorytypes[index].endaddr = 0x000C6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000C7000; _vmx_ept_memorytypes[index].endaddr = 0x000C7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000C8000-0x000C8FFF
	  rdmsr(IA32_MTRR_FIX4K_C8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000C8000; _vmx_ept_memorytypes[index].endaddr = 0x000C8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C9000; _vmx_ept_memorytypes[index].endaddr = 0x000C9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000CA000; _vmx_ept_memorytypes[index].endaddr = 0x000CAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000CB000; _vmx_ept_memorytypes[index].endaddr = 0x000CBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000CC000; _vmx_ept_memorytypes[index].endaddr = 0x000CCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000CD000; _vmx_ept_memorytypes[index].endaddr = 0x000CDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000CE000; _vmx_ept_memorytypes[index].endaddr = 0x000CEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000CF000; _vmx_ept_memorytypes[index].endaddr = 0x000CFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000D0000-0x000D7FFF
    rdmsr(IA32_MTRR_FIX4K_D0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000D0000; _vmx_ept_memorytypes[index].endaddr = 0x000D0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D1000; _vmx_ept_memorytypes[index].endaddr = 0x000D1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000D2000; _vmx_ept_memorytypes[index].endaddr = 0x000D2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000D3000; _vmx_ept_memorytypes[index].endaddr = 0x000D3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000D4000; _vmx_ept_memorytypes[index].endaddr = 0x000D4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D5000; _vmx_ept_memorytypes[index].endaddr = 0x000D5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000D6000; _vmx_ept_memorytypes[index].endaddr = 0x000D6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000D7000; _vmx_ept_memorytypes[index].endaddr = 0x000D7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000D8000-0x000DFFFF
  	rdmsr(IA32_MTRR_FIX4K_D8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000D8000; _vmx_ept_memorytypes[index].endaddr = 0x000D8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D9000; _vmx_ept_memorytypes[index].endaddr = 0x000D9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000DA000; _vmx_ept_memorytypes[index].endaddr = 0x000DAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000DB000; _vmx_ept_memorytypes[index].endaddr = 0x000DBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000DC000; _vmx_ept_memorytypes[index].endaddr = 0x000DCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000DD000; _vmx_ept_memorytypes[index].endaddr = 0x000DDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000DE000; _vmx_ept_memorytypes[index].endaddr = 0x000DEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000DF000; _vmx_ept_memorytypes[index].endaddr = 0x000DFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000E0000-0x000E7FFF
    rdmsr(IA32_MTRR_FIX4K_E0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000E0000; _vmx_ept_memorytypes[index].endaddr = 0x000E0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E1000; _vmx_ept_memorytypes[index].endaddr = 0x000E1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000E2000; _vmx_ept_memorytypes[index].endaddr = 0x000E2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000E3000; _vmx_ept_memorytypes[index].endaddr = 0x000E3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000E4000; _vmx_ept_memorytypes[index].endaddr = 0x000E4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E5000; _vmx_ept_memorytypes[index].endaddr = 0x000E5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000E6000; _vmx_ept_memorytypes[index].endaddr = 0x000E6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000E7000; _vmx_ept_memorytypes[index].endaddr = 0x000E7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000E8000-0x000EFFFF
	  rdmsr(IA32_MTRR_FIX4K_E8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000E8000; _vmx_ept_memorytypes[index].endaddr = 0x000E8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E9000; _vmx_ept_memorytypes[index].endaddr = 0x000E9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000EA000; _vmx_ept_memorytypes[index].endaddr = 0x000EAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000EB000; _vmx_ept_memorytypes[index].endaddr = 0x000EBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000EC000; _vmx_ept_memorytypes[index].endaddr = 0x000ECFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000ED000; _vmx_ept_memorytypes[index].endaddr = 0x000EDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000EE000; _vmx_ept_memorytypes[index].endaddr = 0x000EEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000EF000; _vmx_ept_memorytypes[index].endaddr = 0x000EFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000F0000-0x000F7FFF
  	rdmsr(IA32_MTRR_FIX4K_F0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000F0000; _vmx_ept_memorytypes[index].endaddr = 0x000F0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F1000; _vmx_ept_memorytypes[index].endaddr = 0x000F1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000F2000; _vmx_ept_memorytypes[index].endaddr = 0x000F2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000F3000; _vmx_ept_memorytypes[index].endaddr = 0x000F3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000F4000; _vmx_ept_memorytypes[index].endaddr = 0x000F4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F5000; _vmx_ept_memorytypes[index].endaddr = 0x000F5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000F6000; _vmx_ept_memorytypes[index].endaddr = 0x000F6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000F7000; _vmx_ept_memorytypes[index].endaddr = 0x000F7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000F8000-0x000FFFFF
  	rdmsr(IA32_MTRR_FIX4K_F8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000F8000; _vmx_ept_memorytypes[index].endaddr = 0x000F8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F9000; _vmx_ept_memorytypes[index].endaddr = 0x000F9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000FA000; _vmx_ept_memorytypes[index].endaddr = 0x000FAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000FB000; _vmx_ept_memorytypes[index].endaddr = 0x000FBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000FC000; _vmx_ept_memorytypes[index].endaddr = 0x000FCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000FD000; _vmx_ept_memorytypes[index].endaddr = 0x000FDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000FE000; _vmx_ept_memorytypes[index].endaddr = 0x000FEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000FF000; _vmx_ept_memorytypes[index].endaddr = 0x000FFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);


	//3. grab memory types using variable length MTRRs
	{
		u64 paddrmask = 0x0000000FFFFFFFFFULL; //36-bits physical address, TODO: need to make this dynamic
		u64 vMTRR_base, vMTRR_mask;
		u32 msrval=IA32_MTRR_PHYSBASE0;
		u32 i;

		for(i=0; i < num_vmtrrs; i++){
			rdmsr(msrval, &eax, &edx);
			vMTRR_base = ((u64)edx << 32) | (u64)eax;
			msrval++;
			rdmsr(msrval, &eax, &edx);
			vMTRR_mask = ((u64)edx << 32) | (u64)eax;
			msrval++;
			if( (vMTRR_mask & ((u64)1 << 11)) ){
				_vmx_ept_memorytypes[index].startaddr = (vMTRR_base & (u64)0xFFFFFFFFFFFFF000ULL);
				_vmx_ept_memorytypes[index].endaddr = (vMTRR_base & (u64)0xFFFFFFFFFFFFF000ULL) +
					(u64) (~(vMTRR_mask & (u64)0xFFFFFFFFFFFFF000ULL) &
						paddrmask);
				_vmx_ept_memorytypes[index++].type = ((u32)vMTRR_base & (u32)0x000000FF);
			}else{
				_vmx_ept_memorytypes[index++].invalid = 1;
			}
		}
	}

	_XDPRINTF_("\n%s: gathered MTRR details, number of entries=%u", __FUNCTION__, index);
	HALT_ON_ERRORCOND( index <= (MAX_MEMORYTYPE_ENTRIES+1) );

  //[debug: dump the contents of _vmx_ept_memorytypes]
  //{
  //  int i;
  //  for(i=0; i < MAX_MEMORYTYPE_ENTRIES; i++){
  //    _XDPRINTF_("\nrange  0x%016llx-0x%016llx (type=%u)",
  //      _vmx_ept_memorytypes[i].startaddr, _vmx_ept_memorytypes[i].endaddr, _vmx_ept_memorytypes[i].type);
  //  }
  //}


}

//---get memory type for a given physical page address--------------------------
//
//11.11.4.1 MTRR Precedences
//  0. if MTRRs are not enabled --> MTRR_TYPE_UC
//  if enabled then
     //if physaddr < 1MB use fixed MTRR ranges return type
     //else if within a valid variable range MTRR then
        //if a single match, return type
        //if two or more and one is UC, return UC
        //if two or more and WB and WT, return WT
        //else invalid combination
     //else
       // return default memory type
//
static u32 __xmhfhic_vmx_getmemorytypeforphysicalpage(u64 pagebaseaddr){
 int i;
 u32 prev_type= MTRR_TYPE_RESV;

  //check if page base address under 1M, if so used FIXED MTRRs
  if(pagebaseaddr < (1024*1024)){
    for(i=0; i < MAX_FIXED_MEMORYTYPE_ENTRIES; i++){
      if( pagebaseaddr >= _vmx_ept_memorytypes[i].startaddr && (pagebaseaddr+PAGE_SIZE_4K-1) <= _vmx_ept_memorytypes[i].endaddr )
        return _vmx_ept_memorytypes[i].type;
    }

    _XDPRINTF_("\n%s: endaddr < 1M and unmatched fixed MTRR. Halt!", __FUNCTION__);
    HALT();
  }

  //page base address is above 1M, use VARIABLE MTRRs
  for(i= MAX_FIXED_MEMORYTYPE_ENTRIES; i < MAX_MEMORYTYPE_ENTRIES; i++){
    if( pagebaseaddr >= _vmx_ept_memorytypes[i].startaddr && (pagebaseaddr+PAGE_SIZE_4K-1) <= _vmx_ept_memorytypes[i].endaddr &&
          (!_vmx_ept_memorytypes[i].invalid) ){
       if(_vmx_ept_memorytypes[i].type == MTRR_TYPE_UC){
        prev_type = MTRR_TYPE_UC;
       }else if(_vmx_ept_memorytypes[i].type == MTRR_TYPE_WT && prev_type != MTRR_TYPE_UC){
        prev_type = MTRR_TYPE_WT;
       }else{
        if(prev_type != MTRR_TYPE_UC && prev_type != MTRR_TYPE_WT){
          if(prev_type == MTRR_TYPE_RESV){
            prev_type = _vmx_ept_memorytypes[i].type;
          }else{
            _XDPRINTF_("\nprev_type=%u, _vmx_ept_memorytypes=%u", prev_type, _vmx_ept_memorytypes[i].type);
            HALT_ON_ERRORCOND ( prev_type == _vmx_ept_memorytypes[i].type);
          }
        }
       }
    }
  }

  if(prev_type == MTRR_TYPE_RESV)
    prev_type = MTRR_TYPE_WB; //todo: need to dynamically get the default MTRR (usually WB)

  return prev_type;
}


//---setup EPT for VMX----------------------------------------------------------
static void __xmhfhic_vmx_setupEPT(u64 guestslab_id){
	u64 p_table_value;
	u64 gpa;
    slab_retval_t srval;

	for(gpa=0; gpa < ADDR_4GB; gpa += PAGE_SIZE_4K){
		u32 memorytype = __xmhfhic_vmx_getmemorytypeforphysicalpage((u64)gpa);
		//make XMHF physical pages inaccessible
		if( (gpa >= (xcbootinfo->physmem_base)) &&
			(gpa < (xcbootinfo->physmem_base + xcbootinfo->size)) ){
			p_table_value = (u64) (gpa)  | ((u64)memorytype << 3) | (u64)0x0 ;	//not-present
		}else{
			if(memorytype == 0)
				p_table_value = (u64) (gpa)  | ((u64)memorytype << 3) |  (u64)0x7 ;	//present, UC
			else
				p_table_value = (u64) (gpa)  | ((u64)6 << 3) | (u64)0x7 ;	//present, WB, track host MTRR
		}

        __xmhfhic_guestpgtbl_setentry(guestslab_id, gpa, p_table_value);

	}
}


void xmhfhic_arch_setup_guest_slab_page_tables(void){

    __xmhfhic_vmx_gathermemorytypes();

    __xmhfhic_guestpgtbl_establishshape(0);

	__xmhfhic_vmx_setupEPT(0);

}




















//////////////////////////////////////////////////////////////////////////////
// switch to smp

static bool __xmhfhic_ap_entry(void) __attribute__((naked));
static void __xmhfhic_smp_cpu_x86_smpinitialize_commonstart(void);
static u64 _xcsmp_ap_entry_lock = 1;
static mtrr_state_t _mtrrs;
static u64 _ap_cr3=0;

__attribute__(( aligned(16) )) static u64 _xcsmp_ap_init_gdt_start[]  = {
	0x0000000000000000ULL,	//NULL descriptor
	0x00af9b000000ffffULL,	//CPL-0 64-bit code descriptor (CS64)
	0x00af93000000ffffULL,	//CPL-0 64-bit data descriptor (DS/SS/ES/FS/GS)
};

__attribute__(( aligned(16) )) static arch_x86_gdtdesc_t _xcsmp_ap_init_gdt  = {
	.size=sizeof(_xcsmp_ap_init_gdt_start)-1,
	.base=&_xcsmp_ap_init_gdt_start,
};

__attribute__((naked)) static void _ap_bootstrap_code(void) {

    asm volatile (
           " .code32 \r\n"
           " movw %0, %%ax \r\n"
           " movw %%ax, %%ds \r\n"

           " movl %1, %%ebx \r\n"
           " movl (%%ebx), %%ebx \r\n"

           " jmpl *%%ebx \r\n"
           " hlt \r\n"
           " .balign 4096 \r\n"
           ".code64"
            :
            : "i" (__DS_CPL0),
              "i" ((X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_entrypoint))
            :

        );
}


static void __xmhfhic_smp_cpu_x86_savecpumtrrstate(void){
	xmhfhw_cpu_x86_save_mtrrs(&_mtrrs);
}

static void __xmhfhic_smp_cpu_x86_restorecpumtrrstate(void){
	xmhfhw_cpu_x86_restore_mtrrs(&_mtrrs);
}


//wake up APs using the LAPIC by sending the INIT-SIPI-SIPI IPI sequence
static void __xmhfhic_smp_cpu_x86_wakeupAPs(void){
	u32 eax, edx;
	volatile u32 *icr;

	//read LAPIC base address from MSR
	rdmsr(MSR_APIC_BASE, &eax, &edx);
	HALT_ON_ERRORCOND( edx == 0 ); //APIC is below 4G

	//construct the command register address (offset 0x300)
	icr = (u32 *) (((u32)eax & 0xFFFFF000UL) + 0x300);

	//our AP boot-strap code is at physical memory location 0x10000.
	//so use 0x10 as the vector (0x10000/0x1000 = 0x10)

	//send INIT
	*icr = 0x000c4500UL;

	xmhf_baseplatform_arch_x86_udelay(10000);

	//wait for command completion
	{
		u32 val;
		do{
		  val = *icr;
		}while( (val & 0x1000) );
	}

	//send SIPI (twice as per the MP protocol)
	{
		int i;
		for(i=0; i < 2; i++){
			*icr = 0x000c4610UL;
			xmhf_baseplatform_arch_x86_udelay(200);
			//wait for command completion
			{
			  u32 val;
			  do{
				val = *icr;
			  }while( (val & 0x1000) );
			}
		}
	}

}



//wake up application processors (cores) in the system
static void __xmhfhic_smp_container_vmx_wakeupAPs(void){
    static x86smp_apbootstrapdata_t apdata;

    apdata.ap_cr3 = read_cr3();
    apdata.ap_cr4 = read_cr4();
    apdata.ap_entrypoint = (u32)&__xmhfhic_ap_entry;
    apdata.ap_gdtdesc_limit = sizeof(apdata.ap_gdt) - 1;
    apdata.ap_gdtdesc_base = (X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_gdt);
    apdata.ap_cs_selector = __CS_CPL0;
    apdata.ap_eip = (X86SMP_APBOOTSTRAP_CODESEG << 4);
    apdata.ap_gdt[0] = 0x0000000000000000ULL;
    apdata.ap_gdt[1] = 0x00cf9a000000ffffULL;
    apdata.ap_gdt[2] = 0x00cf92000000ffffULL;

    _XDPRINTF_("%s: sizeof(apdata)=%u bytes\n", __FUNCTION__, sizeof(apdata));
    _XDPRINTF_("  apdata.ap_gdtdesc_limit at %08x\n", &apdata.ap_gdtdesc_limit);
    _XDPRINTF_("  apdata.ap_gdt at %08x\n", &apdata.ap_gdt);

    memcpy((void *)(X86SMP_APBOOTSTRAP_DATASEG << 4), (void *)&apdata, sizeof(apdata));

    memcpy((void *)(X86SMP_APBOOTSTRAP_CODESEG << 4), (void *)&_ap_bootstrap_code, PAGE_SIZE_4K);

#if defined (__DRT__)
    {
        txt_heap_t *txt_heap;
        os_mle_data_t *os_mle_data;
        mle_join_t *mle_join;
        sinit_mle_data_t *sinit_mle_data;
        os_sinit_data_t *os_sinit_data;

        txt_heap = get_txt_heap();
        os_mle_data = get_os_mle_data_start(txt_heap);
        sinit_mle_data = get_sinit_mle_data_start(txt_heap);
        os_sinit_data = get_os_sinit_data_start(txt_heap);

        // enable SMIs on BSP before waking APs (which will enable them on APs)
        // because some SMM may take immediate SMI and hang if AP gets in first
        //_XDPRINTF_("Enabling SMIs on BSP\n");
        //__getsec_smctrl();

        mle_join = (mle_join_t *)((u32)(X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_gdtdesc_limit));

        _XDPRINTF_("\nBSP: mle_join.gdt_limit = %x", mle_join->gdt_limit);
        _XDPRINTF_("\nBSP: mle_join.gdt_base = %x", mle_join->gdt_base);
        _XDPRINTF_("\nBSP: mle_join.seg_sel = %x", mle_join->seg_sel);
        _XDPRINTF_("\nBSP: mle_join.entry_point = %x", mle_join->entry_point);

        write_priv_config_reg(TXTCR_MLE_JOIN, (uint64_t)(unsigned long)mle_join);

        if (os_sinit_data->capabilities.rlp_wake_monitor) {
            _XDPRINTF_("\nBSP: joining RLPs to MLE with MONITOR wakeup");
            _XDPRINTF_("\nBSP: rlp_wakeup_addr = 0x%x", sinit_mle_data->rlp_wakeup_addr);
            *((uint32_t *)(unsigned long)(sinit_mle_data->rlp_wakeup_addr)) = 0x01;
        }else {
            _XDPRINTF_("\nBSP: joining RLPs to MLE with GETSEC[WAKEUP]");
            __getsec_wakeup();
            _XDPRINTF_("\nBSP: GETSEC[WAKEUP] completed");
        }
    }

#else //!__DRT__

    _XDPRINTF_("\nBSP: Using APIC to awaken APs...");
    __xmhfhic_smp_cpu_x86_wakeupAPs();
    _XDPRINTF_("\nBSP: APs should be awake.");

#endif


}

//initialize SMP
static bool __xmhfhic_smp_arch_smpinitialize(void){
	u32 i;

    //save cpu MTRR state which we will later replicate on all APs
	__xmhfhic_smp_cpu_x86_savecpumtrrstate();

    //save page table base which we will later replicate on all APs
    _ap_cr3 = read_cr3();

	//wake up APS
	if(xcbootinfo->cpuinfo_numentries > 1){
	  __xmhfhic_smp_container_vmx_wakeupAPs();
	}

	//fall through to common code
	_XDPRINTF_("%s: Relinquishing BSP thread and moving to common...\n", __FUNCTION__);
	__xmhfhic_smp_cpu_x86_smpinitialize_commonstart();

	_XDPRINTF_("%s:%u: Must never get here. Halting\n", __FUNCTION__, __LINE__);
	HALT();

}

//return 1 if the calling CPU is the BSP
static bool __xmhfhic_smp_cpu_x86_isbsp(void){
  u32 eax, edx;
  //read LAPIC base address from MSR
  rdmsr(MSR_APIC_BASE, &eax, &edx);
  HALT_ON_ERRORCOND( edx == 0 ); //APIC is below 4G

  if(eax & 0x100)
    return true;
  else
    return false;
}


//common function which is entered by all CPUs upon SMP initialization
//note: this is specific to the x86 architecture backend
void __xmhfhic_smp_cpu_x86_smpinitialize_commonstart(void){
	u64 cpuid = __xmhfhic_x86vmx_cpuidtable[xmhf_baseplatform_arch_x86_getcpulapicid()];

    xmhfhic_smp_entry(cpuid);
}



static bool __xmhfhic_ap_entry(void) __attribute__((naked)){

    asm volatile(
                    ".code32 \r\n"
					"_xcsmp_ap_start: \r\n"

					"movw %%ds, %%ax \r\n"
					"movw %%ax, %%es \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"

    				"movl %%cr4, %%eax \r\n"
   					"orl $0x00000030, %%eax \r\n"
   					"movl %%eax, %%cr4 \r\n"

                    "movl %0, %%ebx \r\n"
                    "movl (%%ebx), %%ebx \r\n"
                    "movl %%ebx, %%cr3 \r\n"

                    "movl $0xc0000080, %%ecx \r\n"
                    "rdmsr \r\n"
                    "orl $0x00000100, %%eax \r\n"
                    "orl $0x00000800, %%eax \r\n"
                    "wrmsr \r\n"

                    "movl %%cr0, %%eax \r\n"
                    "orl $0x80000015, %%eax \r\n"
                    "movl %%eax, %%cr0 \r\n"

                    "movl %1, %%esi \r\n"
                    "lgdt (%%esi) \r\n"

                    "ljmp $8, $_xcsmp_ap_start64 \r\n"

                    ".code64 \r\n"
                    "_xcsmp_ap_start64: \r\n"

					"movw $0x10, %%ax \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"
					"movw %%ax, %%ds \r\n"
					"movw %%ax, %%es \r\n"

                    "movl %2, %%ecx \r\n"
                    "rdmsr \r\n"
                    "andl $0x00000FFF, %%eax \r\n"
                    "orl %3, %%eax \r\n"
                    "wrmsr \r\n"

					:
					:   "i" (&_ap_cr3), "i" (&_xcsmp_ap_init_gdt), "i" (MSR_APIC_BASE), "i" (X86SMP_LAPIC_MEMORYADDRESS)
	);


/*    asm volatile(
                 	"movl %0, %%eax\r\n"
					"movl (%%eax), %%eax\r\n"
					"shr $24, %%eax\r\n"
					"movl %2, %%ebx\r\n"
					"movl %1, %%ecx \r\n"
					"1: cmpl 0x0(%%ebx), %%eax\r\n"
					"jz 2f\r\n"
					"addl %3, %%ebx\r\n"
					"loop 1b \r\n"
					"hlt\r\n"								// we should never get here, if so just halt
					"2: movl 0x4(%%ebx), %%eax\r\n"			// eax = g_xc_cputable[ecx].cpu_index
					"movl %5, %%ecx \r\n"					// ecx = sizeof(_cpustack[0])
					"mull %%ecx \r\n"						// eax = sizeof(_cpustack[0]) * eax
					"addl %%ecx, %%eax \r\n"				// eax = (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"addl %4, %%eax \r\n"				    // eax = &_cpustack + (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"movl %%eax, %%esp \r\n"				// esp = top of stack for the cpu

                    "jmp __xmhfhic_smp_cpu_x86_smpinitialize_commonstart \r\n"

					:
					:   "i" (X86SMP_LAPIC_ID_MEMORYADDRESS), "m" (_totalcpus), "i" (&_cputable),
                        "i" (sizeof(xmhf_cputable_t)), "i" (&_init_cpustacks), "i" (sizeof(_init_cpustacks[0]))

	);*/

    asm volatile(
                 	"xorq %%rax, %%rax \r\n"                //RAX=0
                 	"movl %0, %%eax\r\n"                    //
					"movl (%%eax), %%eax\r\n"               //RAX(bits 0-7)=LAPIC ID
					"shr $24, %%eax\r\n"                    //RAX=LAPIC ID
                    "movq %1, %%rbx \r\n"                   //RBX=&__xmhfhic_x86vmx_cpuidtable
                    "movq (%%rbx, %%rax, 8), %%rax \r\n"    //EAX= 0-based cpu index for the CPU

					"movl %2, %%ecx \r\n"					// ecx = sizeof(_cpustack[0])
					"mull %%ecx \r\n"						// eax = sizeof(_cpustack[0]) * eax
					"addl %%ecx, %%eax \r\n"				// eax = (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"addl %3, %%eax \r\n"				    // eax = &_cpustack + (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"movl %%eax, %%esp \r\n"				// esp = top of stack for the cpu

                    "jmp __xmhfhic_smp_cpu_x86_smpinitialize_commonstart \r\n"

					:
					:   "i" (X86SMP_LAPIC_ID_MEMORYADDRESS),
                        "i" (&__xmhfhic_x86vmx_cpuidtable),
                        "i" (sizeof(_init_cpustacks[0])),
                        "i" (&_init_cpustacks)

                    :
	);


}


void xmhfhic_arch_switch_to_smp(void){
	//initialize cpu table and total platform CPUs
	{
	    u32 i, j;
	    for(i=0; i < MAX_X86_APIC_ID; i++)
            __xmhfhic_x86vmx_cpuidtable[i] = 0xFFFFFFFFFFFFFFFFULL;

	    for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            u64 value = i;

            if(xcbootinfo->cpuinfo_buffer[i].isbsp)
                value |= 0x8000000000000000ULL;

            //XXX: TODO sanity check xcbootinfo->cpuinfo_buffer[i].lapic_id < MAX_X86_APIC_ID
            __xmhfhic_x86vmx_cpuidtable[xcbootinfo->cpuinfo_buffer[i].lapic_id] = value;
        }
	}

    __xmhfhic_smp_arch_smpinitialize();

}























/////////////////////////////////////////////////////////////////////
// setup base CPU data structures

//initialize GDT
static void __xmhfhic_x86vmx_initializeGDT(void){
		u32 i;

		//initialize TSS descriptors for all CPUs
		for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            TSSENTRY *t;
            u32 tss_base=(u32)&__xmhfhic_x86vmx_tss[i];

            //TSS descriptor
            t= (TSSENTRY *)&__xmhfhic_x86vmx_gdt_start[(__TRSEL/8)+(i*2)];
            t->attributes1= 0xE9;
            t->limit16_19attributes2= 0x0;
            t->baseAddr0_15= (u16)(tss_base & 0x0000FFFF);
            t->baseAddr16_23= (u8)((tss_base & 0x00FF0000) >> 16);
            t->baseAddr24_31= (u8)((tss_base & 0xFF000000) >> 24);
            t->limit0_15=0x67;
		}

}

//initialize IDT
static void __xmhfhic_x86vmx_initializeIDT(void){
	u32 i;

	for(i=0; i < EMHF_XCPHANDLER_MAXEXCEPTIONS; i++){
		__xmhfhic_x86vmx_idt_start[i].isrLow= (u16)__xmhfhic_exceptionstubs[i];
		__xmhfhic_x86vmx_idt_start[i].isrHigh= (u16) ( (u32)__xmhfhic_exceptionstubs[i] >> 16 );
		__xmhfhic_x86vmx_idt_start[i].isrSelector = __CS_CPL0;
		__xmhfhic_x86vmx_idt_start[i].count=0x0;
		__xmhfhic_x86vmx_idt_start[i].type=0xEE;	//32-bit interrupt gate
                                //present=1, DPL=11b, system=0, type=1110b
        __xmhfhic_x86vmx_idt_start[i].offset3263=0;
        __xmhfhic_x86vmx_idt_start[i].reserved=0;
	}

}


//initialize TSS
static void __xmhfhic_x86vmx_initializeTSS(void){
		u32 i;

		//initialize TSS descriptors for all CPUs
		for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            tss_t *tss= (tss_t *)__xmhfhic_x86vmx_tss[i];
            tss->rsp0 = (u64) ( &__xmhfhic_x86vmx_tss_stack[i] + sizeof(__xmhfhic_x86vmx_tss_stack[0]) );
		}
}


void xmhfhic_arch_setup_base_cpu_data_structures(void){

    //initialize GDT
    __xmhfhic_x86vmx_initializeGDT();

    //initialize IDT
    __xmhfhic_x86vmx_initializeIDT();

    //initialize TSS
    __xmhfhic_x86vmx_initializeTSS();

}
















//////////////////////////////////////////////////////////////////////////////
// setup cpu state for hic



/*


//*
//perform basic (boot) CPU initialization
void xcprimeon_arch_cpu_basicinit(void){
	u32 cpu_vendor;

	//grab CPU vendor
	cpu_vendor = xmhf_baseplatform_arch_getcpuvendor();
	if (cpu_vendor != CPU_VENDOR_INTEL){
		_XDPRINTF_("%s: not an Intel CPU but running VMX backend. Halting!\n", __FUNCTION__);
		HALT();
	}

	//check VMX support
	{
		u32	cpu_features;
		u32 res0,res1,res2;

		cpuid(0x1, &res0, &res1, &cpu_features, &res2);

		if ( ( cpu_features & (1<<5) ) == 0 ){
			_XDPRINTF_("No VMX support. Halting!\n");
			HALT();
		}
	}



*/


//load GDT and initialize segment registers
static void __xmhfhic_x86vmx_loadGDT(u64 cpuid){

	asm volatile(
		"lgdt  %0 \r\n"
		"pushq	%1 \r\n"				// far jump to runtime entry point
		"pushq	$reloadsegs \r\n"
		"lretq \r\n"
		"reloadsegs: \r\n"
		"movw	%2, %%ax \r\n"
		"movw	%%ax, %%ds \r\n"
		"movw	%%ax, %%es \r\n"
		"movw	%%ax, %%fs \r\n"
		"movw	%%ax, %%gs \r\n"
		"movw   %%ax, %%ss \r\n"
		: //no outputs
		: "m" (__xmhfhic_x86vmx_gdt), "i" (__CS_CPL0), "i" (__DS_CPL0)
		: "eax"
	);
}


//load IDT
static void __xmhfhic_x86vmx_loadIDT(u64 cpuid){
	//load IDT
	asm volatile(
		"lidt  %0 \r\n"
		: //no outputs
		: "m" (__xmhfhic_x86vmx_idt)
		: //no clobber
	);
}

//load TR
static void __xmhfhic_x86vmx_loadTR(u64 cpuid){
	  asm volatile(
		"movq %0, %%rax\r\n"
		"ltr %%ax\r\n"				//load TR
	     :
	     : "g"(__TRSEL + ((u32)cpuid * 16) )
	     : "rax"
	  );
}


//set IOPl to CPl-3
static void __xmhfhic_x86vmx_setIOPL3(u64 cpuid){

	asm volatile(
        "pushfq \r\n"
        "popq %%rax \r\n"
		"orq $0x3000, %%rax \r\n"					// clear flags, but set IOPL=3 (CPL-3)
		"pushq %%rax \r\n"
		"popfq \r\n"
		: //no outputs
		: //no inputs
		: "rax", "cc"
	);


}


void xmhf_hic_arch_setup_cpu_state(u64 cpuid){

	//replicate common MTRR state on this CPU
	__xmhfhic_smp_cpu_x86_restorecpumtrrstate();

    //load GDT
    __xmhfhic_x86vmx_loadGDT(cpuid);
    _XDPRINTF_("%s[%u]: GDT loaded\n", __FUNCTION__, (u32)cpuid);

    //load TR
    __xmhfhic_x86vmx_loadTR(cpuid);
    _XDPRINTF_("%s[%u]: TR loaded\n", __FUNCTION__, (u32)cpuid);

    //load IDT
    __xmhfhic_x86vmx_loadIDT(cpuid);
    _XDPRINTF_("%s[%u]: IDT loaded\n", __FUNCTION__, (u32)cpuid);

    //set IOPL3
    __xmhfhic_x86vmx_setIOPL3(cpuid);
    _XDPRINTF_("%s[%u]: set IOPL to CPL-3\n", __FUNCTION__, (u32)cpuid);


    //set LAPIC base address to preferred address
    {
        u64 msrapic = rdmsr64(MSR_APIC_BASE);
        wrmsr64(MSR_APIC_BASE, ((msrapic & 0x0000000000000FFFULL) | X86SMP_LAPIC_MEMORYADDRESS));
    }
    _XDPRINTF_("%s[%u]: set LAPIC base address to %016llx\n", __FUNCTION__, (u32)cpuid, rdmsr64(MSR_APIC_BASE));

	//turn on NX protections
	{
		u32 eax, edx;
		rdmsr(MSR_EFER, &eax, &edx);
		eax |= (1 << EFER_NXE);
		wrmsr(MSR_EFER, eax, edx);
	}
    _XDPRINTF_("%s[%u]: NX protections enabled\n", __FUNCTION__, (u32)cpuid);

	//enable PCIDE support
	{
		write_cr4(read_cr4() | CR4_PCIDE);
	}
    _XDPRINTF_("%s[%u]: PCIDE enabled\n", __FUNCTION__, (u32)cpuid);


	//set OSXSAVE bit in CR4 to enable us to pass-thru XSETBV intercepts
	//when the CPU supports XSAVE feature
	if(xmhf_baseplatform_arch_x86_cpuhasxsavefeature()){
        write_cr4(read_cr4() | CR4_OSXSAVE);
        _XDPRINTF_("%s[%u]: XSETBV passthrough enabled\n", __FUNCTION__, (u32)cpuid);
	}


	//set bit 5 (EM) of CR0 to be VMX compatible in case of Intel cores
	write_cr0(read_cr0() | 0x20);
    _XDPRINTF_("%s[%u]: Set CR0.EM to be VMX compatible\n", __FUNCTION__, (u32)cpuid);


    //turn on CR0.WP bit for supervisor mode write protection
    //write_cr0(read_cr0() | CR0_WP);
    //_XDPRINTF_("%s[%u]: Enabled supervisor mode write protection\n", __FUNCTION__, (u32)cpuid);

}


