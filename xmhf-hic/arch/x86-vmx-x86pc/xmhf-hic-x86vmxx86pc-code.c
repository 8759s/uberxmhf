/*
 * @XMHF_LICENSE_HEADER_START@
 *
 * eXtensible, Modular Hypervisor Framework (XMHF)
 * Copyright (c) 2009-2012 Carnegie Mellon University
 * Copyright (c) 2010-2012 VDG Inc.
 * All Rights Reserved.
 *
 * Developed by: XMHF Team
 *               Carnegie Mellon University / CyLab
 *               VDG Inc.
 *               http://xmhf.org
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in
 * the documentation and/or other materials provided with the
 * distribution.
 *
 * Neither the names of Carnegie Mellon or VDG Inc, nor the names of
 * its contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @XMHF_LICENSE_HEADER_END@
 */

/**
 * XMHF core primeon slab (xcprimeon), x86-vmx-x86pc backend
 * author: amit vasudevan (amitvasudevan@acm.org)
 */

#include <xmhf.h>
#include <xmhf-core.h>
#include <xmhf-debug.h>

#include <xcprimeon.h>

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pdt[(PAE_PTRS_PER_PDPT*PAE_PTRS_PER_PDT)] = {
	0x0000000000000083,0x0000000000200083,0x0000000000400083,0x0000000000600083,
	0x0000000000800083,0x0000000000a00083,0x0000000000c00083,0x0000000000e00083,
	0x0000000001000083,0x0000000001200083,0x0000000001400083,0x0000000001600083,
	0x0000000001800083,0x0000000001a00083,0x0000000001c00083,0x0000000001e00083,
	0x0000000002000083,0x0000000002200083,0x0000000002400083,0x0000000002600083,
	0x0000000002800083,0x0000000002a00083,0x0000000002c00083,0x0000000002e00083,
	0x0000000003000083,0x0000000003200083,0x0000000003400083,0x0000000003600083,
	0x0000000003800083,0x0000000003a00083,0x0000000003c00083,0x0000000003e00083,
	0x0000000004000083,0x0000000004200083,0x0000000004400083,0x0000000004600083,
	0x0000000004800083,0x0000000004a00083,0x0000000004c00083,0x0000000004e00083,
	0x0000000005000083,0x0000000005200083,0x0000000005400083,0x0000000005600083,
	0x0000000005800083,0x0000000005a00083,0x0000000005c00083,0x0000000005e00083,
	0x0000000006000083,0x0000000006200083,0x0000000006400083,0x0000000006600083,
	0x0000000006800083,0x0000000006a00083,0x0000000006c00083,0x0000000006e00083,
	0x0000000007000083,0x0000000007200083,0x0000000007400083,0x0000000007600083,
	0x0000000007800083,0x0000000007a00083,0x0000000007c00083,0x0000000007e00083,
	0x0000000008000083,0x0000000008200083,0x0000000008400083,0x0000000008600083,
	0x0000000008800083,0x0000000008a00083,0x0000000008c00083,0x0000000008e00083,
	0x0000000009000083,0x0000000009200083,0x0000000009400083,0x0000000009600083,
	0x0000000009800083,0x0000000009a00083,0x0000000009c00083,0x0000000009e00083,
	0x000000000a000083,0x000000000a200083,0x000000000a400083,0x000000000a600083,
	0x000000000a800083,0x000000000aa00083,0x000000000ac00083,0x000000000ae00083,
	0x000000000b000083,0x000000000b200083,0x000000000b400083,0x000000000b600083,
	0x000000000b800083,0x000000000ba00083,0x000000000bc00083,0x000000000be00083,
	0x000000000c000083,0x000000000c200083,0x000000000c400083,0x000000000c600083,
	0x000000000c800083,0x000000000ca00083,0x000000000cc00083,0x000000000ce00083,
	0x000000000d000083,0x000000000d200083,0x000000000d400083,0x000000000d600083,
	0x000000000d800083,0x000000000da00083,0x000000000dc00083,0x000000000de00083,
	0x000000000e000083,0x000000000e200083,0x000000000e400083,0x000000000e600083,
	0x000000000e800083,0x000000000ea00083,0x000000000ec00083,0x000000000ee00083,
	0x000000000f000083,0x000000000f200083,0x000000000f400083,0x000000000f600083,
	0x000000000f800083,0x000000000fa00083,0x000000000fc00083,0x000000000fe00083,
	0x0000000010000083,0x0000000010200083,0x0000000010400083,0x0000000010600083,
	0x0000000010800083,0x0000000010a00083,0x0000000010c00083,0x0000000010e00083,
	0x0000000011000083,0x0000000011200083,0x0000000011400083,0x0000000011600083,
	0x0000000011800083,0x0000000011a00083,0x0000000011c00083,0x0000000011e00083,
	0x0000000012000083,0x0000000012200083,0x0000000012400083,0x0000000012600083,
	0x0000000012800083,0x0000000012a00083,0x0000000012c00083,0x0000000012e00083,
	0x0000000013000083,0x0000000013200083,0x0000000013400083,0x0000000013600083,
	0x0000000013800083,0x0000000013a00083,0x0000000013c00083,0x0000000013e00083,
	0x0000000014000083,0x0000000014200083,0x0000000014400083,0x0000000014600083,
	0x0000000014800083,0x0000000014a00083,0x0000000014c00083,0x0000000014e00083,
	0x0000000015000083,0x0000000015200083,0x0000000015400083,0x0000000015600083,
	0x0000000015800083,0x0000000015a00083,0x0000000015c00083,0x0000000015e00083,
	0x0000000016000083,0x0000000016200083,0x0000000016400083,0x0000000016600083,
	0x0000000016800083,0x0000000016a00083,0x0000000016c00083,0x0000000016e00083,
	0x0000000017000083,0x0000000017200083,0x0000000017400083,0x0000000017600083,
	0x0000000017800083,0x0000000017a00083,0x0000000017c00083,0x0000000017e00083,
	0x0000000018000083,0x0000000018200083,0x0000000018400083,0x0000000018600083,
	0x0000000018800083,0x0000000018a00083,0x0000000018c00083,0x0000000018e00083,
	0x0000000019000083,0x0000000019200083,0x0000000019400083,0x0000000019600083,
	0x0000000019800083,0x0000000019a00083,0x0000000019c00083,0x0000000019e00083,
	0x000000001a000083,0x000000001a200083,0x000000001a400083,0x000000001a600083,
	0x000000001a800083,0x000000001aa00083,0x000000001ac00083,0x000000001ae00083,
	0x000000001b000083,0x000000001b200083,0x000000001b400083,0x000000001b600083,
	0x000000001b800083,0x000000001ba00083,0x000000001bc00083,0x000000001be00083,
	0x000000001c000083,0x000000001c200083,0x000000001c400083,0x000000001c600083,
	0x000000001c800083,0x000000001ca00083,0x000000001cc00083,0x000000001ce00083,
	0x000000001d000083,0x000000001d200083,0x000000001d400083,0x000000001d600083,
	0x000000001d800083,0x000000001da00083,0x000000001dc00083,0x000000001de00083,
	0x000000001e000083,0x000000001e200083,0x000000001e400083,0x000000001e600083,
	0x000000001e800083,0x000000001ea00083,0x000000001ec00083,0x000000001ee00083,
	0x000000001f000083,0x000000001f200083,0x000000001f400083,0x000000001f600083,
	0x000000001f800083,0x000000001fa00083,0x000000001fc00083,0x000000001fe00083,
	0x0000000020000083,0x0000000020200083,0x0000000020400083,0x0000000020600083,
	0x0000000020800083,0x0000000020a00083,0x0000000020c00083,0x0000000020e00083,
	0x0000000021000083,0x0000000021200083,0x0000000021400083,0x0000000021600083,
	0x0000000021800083,0x0000000021a00083,0x0000000021c00083,0x0000000021e00083,
	0x0000000022000083,0x0000000022200083,0x0000000022400083,0x0000000022600083,
	0x0000000022800083,0x0000000022a00083,0x0000000022c00083,0x0000000022e00083,
	0x0000000023000083,0x0000000023200083,0x0000000023400083,0x0000000023600083,
	0x0000000023800083,0x0000000023a00083,0x0000000023c00083,0x0000000023e00083,
	0x0000000024000083,0x0000000024200083,0x0000000024400083,0x0000000024600083,
	0x0000000024800083,0x0000000024a00083,0x0000000024c00083,0x0000000024e00083,
	0x0000000025000083,0x0000000025200083,0x0000000025400083,0x0000000025600083,
	0x0000000025800083,0x0000000025a00083,0x0000000025c00083,0x0000000025e00083,
	0x0000000026000083,0x0000000026200083,0x0000000026400083,0x0000000026600083,
	0x0000000026800083,0x0000000026a00083,0x0000000026c00083,0x0000000026e00083,
	0x0000000027000083,0x0000000027200083,0x0000000027400083,0x0000000027600083,
	0x0000000027800083,0x0000000027a00083,0x0000000027c00083,0x0000000027e00083,
	0x0000000028000083,0x0000000028200083,0x0000000028400083,0x0000000028600083,
	0x0000000028800083,0x0000000028a00083,0x0000000028c00083,0x0000000028e00083,
	0x0000000029000083,0x0000000029200083,0x0000000029400083,0x0000000029600083,
	0x0000000029800083,0x0000000029a00083,0x0000000029c00083,0x0000000029e00083,
	0x000000002a000083,0x000000002a200083,0x000000002a400083,0x000000002a600083,
	0x000000002a800083,0x000000002aa00083,0x000000002ac00083,0x000000002ae00083,
	0x000000002b000083,0x000000002b200083,0x000000002b400083,0x000000002b600083,
	0x000000002b800083,0x000000002ba00083,0x000000002bc00083,0x000000002be00083,
	0x000000002c000083,0x000000002c200083,0x000000002c400083,0x000000002c600083,
	0x000000002c800083,0x000000002ca00083,0x000000002cc00083,0x000000002ce00083,
	0x000000002d000083,0x000000002d200083,0x000000002d400083,0x000000002d600083,
	0x000000002d800083,0x000000002da00083,0x000000002dc00083,0x000000002de00083,
	0x000000002e000083,0x000000002e200083,0x000000002e400083,0x000000002e600083,
	0x000000002e800083,0x000000002ea00083,0x000000002ec00083,0x000000002ee00083,
	0x000000002f000083,0x000000002f200083,0x000000002f400083,0x000000002f600083,
	0x000000002f800083,0x000000002fa00083,0x000000002fc00083,0x000000002fe00083,
	0x0000000030000083,0x0000000030200083,0x0000000030400083,0x0000000030600083,
	0x0000000030800083,0x0000000030a00083,0x0000000030c00083,0x0000000030e00083,
	0x0000000031000083,0x0000000031200083,0x0000000031400083,0x0000000031600083,
	0x0000000031800083,0x0000000031a00083,0x0000000031c00083,0x0000000031e00083,
	0x0000000032000083,0x0000000032200083,0x0000000032400083,0x0000000032600083,
	0x0000000032800083,0x0000000032a00083,0x0000000032c00083,0x0000000032e00083,
	0x0000000033000083,0x0000000033200083,0x0000000033400083,0x0000000033600083,
	0x0000000033800083,0x0000000033a00083,0x0000000033c00083,0x0000000033e00083,
	0x0000000034000083,0x0000000034200083,0x0000000034400083,0x0000000034600083,
	0x0000000034800083,0x0000000034a00083,0x0000000034c00083,0x0000000034e00083,
	0x0000000035000083,0x0000000035200083,0x0000000035400083,0x0000000035600083,
	0x0000000035800083,0x0000000035a00083,0x0000000035c00083,0x0000000035e00083,
	0x0000000036000083,0x0000000036200083,0x0000000036400083,0x0000000036600083,
	0x0000000036800083,0x0000000036a00083,0x0000000036c00083,0x0000000036e00083,
	0x0000000037000083,0x0000000037200083,0x0000000037400083,0x0000000037600083,
	0x0000000037800083,0x0000000037a00083,0x0000000037c00083,0x0000000037e00083,
	0x0000000038000083,0x0000000038200083,0x0000000038400083,0x0000000038600083,
	0x0000000038800083,0x0000000038a00083,0x0000000038c00083,0x0000000038e00083,
	0x0000000039000083,0x0000000039200083,0x0000000039400083,0x0000000039600083,
	0x0000000039800083,0x0000000039a00083,0x0000000039c00083,0x0000000039e00083,
	0x000000003a000083,0x000000003a200083,0x000000003a400083,0x000000003a600083,
	0x000000003a800083,0x000000003aa00083,0x000000003ac00083,0x000000003ae00083,
	0x000000003b000083,0x000000003b200083,0x000000003b400083,0x000000003b600083,
	0x000000003b800083,0x000000003ba00083,0x000000003bc00083,0x000000003be00083,
	0x000000003c000083,0x000000003c200083,0x000000003c400083,0x000000003c600083,
	0x000000003c800083,0x000000003ca00083,0x000000003cc00083,0x000000003ce00083,
	0x000000003d000083,0x000000003d200083,0x000000003d400083,0x000000003d600083,
	0x000000003d800083,0x000000003da00083,0x000000003dc00083,0x000000003de00083,
	0x000000003e000083,0x000000003e200083,0x000000003e400083,0x000000003e600083,
	0x000000003e800083,0x000000003ea00083,0x000000003ec00083,0x000000003ee00083,
	0x000000003f000083,0x000000003f200083,0x000000003f400083,0x000000003f600083,
	0x000000003f800083,0x000000003fa00083,0x000000003fc00083,0x000000003fe00083,
	0x0000000040000083,0x0000000040200083,0x0000000040400083,0x0000000040600083,
	0x0000000040800083,0x0000000040a00083,0x0000000040c00083,0x0000000040e00083,
	0x0000000041000083,0x0000000041200083,0x0000000041400083,0x0000000041600083,
	0x0000000041800083,0x0000000041a00083,0x0000000041c00083,0x0000000041e00083,
	0x0000000042000083,0x0000000042200083,0x0000000042400083,0x0000000042600083,
	0x0000000042800083,0x0000000042a00083,0x0000000042c00083,0x0000000042e00083,
	0x0000000043000083,0x0000000043200083,0x0000000043400083,0x0000000043600083,
	0x0000000043800083,0x0000000043a00083,0x0000000043c00083,0x0000000043e00083,
	0x0000000044000083,0x0000000044200083,0x0000000044400083,0x0000000044600083,
	0x0000000044800083,0x0000000044a00083,0x0000000044c00083,0x0000000044e00083,
	0x0000000045000083,0x0000000045200083,0x0000000045400083,0x0000000045600083,
	0x0000000045800083,0x0000000045a00083,0x0000000045c00083,0x0000000045e00083,
	0x0000000046000083,0x0000000046200083,0x0000000046400083,0x0000000046600083,
	0x0000000046800083,0x0000000046a00083,0x0000000046c00083,0x0000000046e00083,
	0x0000000047000083,0x0000000047200083,0x0000000047400083,0x0000000047600083,
	0x0000000047800083,0x0000000047a00083,0x0000000047c00083,0x0000000047e00083,
	0x0000000048000083,0x0000000048200083,0x0000000048400083,0x0000000048600083,
	0x0000000048800083,0x0000000048a00083,0x0000000048c00083,0x0000000048e00083,
	0x0000000049000083,0x0000000049200083,0x0000000049400083,0x0000000049600083,
	0x0000000049800083,0x0000000049a00083,0x0000000049c00083,0x0000000049e00083,
	0x000000004a000083,0x000000004a200083,0x000000004a400083,0x000000004a600083,
	0x000000004a800083,0x000000004aa00083,0x000000004ac00083,0x000000004ae00083,
	0x000000004b000083,0x000000004b200083,0x000000004b400083,0x000000004b600083,
	0x000000004b800083,0x000000004ba00083,0x000000004bc00083,0x000000004be00083,
	0x000000004c000083,0x000000004c200083,0x000000004c400083,0x000000004c600083,
	0x000000004c800083,0x000000004ca00083,0x000000004cc00083,0x000000004ce00083,
	0x000000004d000083,0x000000004d200083,0x000000004d400083,0x000000004d600083,
	0x000000004d800083,0x000000004da00083,0x000000004dc00083,0x000000004de00083,
	0x000000004e000083,0x000000004e200083,0x000000004e400083,0x000000004e600083,
	0x000000004e800083,0x000000004ea00083,0x000000004ec00083,0x000000004ee00083,
	0x000000004f000083,0x000000004f200083,0x000000004f400083,0x000000004f600083,
	0x000000004f800083,0x000000004fa00083,0x000000004fc00083,0x000000004fe00083,
	0x0000000050000083,0x0000000050200083,0x0000000050400083,0x0000000050600083,
	0x0000000050800083,0x0000000050a00083,0x0000000050c00083,0x0000000050e00083,
	0x0000000051000083,0x0000000051200083,0x0000000051400083,0x0000000051600083,
	0x0000000051800083,0x0000000051a00083,0x0000000051c00083,0x0000000051e00083,
	0x0000000052000083,0x0000000052200083,0x0000000052400083,0x0000000052600083,
	0x0000000052800083,0x0000000052a00083,0x0000000052c00083,0x0000000052e00083,
	0x0000000053000083,0x0000000053200083,0x0000000053400083,0x0000000053600083,
	0x0000000053800083,0x0000000053a00083,0x0000000053c00083,0x0000000053e00083,
	0x0000000054000083,0x0000000054200083,0x0000000054400083,0x0000000054600083,
	0x0000000054800083,0x0000000054a00083,0x0000000054c00083,0x0000000054e00083,
	0x0000000055000083,0x0000000055200083,0x0000000055400083,0x0000000055600083,
	0x0000000055800083,0x0000000055a00083,0x0000000055c00083,0x0000000055e00083,
	0x0000000056000083,0x0000000056200083,0x0000000056400083,0x0000000056600083,
	0x0000000056800083,0x0000000056a00083,0x0000000056c00083,0x0000000056e00083,
	0x0000000057000083,0x0000000057200083,0x0000000057400083,0x0000000057600083,
	0x0000000057800083,0x0000000057a00083,0x0000000057c00083,0x0000000057e00083,
	0x0000000058000083,0x0000000058200083,0x0000000058400083,0x0000000058600083,
	0x0000000058800083,0x0000000058a00083,0x0000000058c00083,0x0000000058e00083,
	0x0000000059000083,0x0000000059200083,0x0000000059400083,0x0000000059600083,
	0x0000000059800083,0x0000000059a00083,0x0000000059c00083,0x0000000059e00083,
	0x000000005a000083,0x000000005a200083,0x000000005a400083,0x000000005a600083,
	0x000000005a800083,0x000000005aa00083,0x000000005ac00083,0x000000005ae00083,
	0x000000005b000083,0x000000005b200083,0x000000005b400083,0x000000005b600083,
	0x000000005b800083,0x000000005ba00083,0x000000005bc00083,0x000000005be00083,
	0x000000005c000083,0x000000005c200083,0x000000005c400083,0x000000005c600083,
	0x000000005c800083,0x000000005ca00083,0x000000005cc00083,0x000000005ce00083,
	0x000000005d000083,0x000000005d200083,0x000000005d400083,0x000000005d600083,
	0x000000005d800083,0x000000005da00083,0x000000005dc00083,0x000000005de00083,
	0x000000005e000083,0x000000005e200083,0x000000005e400083,0x000000005e600083,
	0x000000005e800083,0x000000005ea00083,0x000000005ec00083,0x000000005ee00083,
	0x000000005f000083,0x000000005f200083,0x000000005f400083,0x000000005f600083,
	0x000000005f800083,0x000000005fa00083,0x000000005fc00083,0x000000005fe00083,
	0x0000000060000083,0x0000000060200083,0x0000000060400083,0x0000000060600083,
	0x0000000060800083,0x0000000060a00083,0x0000000060c00083,0x0000000060e00083,
	0x0000000061000083,0x0000000061200083,0x0000000061400083,0x0000000061600083,
	0x0000000061800083,0x0000000061a00083,0x0000000061c00083,0x0000000061e00083,
	0x0000000062000083,0x0000000062200083,0x0000000062400083,0x0000000062600083,
	0x0000000062800083,0x0000000062a00083,0x0000000062c00083,0x0000000062e00083,
	0x0000000063000083,0x0000000063200083,0x0000000063400083,0x0000000063600083,
	0x0000000063800083,0x0000000063a00083,0x0000000063c00083,0x0000000063e00083,
	0x0000000064000083,0x0000000064200083,0x0000000064400083,0x0000000064600083,
	0x0000000064800083,0x0000000064a00083,0x0000000064c00083,0x0000000064e00083,
	0x0000000065000083,0x0000000065200083,0x0000000065400083,0x0000000065600083,
	0x0000000065800083,0x0000000065a00083,0x0000000065c00083,0x0000000065e00083,
	0x0000000066000083,0x0000000066200083,0x0000000066400083,0x0000000066600083,
	0x0000000066800083,0x0000000066a00083,0x0000000066c00083,0x0000000066e00083,
	0x0000000067000083,0x0000000067200083,0x0000000067400083,0x0000000067600083,
	0x0000000067800083,0x0000000067a00083,0x0000000067c00083,0x0000000067e00083,
	0x0000000068000083,0x0000000068200083,0x0000000068400083,0x0000000068600083,
	0x0000000068800083,0x0000000068a00083,0x0000000068c00083,0x0000000068e00083,
	0x0000000069000083,0x0000000069200083,0x0000000069400083,0x0000000069600083,
	0x0000000069800083,0x0000000069a00083,0x0000000069c00083,0x0000000069e00083,
	0x000000006a000083,0x000000006a200083,0x000000006a400083,0x000000006a600083,
	0x000000006a800083,0x000000006aa00083,0x000000006ac00083,0x000000006ae00083,
	0x000000006b000083,0x000000006b200083,0x000000006b400083,0x000000006b600083,
	0x000000006b800083,0x000000006ba00083,0x000000006bc00083,0x000000006be00083,
	0x000000006c000083,0x000000006c200083,0x000000006c400083,0x000000006c600083,
	0x000000006c800083,0x000000006ca00083,0x000000006cc00083,0x000000006ce00083,
	0x000000006d000083,0x000000006d200083,0x000000006d400083,0x000000006d600083,
	0x000000006d800083,0x000000006da00083,0x000000006dc00083,0x000000006de00083,
	0x000000006e000083,0x000000006e200083,0x000000006e400083,0x000000006e600083,
	0x000000006e800083,0x000000006ea00083,0x000000006ec00083,0x000000006ee00083,
	0x000000006f000083,0x000000006f200083,0x000000006f400083,0x000000006f600083,
	0x000000006f800083,0x000000006fa00083,0x000000006fc00083,0x000000006fe00083,
	0x0000000070000083,0x0000000070200083,0x0000000070400083,0x0000000070600083,
	0x0000000070800083,0x0000000070a00083,0x0000000070c00083,0x0000000070e00083,
	0x0000000071000083,0x0000000071200083,0x0000000071400083,0x0000000071600083,
	0x0000000071800083,0x0000000071a00083,0x0000000071c00083,0x0000000071e00083,
	0x0000000072000083,0x0000000072200083,0x0000000072400083,0x0000000072600083,
	0x0000000072800083,0x0000000072a00083,0x0000000072c00083,0x0000000072e00083,
	0x0000000073000083,0x0000000073200083,0x0000000073400083,0x0000000073600083,
	0x0000000073800083,0x0000000073a00083,0x0000000073c00083,0x0000000073e00083,
	0x0000000074000083,0x0000000074200083,0x0000000074400083,0x0000000074600083,
	0x0000000074800083,0x0000000074a00083,0x0000000074c00083,0x0000000074e00083,
	0x0000000075000083,0x0000000075200083,0x0000000075400083,0x0000000075600083,
	0x0000000075800083,0x0000000075a00083,0x0000000075c00083,0x0000000075e00083,
	0x0000000076000083,0x0000000076200083,0x0000000076400083,0x0000000076600083,
	0x0000000076800083,0x0000000076a00083,0x0000000076c00083,0x0000000076e00083,
	0x0000000077000083,0x0000000077200083,0x0000000077400083,0x0000000077600083,
	0x0000000077800083,0x0000000077a00083,0x0000000077c00083,0x0000000077e00083,
	0x0000000078000083,0x0000000078200083,0x0000000078400083,0x0000000078600083,
	0x0000000078800083,0x0000000078a00083,0x0000000078c00083,0x0000000078e00083,
	0x0000000079000083,0x0000000079200083,0x0000000079400083,0x0000000079600083,
	0x0000000079800083,0x0000000079a00083,0x0000000079c00083,0x0000000079e00083,
	0x000000007a000083,0x000000007a200083,0x000000007a400083,0x000000007a600083,
	0x000000007a800083,0x000000007aa00083,0x000000007ac00083,0x000000007ae00083,
	0x000000007b000083,0x000000007b200083,0x000000007b400083,0x000000007b600083,
	0x000000007b800083,0x000000007ba00083,0x000000007bc00083,0x000000007be00083,
	0x000000007c000083,0x000000007c200083,0x000000007c400083,0x000000007c600083,
	0x000000007c800083,0x000000007ca00083,0x000000007cc00083,0x000000007ce00083,
	0x000000007d000083,0x000000007d200083,0x000000007d400083,0x000000007d600083,
	0x000000007d800083,0x000000007da00083,0x000000007dc00083,0x000000007de00083,
	0x000000007e000083,0x000000007e200083,0x000000007e400083,0x000000007e600083,
	0x000000007e800083,0x000000007ea00083,0x000000007ec00083,0x000000007ee00083,
	0x000000007f000083,0x000000007f200083,0x000000007f400083,0x000000007f600083,
	0x000000007f800083,0x000000007fa00083,0x000000007fc00083,0x000000007fe00083,
	0x0000000080000083,0x0000000080200083,0x0000000080400083,0x0000000080600083,
	0x0000000080800083,0x0000000080a00083,0x0000000080c00083,0x0000000080e00083,
	0x0000000083000083,0x0000000083200083,0x0000000083400083,0x0000000083600083,
	0x0000000083800083,0x0000000083a00083,0x0000000083c00083,0x0000000083e00083,
	0x0000000082000083,0x0000000082200083,0x0000000082400083,0x0000000082600083,
	0x0000000082800083,0x0000000082a00083,0x0000000082c00083,0x0000000082e00083,
	0x0000000083000083,0x0000000083200083,0x0000000083400083,0x0000000083600083,
	0x0000000083800083,0x0000000083a00083,0x0000000083c00083,0x0000000083e00083,
	0x0000000084000083,0x0000000084200083,0x0000000084400083,0x0000000084600083,
	0x0000000084800083,0x0000000084a00083,0x0000000084c00083,0x0000000084e00083,
	0x0000000085000083,0x0000000085200083,0x0000000085400083,0x0000000085600083,
	0x0000000085800083,0x0000000085a00083,0x0000000085c00083,0x0000000085e00083,
	0x0000000086000083,0x0000000086200083,0x0000000086400083,0x0000000086600083,
	0x0000000086800083,0x0000000086a00083,0x0000000086c00083,0x0000000086e00083,
	0x0000000087000083,0x0000000087200083,0x0000000087400083,0x0000000087600083,
	0x0000000087800083,0x0000000087a00083,0x0000000087c00083,0x0000000087e00083,
	0x0000000088000083,0x0000000088200083,0x0000000088400083,0x0000000088600083,
	0x0000000088800083,0x0000000088a00083,0x0000000088c00083,0x0000000088e00083,
	0x0000000089000083,0x0000000089200083,0x0000000089400083,0x0000000089600083,
	0x0000000089800083,0x0000000089a00083,0x0000000089c00083,0x0000000089e00083,
	0x000000008a000083,0x000000008a200083,0x000000008a400083,0x000000008a600083,
	0x000000008a800083,0x000000008aa00083,0x000000008ac00083,0x000000008ae00083,
	0x000000008b000083,0x000000008b200083,0x000000008b400083,0x000000008b600083,
	0x000000008b800083,0x000000008ba00083,0x000000008bc00083,0x000000008be00083,
	0x000000008c000083,0x000000008c200083,0x000000008c400083,0x000000008c600083,
	0x000000008c800083,0x000000008ca00083,0x000000008cc00083,0x000000008ce00083,
	0x000000008d000083,0x000000008d200083,0x000000008d400083,0x000000008d600083,
	0x000000008d800083,0x000000008da00083,0x000000008dc00083,0x000000008de00083,
	0x000000008e000083,0x000000008e200083,0x000000008e400083,0x000000008e600083,
	0x000000008e800083,0x000000008ea00083,0x000000008ec00083,0x000000008ee00083,
	0x000000008f000083,0x000000008f200083,0x000000008f400083,0x000000008f600083,
	0x000000008f800083,0x000000008fa00083,0x000000008fc00083,0x000000008fe00083,
	0x0000000090000083,0x0000000090200083,0x0000000090400083,0x0000000090600083,
	0x0000000090800083,0x0000000090a00083,0x0000000090c00083,0x0000000090e00083,
	0x0000000091000083,0x0000000091200083,0x0000000091400083,0x0000000091600083,
	0x0000000091800083,0x0000000091a00083,0x0000000091c00083,0x0000000091e00083,
	0x0000000092000083,0x0000000092200083,0x0000000092400083,0x0000000092600083,
	0x0000000092800083,0x0000000092a00083,0x0000000092c00083,0x0000000092e00083,
	0x0000000093000083,0x0000000093200083,0x0000000093400083,0x0000000093600083,
	0x0000000093800083,0x0000000093a00083,0x0000000093c00083,0x0000000093e00083,
	0x0000000094000083,0x0000000094200083,0x0000000094400083,0x0000000094600083,
	0x0000000094800083,0x0000000094a00083,0x0000000094c00083,0x0000000094e00083,
	0x0000000095000083,0x0000000095200083,0x0000000095400083,0x0000000095600083,
	0x0000000095800083,0x0000000095a00083,0x0000000095c00083,0x0000000095e00083,
	0x0000000096000083,0x0000000096200083,0x0000000096400083,0x0000000096600083,
	0x0000000096800083,0x0000000096a00083,0x0000000096c00083,0x0000000096e00083,
	0x0000000097000083,0x0000000097200083,0x0000000097400083,0x0000000097600083,
	0x0000000097800083,0x0000000097a00083,0x0000000097c00083,0x0000000097e00083,
	0x0000000098000083,0x0000000098200083,0x0000000098400083,0x0000000098600083,
	0x0000000098800083,0x0000000098a00083,0x0000000098c00083,0x0000000098e00083,
	0x0000000099000083,0x0000000099200083,0x0000000099400083,0x0000000099600083,
	0x0000000099800083,0x0000000099a00083,0x0000000099c00083,0x0000000099e00083,
	0x000000009a000083,0x000000009a200083,0x000000009a400083,0x000000009a600083,
	0x000000009a800083,0x000000009aa00083,0x000000009ac00083,0x000000009ae00083,
	0x000000009b000083,0x000000009b200083,0x000000009b400083,0x000000009b600083,
	0x000000009b800083,0x000000009ba00083,0x000000009bc00083,0x000000009be00083,
	0x000000009c000083,0x000000009c200083,0x000000009c400083,0x000000009c600083,
	0x000000009c800083,0x000000009ca00083,0x000000009cc00083,0x000000009ce00083,
	0x000000009d000083,0x000000009d200083,0x000000009d400083,0x000000009d600083,
	0x000000009d800083,0x000000009da00083,0x000000009dc00083,0x000000009de00083,
	0x000000009e000083,0x000000009e200083,0x000000009e400083,0x000000009e600083,
	0x000000009e800083,0x000000009ea00083,0x000000009ec00083,0x000000009ee00083,
	0x000000009f000083,0x000000009f200083,0x000000009f400083,0x000000009f600083,
	0x000000009f800083,0x000000009fa00083,0x000000009fc00083,0x000000009fe00083,
	0x00000000a0000083,0x00000000a0200083,0x00000000a0400083,0x00000000a0600083,
	0x00000000a0800083,0x00000000a0a00083,0x00000000a0c00083,0x00000000a0e00083,
	0x00000000a1000083,0x00000000a1200083,0x00000000a1400083,0x00000000a1600083,
	0x00000000a1800083,0x00000000a1a00083,0x00000000a1c00083,0x00000000a1e00083,
	0x00000000a2000083,0x00000000a2200083,0x00000000a2400083,0x00000000a2600083,
	0x00000000a2800083,0x00000000a2a00083,0x00000000a2c00083,0x00000000a2e00083,
	0x00000000a3000083,0x00000000a3200083,0x00000000a3400083,0x00000000a3600083,
	0x00000000a3800083,0x00000000a3a00083,0x00000000a3c00083,0x00000000a3e00083,
	0x00000000a4000083,0x00000000a4200083,0x00000000a4400083,0x00000000a4600083,
	0x00000000a4800083,0x00000000a4a00083,0x00000000a4c00083,0x00000000a4e00083,
	0x00000000a5000083,0x00000000a5200083,0x00000000a5400083,0x00000000a5600083,
	0x00000000a5800083,0x00000000a5a00083,0x00000000a5c00083,0x00000000a5e00083,
	0x00000000a6000083,0x00000000a6200083,0x00000000a6400083,0x00000000a6600083,
	0x00000000a6800083,0x00000000a6a00083,0x00000000a6c00083,0x00000000a6e00083,
	0x00000000a7000083,0x00000000a7200083,0x00000000a7400083,0x00000000a7600083,
	0x00000000a7800083,0x00000000a7a00083,0x00000000a7c00083,0x00000000a7e00083,
	0x00000000a8000083,0x00000000a8200083,0x00000000a8400083,0x00000000a8600083,
	0x00000000a8800083,0x00000000a8a00083,0x00000000a8c00083,0x00000000a8e00083,
	0x00000000a9000083,0x00000000a9200083,0x00000000a9400083,0x00000000a9600083,
	0x00000000a9800083,0x00000000a9a00083,0x00000000a9c00083,0x00000000a9e00083,
	0x00000000aa000083,0x00000000aa200083,0x00000000aa400083,0x00000000aa600083,
	0x00000000aa800083,0x00000000aaa00083,0x00000000aac00083,0x00000000aae00083,
	0x00000000ab000083,0x00000000ab200083,0x00000000ab400083,0x00000000ab600083,
	0x00000000ab800083,0x00000000aba00083,0x00000000abc00083,0x00000000abe00083,
	0x00000000ac000083,0x00000000ac200083,0x00000000ac400083,0x00000000ac600083,
	0x00000000ac800083,0x00000000aca00083,0x00000000acc00083,0x00000000ace00083,
	0x00000000ad000083,0x00000000ad200083,0x00000000ad400083,0x00000000ad600083,
	0x00000000ad800083,0x00000000ada00083,0x00000000adc00083,0x00000000ade00083,
	0x00000000ae000083,0x00000000ae200083,0x00000000ae400083,0x00000000ae600083,
	0x00000000ae800083,0x00000000aea00083,0x00000000aec00083,0x00000000aee00083,
	0x00000000af000083,0x00000000af200083,0x00000000af400083,0x00000000af600083,
	0x00000000af800083,0x00000000afa00083,0x00000000afc00083,0x00000000afe00083,
	0x00000000b0000083,0x00000000b0200083,0x00000000b0400083,0x00000000b0600083,
	0x00000000b0800083,0x00000000b0a00083,0x00000000b0c00083,0x00000000b0e00083,
	0x00000000b1000083,0x00000000b1200083,0x00000000b1400083,0x00000000b1600083,
	0x00000000b1800083,0x00000000b1a00083,0x00000000b1c00083,0x00000000b1e00083,
	0x00000000b2000083,0x00000000b2200083,0x00000000b2400083,0x00000000b2600083,
	0x00000000b2800083,0x00000000b2a00083,0x00000000b2c00083,0x00000000b2e00083,
	0x00000000b3000083,0x00000000b3200083,0x00000000b3400083,0x00000000b3600083,
	0x00000000b3800083,0x00000000b3a00083,0x00000000b3c00083,0x00000000b3e00083,
	0x00000000b4000083,0x00000000b4200083,0x00000000b4400083,0x00000000b4600083,
	0x00000000b4800083,0x00000000b4a00083,0x00000000b4c00083,0x00000000b4e00083,
	0x00000000b5000083,0x00000000b5200083,0x00000000b5400083,0x00000000b5600083,
	0x00000000b5800083,0x00000000b5a00083,0x00000000b5c00083,0x00000000b5e00083,
	0x00000000b6000083,0x00000000b6200083,0x00000000b6400083,0x00000000b6600083,
	0x00000000b6800083,0x00000000b6a00083,0x00000000b6c00083,0x00000000b6e00083,
	0x00000000b7000083,0x00000000b7200083,0x00000000b7400083,0x00000000b7600083,
	0x00000000b7800083,0x00000000b7a00083,0x00000000b7c00083,0x00000000b7e00083,
	0x00000000b8000083,0x00000000b8200083,0x00000000b8400083,0x00000000b8600083,
	0x00000000b8800083,0x00000000b8a00083,0x00000000b8c00083,0x00000000b8e00083,
	0x00000000b9000083,0x00000000b9200083,0x00000000b9400083,0x00000000b9600083,
	0x00000000b9800083,0x00000000b9a00083,0x00000000b9c00083,0x00000000b9e00083,
	0x00000000ba000083,0x00000000ba200083,0x00000000ba400083,0x00000000ba600083,
	0x00000000ba800083,0x00000000baa00083,0x00000000bac00083,0x00000000bae00083,
	0x00000000bb000083,0x00000000bb200083,0x00000000bb400083,0x00000000bb600083,
	0x00000000bb800083,0x00000000bba00083,0x00000000bbc00083,0x00000000bbe00083,
	0x00000000bc000083,0x00000000bc200083,0x00000000bc400083,0x00000000bc600083,
	0x00000000bc800083,0x00000000bca00083,0x00000000bcc00083,0x00000000bce00083,
	0x00000000bd000083,0x00000000bd200083,0x00000000bd400083,0x00000000bd600083,
	0x00000000bd800083,0x00000000bda00083,0x00000000bdc00083,0x00000000bde00083,
	0x00000000be000083,0x00000000be200083,0x00000000be400083,0x00000000be600083,
	0x00000000be800083,0x00000000bea00083,0x00000000bec00083,0x00000000bee00083,
	0x00000000bf000083,0x00000000bf200083,0x00000000bf400083,0x00000000bf600083,
	0x00000000bf800083,0x00000000bfa00083,0x00000000bfc00083,0x00000000bfe00083,
	0x00000000c0000083,0x00000000c0200083,0x00000000c0400083,0x00000000c0600083,
	0x00000000c0800083,0x00000000c0a00083,0x00000000c0c00083,0x00000000c0e00083,
	0x00000000c1000083,0x00000000c1200083,0x00000000c1400083,0x00000000c1600083,
	0x00000000c1800083,0x00000000c1a00083,0x00000000c1c00083,0x00000000c1e00083,
	0x00000000c2000083,0x00000000c2200083,0x00000000c2400083,0x00000000c2600083,
	0x00000000c2800083,0x00000000c2a00083,0x00000000c2c00083,0x00000000c2e00083,
	0x00000000c3000083,0x00000000c3200083,0x00000000c3400083,0x00000000c3600083,
	0x00000000c3800083,0x00000000c3a00083,0x00000000c3c00083,0x00000000c3e00083,
	0x00000000c4000083,0x00000000c4200083,0x00000000c4400083,0x00000000c4600083,
	0x00000000c4800083,0x00000000c4a00083,0x00000000c4c00083,0x00000000c4e00083,
	0x00000000c5000083,0x00000000c5200083,0x00000000c5400083,0x00000000c5600083,
	0x00000000c5800083,0x00000000c5a00083,0x00000000c5c00083,0x00000000c5e00083,
	0x00000000c6000083,0x00000000c6200083,0x00000000c6400083,0x00000000c6600083,
	0x00000000c6800083,0x00000000c6a00083,0x00000000c6c00083,0x00000000c6e00083,
	0x00000000c7000083,0x00000000c7200083,0x00000000c7400083,0x00000000c7600083,
	0x00000000c7800083,0x00000000c7a00083,0x00000000c7c00083,0x00000000c7e00083,
	0x00000000c8000083,0x00000000c8200083,0x00000000c8400083,0x00000000c8600083,
	0x00000000c8800083,0x00000000c8a00083,0x00000000c8c00083,0x00000000c8e00083,
	0x00000000c9000083,0x00000000c9200083,0x00000000c9400083,0x00000000c9600083,
	0x00000000c9800083,0x00000000c9a00083,0x00000000c9c00083,0x00000000c9e00083,
	0x00000000ca000083,0x00000000ca200083,0x00000000ca400083,0x00000000ca600083,
	0x00000000ca800083,0x00000000caa00083,0x00000000cac00083,0x00000000cae00083,
	0x00000000cb000083,0x00000000cb200083,0x00000000cb400083,0x00000000cb600083,
	0x00000000cb800083,0x00000000cba00083,0x00000000cbc00083,0x00000000cbe00083,
	0x00000000cc000083,0x00000000cc200083,0x00000000cc400083,0x00000000cc600083,
	0x00000000cc800083,0x00000000cca00083,0x00000000ccc00083,0x00000000cce00083,
	0x00000000cd000083,0x00000000cd200083,0x00000000cd400083,0x00000000cd600083,
	0x00000000cd800083,0x00000000cda00083,0x00000000cdc00083,0x00000000cde00083,
	0x00000000ce000083,0x00000000ce200083,0x00000000ce400083,0x00000000ce600083,
	0x00000000ce800083,0x00000000cea00083,0x00000000cec00083,0x00000000cee00083,
	0x00000000cf000083,0x00000000cf200083,0x00000000cf400083,0x00000000cf600083,
	0x00000000cf800083,0x00000000cfa00083,0x00000000cfc00083,0x00000000cfe00083,
	0x00000000d0000083,0x00000000d0200083,0x00000000d0400083,0x00000000d0600083,
	0x00000000d0800083,0x00000000d0a00083,0x00000000d0c00083,0x00000000d0e00083,
	0x00000000d1000083,0x00000000d1200083,0x00000000d1400083,0x00000000d1600083,
	0x00000000d1800083,0x00000000d1a00083,0x00000000d1c00083,0x00000000d1e00083,
	0x00000000d2000083,0x00000000d2200083,0x00000000d2400083,0x00000000d2600083,
	0x00000000d2800083,0x00000000d2a00083,0x00000000d2c00083,0x00000000d2e00083,
	0x00000000d3000083,0x00000000d3200083,0x00000000d3400083,0x00000000d3600083,
	0x00000000d3800083,0x00000000d3a00083,0x00000000d3c00083,0x00000000d3e00083,
	0x00000000d4000083,0x00000000d4200083,0x00000000d4400083,0x00000000d4600083,
	0x00000000d4800083,0x00000000d4a00083,0x00000000d4c00083,0x00000000d4e00083,
	0x00000000d5000083,0x00000000d5200083,0x00000000d5400083,0x00000000d5600083,
	0x00000000d5800083,0x00000000d5a00083,0x00000000d5c00083,0x00000000d5e00083,
	0x00000000d6000083,0x00000000d6200083,0x00000000d6400083,0x00000000d6600083,
	0x00000000d6800083,0x00000000d6a00083,0x00000000d6c00083,0x00000000d6e00083,
	0x00000000d7000083,0x00000000d7200083,0x00000000d7400083,0x00000000d7600083,
	0x00000000d7800083,0x00000000d7a00083,0x00000000d7c00083,0x00000000d7e00083,
	0x00000000d8000083,0x00000000d8200083,0x00000000d8400083,0x00000000d8600083,
	0x00000000d8800083,0x00000000d8a00083,0x00000000d8c00083,0x00000000d8e00083,
	0x00000000d9000083,0x00000000d9200083,0x00000000d9400083,0x00000000d9600083,
	0x00000000d9800083,0x00000000d9a00083,0x00000000d9c00083,0x00000000d9e00083,
	0x00000000da000083,0x00000000da200083,0x00000000da400083,0x00000000da600083,
	0x00000000da800083,0x00000000daa00083,0x00000000dac00083,0x00000000dae00083,
	0x00000000db000083,0x00000000db200083,0x00000000db400083,0x00000000db600083,
	0x00000000db800083,0x00000000dba00083,0x00000000dbc00083,0x00000000dbe00083,
	0x00000000dc000083,0x00000000dc200083,0x00000000dc400083,0x00000000dc600083,
	0x00000000dc800083,0x00000000dca00083,0x00000000dcc00083,0x00000000dce00083,
	0x00000000dd000083,0x00000000dd200083,0x00000000dd400083,0x00000000dd600083,
	0x00000000dd800083,0x00000000dda00083,0x00000000ddc00083,0x00000000dde00083,
	0x00000000de000083,0x00000000de200083,0x00000000de400083,0x00000000de600083,
	0x00000000de800083,0x00000000dea00083,0x00000000dec00083,0x00000000dee00083,
	0x00000000df000083,0x00000000df200083,0x00000000df400083,0x00000000df600083,
	0x00000000df800083,0x00000000dfa00083,0x00000000dfc00083,0x00000000dfe00083,
	0x00000000e0000083,0x00000000e0200083,0x00000000e0400083,0x00000000e0600083,
	0x00000000e0800083,0x00000000e0a00083,0x00000000e0c00083,0x00000000e0e00083,
	0x00000000e1000083,0x00000000e1200083,0x00000000e1400083,0x00000000e1600083,
	0x00000000e1800083,0x00000000e1a00083,0x00000000e1c00083,0x00000000e1e00083,
	0x00000000e2000083,0x00000000e2200083,0x00000000e2400083,0x00000000e2600083,
	0x00000000e2800083,0x00000000e2a00083,0x00000000e2c00083,0x00000000e2e00083,
	0x00000000e3000083,0x00000000e3200083,0x00000000e3400083,0x00000000e3600083,
	0x00000000e3800083,0x00000000e3a00083,0x00000000e3c00083,0x00000000e3e00083,
	0x00000000e4000083,0x00000000e4200083,0x00000000e4400083,0x00000000e4600083,
	0x00000000e4800083,0x00000000e4a00083,0x00000000e4c00083,0x00000000e4e00083,
	0x00000000e5000083,0x00000000e5200083,0x00000000e5400083,0x00000000e5600083,
	0x00000000e5800083,0x00000000e5a00083,0x00000000e5c00083,0x00000000e5e00083,
	0x00000000e6000083,0x00000000e6200083,0x00000000e6400083,0x00000000e6600083,
	0x00000000e6800083,0x00000000e6a00083,0x00000000e6c00083,0x00000000e6e00083,
	0x00000000e7000083,0x00000000e7200083,0x00000000e7400083,0x00000000e7600083,
	0x00000000e7800083,0x00000000e7a00083,0x00000000e7c00083,0x00000000e7e00083,
	0x00000000e8000083,0x00000000e8200083,0x00000000e8400083,0x00000000e8600083,
	0x00000000e8800083,0x00000000e8a00083,0x00000000e8c00083,0x00000000e8e00083,
	0x00000000e9000083,0x00000000e9200083,0x00000000e9400083,0x00000000e9600083,
	0x00000000e9800083,0x00000000e9a00083,0x00000000e9c00083,0x00000000e9e00083,
	0x00000000ea000083,0x00000000ea200083,0x00000000ea400083,0x00000000ea600083,
	0x00000000ea800083,0x00000000eaa00083,0x00000000eac00083,0x00000000eae00083,
	0x00000000eb000083,0x00000000eb200083,0x00000000eb400083,0x00000000eb600083,
	0x00000000eb800083,0x00000000eba00083,0x00000000ebc00083,0x00000000ebe00083,
	0x00000000ec000083,0x00000000ec200083,0x00000000ec400083,0x00000000ec600083,
	0x00000000ec800083,0x00000000eca00083,0x00000000ecc00083,0x00000000ece00083,
	0x00000000ed000083,0x00000000ed200083,0x00000000ed400083,0x00000000ed600083,
	0x00000000ed800083,0x00000000eda00083,0x00000000edc00083,0x00000000ede00083,
	0x00000000ee000083,0x00000000ee200083,0x00000000ee400083,0x00000000ee600083,
	0x00000000ee800083,0x00000000eea00083,0x00000000eec00083,0x00000000eee00083,
	0x00000000ef000083,0x00000000ef200083,0x00000000ef400083,0x00000000ef600083,
	0x00000000ef800083,0x00000000efa00083,0x00000000efc00083,0x00000000efe00083,
	0x00000000f0000083,0x00000000f0200083,0x00000000f0400083,0x00000000f0600083,
	0x00000000f0800083,0x00000000f0a00083,0x00000000f0c00083,0x00000000f0e00083,
	0x00000000f1000083,0x00000000f1200083,0x00000000f1400083,0x00000000f1600083,
	0x00000000f1800083,0x00000000f1a00083,0x00000000f1c00083,0x00000000f1e00083,
	0x00000000f2000083,0x00000000f2200083,0x00000000f2400083,0x00000000f2600083,
	0x00000000f2800083,0x00000000f2a00083,0x00000000f2c00083,0x00000000f2e00083,
	0x00000000f3000083,0x00000000f3200083,0x00000000f3400083,0x00000000f3600083,
	0x00000000f3800083,0x00000000f3a00083,0x00000000f3c00083,0x00000000f3e00083,
	0x00000000f4000083,0x00000000f4200083,0x00000000f4400083,0x00000000f4600083,
	0x00000000f4800083,0x00000000f4a00083,0x00000000f4c00083,0x00000000f4e00083,
	0x00000000f5000083,0x00000000f5200083,0x00000000f5400083,0x00000000f5600083,
	0x00000000f5800083,0x00000000f5a00083,0x00000000f5c00083,0x00000000f5e00083,
	0x00000000f6000083,0x00000000f6200083,0x00000000f6400083,0x00000000f6600083,
	0x00000000f6800083,0x00000000f6a00083,0x00000000f6c00083,0x00000000f6e00083,
	0x00000000f7000083,0x00000000f7200083,0x00000000f7400083,0x00000000f7600083,
	0x00000000f7800083,0x00000000f7a00083,0x00000000f7c00083,0x00000000f7e00083,
	0x00000000f8000083,0x00000000f8200083,0x00000000f8400083,0x00000000f8600083,
	0x00000000f8800083,0x00000000f8a00083,0x00000000f8c00083,0x00000000f8e00083,
	0x00000000f9000083,0x00000000f9200083,0x00000000f9400083,0x00000000f9600083,
	0x00000000f9800083,0x00000000f9a00083,0x00000000f9c00083,0x00000000f9e00083,
	0x00000000fa000083,0x00000000fa200083,0x00000000fa400083,0x00000000fa600083,
	0x00000000fa800083,0x00000000faa00083,0x00000000fac00083,0x00000000fae00083,
	0x00000000fb000083,0x00000000fb200083,0x00000000fb400083,0x00000000fb600083,
	0x00000000fb800083,0x00000000fba00083,0x00000000fbc00083,0x00000000fbe00083,
	0x00000000fc000083,0x00000000fc200083,0x00000000fc400083,0x00000000fc600083,
	0x00000000fc800083,0x00000000fca00083,0x00000000fcc00083,0x00000000fce00083,
	0x00000000fd000083,0x00000000fd200083,0x00000000fd400083,0x00000000fd600083,
	0x00000000fd800083,0x00000000fda00083,0x00000000fdc00083,0x00000000fde00083,
	0x00000000fe000083,0x00000000fe200083,0x00000000fe400083,0x00000000fe600083,
	0x00000000fe800083,0x00000000fea00083,0x00000000fec00093,0x00000000fee00093,
	0x00000000ff000093,0x00000000ff200093,0x00000000ff400093,0x00000000ff600093,
	0x00000000ff800093,0x00000000ffa00093,0x00000000ffc00093,0x00000000ffe00093,
};

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pdpt[PAE_MAXPTRS_PER_PDPT] = {
    ((u64)(&_xcprimeon_init_pdt[0]) + (u64)(_PAGE_PRESENT | _PAGE_RW) ),
    ((u64)(&_xcprimeon_init_pdt[512]) + (u64)(_PAGE_PRESENT | _PAGE_RW) ),
    ((u64)(&_xcprimeon_init_pdt[1024]) + (u64)(_PAGE_PRESENT | _PAGE_RW) ),
    ((u64)(&_xcprimeon_init_pdt[1536]) + (u64)(_PAGE_PRESENT | _PAGE_RW) ),
    0
};

__attribute__((aligned(4096))) static u64 _xcprimeon_init_pml4t[PAE_MAXPTRS_PER_PDPT] = {
    ((u64)(&_xcprimeon_init_pdpt) + (u64)(_PAGE_PRESENT | _PAGE_RW) ),
    0
};


__attribute__(( aligned(16) )) static u64 _xcprimeon_init_gdt_start[]  = {
	0x0000000000000000ULL,	//NULL descriptor
	0x00af9b000000ffffULL,	//CPL-0 64-bit code descriptor (CS64)
	0x00af93000000ffffULL,	//CPL-0 64-bit data descriptor (DS/SS/ES/FS/GS)
};

__attribute__(( aligned(16) )) static arch_x86_gdtdesc_t _xcprimeon_init_gdt  = {
	.size=sizeof(_xcprimeon_init_gdt_start)-1,
	.base=&_xcprimeon_init_gdt_start,
};


__attribute__((naked)) __attribute__ ((section(".hic_entrystub"))) __attribute__(( align(4096) )) void xcprimeon_arch_entry(void) {

	asm volatile (
                    ".code32 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 4096, 1, 0 \r\n"
					".fill 0x80, 1, 0x90\r\n" //TODO: should really be sizeof(mle_hdr_t)
					"_xcprimeon_start: \r\n"

					"movw %%ds, %%ax \r\n"
					"movw %%ax, %%es \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"

					"movl $0x10200000, %%esp \r\n" //TODO: get rid of hard-coded stack top

    				"movl %%cr4, %%eax \r\n"
   					"orl $0x00000030, %%eax \r\n"
   					"movl %%eax, %%cr4 \r\n"

                    "movl %0, %%eax \r\n"
                    "movl %%eax, %%cr3 \r\n"

                    "movl $0xc0000080, %%ecx \r\n"
                    "rdmsr \r\n"
                    "orl $0x00000100, %%eax \r\n"
                    "orl $0x00000800, %%eax \r\n"
                    "wrmsr \r\n"

                    "movl %%cr0, %%eax \r\n"
                    "orl $0x80000015, %%eax \r\n"
                    "movl %%eax, %%cr0 \r\n"

                    "movl %1, %%esi \r\n"
                    "lgdt (%%esi) \r\n"

                    "pushl $8 \r\n"
                    "pushl $_xcprimeon_start64 \r\n"
                    "lret \r\n"

                    ".code64 \r\n"
                    "_xcprimeon_start64: \r\n"

					"movw $0x10, %%ax \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"
					"movw %%ax, %%ds \r\n"
					"movw %%ax, %%es \r\n"

					"xorq %%rsp, %%rsp \r\n"
					"movl $0x10200000, %%esp \r\n" //TODO: get rid of hard-coded stack top

                    "jmp xmhfhic_entry \r\n"
			    :
			    : "i" (&_xcprimeon_init_pml4t), "i" (&_xcprimeon_init_gdt)
                :
	);
}





















/////////////////////////////////////////////////////////////////////////////
// relinquish HIC initialization and move on to the first slab
/*
void xcprimeon_arch_relinquish_control(void){

    asm volatile(
                 	"movl %0, %%eax\r\n"
					"movl (%%eax), %%eax\r\n"
					"shr $24, %%eax\r\n"
					"movl %2, %%ebx\r\n"
					"movl %1, %%ecx \r\n"
					"1: cmpl 0x0(%%ebx), %%eax\r\n"
					"jz 2f\r\n"
					"addl %3, %%ebx\r\n"
					"loop 1b \r\n"
					"hlt\r\n"								// we should never get here, if so just halt
					"2: movl 0x4(%%ebx), %%eax\r\n"			// eax = g_xc_cputable[ecx].cpu_index
					"movl %5, %%ecx \r\n"					// ecx = sizeof(_cpustack[0])
					"mull %%ecx \r\n"						// eax = sizeof(_cpustack[0]) * eax
					"addl %%ecx, %%eax \r\n"				// eax = (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"addl %4, %%eax \r\n"				    // eax = &_cpustack + (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"movl %%eax, %%esp \r\n"				// esp = top of stack for the cpu

					//"jmp xcsmp_interface \r\n"
					"hlt \r\n"
					:
					:   "i" (X86SMP_LAPIC_ID_MEMORYADDRESS), "m" (_totalcpus), "i" (&_cputable),
                        "i" (sizeof(xmhf_cputable_t)), "i" (&_init_cpustacks), "i" (sizeof(_init_cpustacks[0]))
	);

}*/























//////////////////////////////////////////////////////////////////////////////
//setup slab device allocation
typedef struct {
    __attribute__((aligned(4096))) vtd_slpgtbl_t _vtd_slpgtbl;
    bool initialized;
}__attribute__((packed)) xc_partitiondevicetable_t;

__attribute__((aligned(4096))) static  xc_partitiondevicetable_t _partitiondevtable[MAX_PRIMARY_PARTITIONS];

__attribute__((aligned(4096))) static vtd_ret_entry_t _vtd_ret[VTD_RET_MAXPTRS];
__attribute__((aligned(4096))) static vtd_cet_entry_t _vtd_cet[VTD_RET_MAXPTRS][VTD_CET_MAXPTRS];

static vtd_drhd_handle_t vtd_drhd_maxhandle=0;
static u32 vtd_pagewalk_level = VTD_PAGEWALK_NONE;
static bool vtd_initialized = false;

static u64 _platform_x86pc_vtd_setup_retcet(void){
    u32 i, j;

    for(i=0; i< VTD_RET_MAXPTRS; i++){
        _vtd_ret[i].qwords[0] = _vtd_ret[i].qwords[1] = 0ULL;
        _vtd_ret[i].fields.p = 1;
        _vtd_ret[i].fields.ctp = ((u64)&_vtd_cet[i] >> 12);

        for(j=0; j < VTD_CET_MAXPTRS; j++){
            _vtd_cet[i][j].qwords[0] = _vtd_cet[i][j].qwords[1] = 0ULL;
        }
    }

    return (u64)&_vtd_ret;
}

//initialize vtd hardware and setup vtd_drhd_maxhandle and _vtd_pagewalk_level
//to appropriate values. if everything went well set vtd_initialized to true
static bool _platform_x86pc_vtd_initialize(void){
    u64 vtd_ret_addr;
	vtd_drhd_handle_t drhd_handle;
	u32 vtd_dmar_table_physical_address=0;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i, b, d, f;

    //if we already setup vtd then simply return true
    if(vtd_initialized)
        return true;

    //initialize partition--device table
    for(i=0; i < MAX_PRIMARY_PARTITIONS; i++)
        _partitiondevtable[i].initialized = false;

	//setup basic RET/CET structure; will initially prevent DMA reads and writes
	//for the entire system
    vtd_ret_addr = _platform_x86pc_vtd_setup_retcet();

	//scan for available DRHD units in the platform
	if(!xmhfhw_platform_x86pc_vtd_scanfor_drhd_units(&vtd_drhd_maxhandle, &vtd_dmar_table_physical_address)){
        _XDPRINTF_("%s: unable to scan for DRHD units. bailing out!\n", __FUNCTION__);
		return false;
	}

    _XDPRINTF_("%s: maxhandle = %u, dmar table addr=0x%08x\n", __FUNCTION__,
                (u32)vtd_drhd_maxhandle, (u32)vtd_dmar_table_physical_address);

	//initialize all DRHD units
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
   		VTD_CAP_REG cap;

		_XDPRINTF_("%s: Setting up DRHD unit %u...\n", __FUNCTION__, drhd_handle);

		if(!xmhfhw_platform_x86pc_vtd_drhd_initialize(drhd_handle) ){
            _XDPRINTF_("%s: error setting up DRHD unit %u. bailing out!\n", __FUNCTION__, drhd_handle);
			return false;
		}

        //read and store DRHD supported page-walk length
        cap.value = xmhfhw_platform_x86pc_vtd_drhd_reg_read(drhd_handle, VTD_CAP_REG_OFF);
        if(cap.bits.sagaw & 0x2){
            if(vtd_pagewalk_level == VTD_PAGEWALK_NONE || vtd_pagewalk_level == VTD_PAGEWALK_3LEVEL){
                vtd_pagewalk_level = VTD_PAGEWALK_3LEVEL;
                _XDPRINTF_("%s: DRHD unit %u - 3-level page-walk\n", __FUNCTION__, drhd_handle);
            }else{
                _XDPRINTF_("%s: Halting: mixed hardware supported page-walk lengths\n",
                            __FUNCTION__);
                HALT();
            }
        }

        if(cap.bits.sagaw & 0x4){
            if(vtd_pagewalk_level == VTD_PAGEWALK_NONE || vtd_pagewalk_level == VTD_PAGEWALK_4LEVEL){
                vtd_pagewalk_level = VTD_PAGEWALK_4LEVEL;
                _XDPRINTF_("%s: DRHD unit %u - 4-level page-walk\n", __FUNCTION__, drhd_handle);
            }else{
                _XDPRINTF_("%s: Halting: mixed hardware supported page-walk lengths\n",
                            __FUNCTION__);
                HALT();
            }
        }


		//set DRHD root entry table
		if(!xmhfhw_platform_x86pc_vtd_drhd_set_root_entry_table(drhd_handle, vtd_ret_addr))
			return false;

		//invalidate caches
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;

		//enable VT-d translation
		xmhfhw_platform_x86pc_vtd_drhd_enable_translation(drhd_handle);

		//disable PMRs now (since DMA protection is active via translation)
		xmhfhw_platform_x86pc_vtd_drhd_disable_pmr(drhd_handle);

		_XDPRINTF_("%s: Successfully setup DRHD unit %u\n", __FUNCTION__, drhd_handle);
	}

	//zap VT-d presence in ACPI table...
	//TODO: we need to be a little elegant here. eventually need to setup
	//EPT/NPTs such that the DMAR pages are unmapped for the guest
	xmhfhw_sysmemaccess_writeu32(vtd_dmar_table_physical_address, 0UL);


    _XDPRINTF_("%s: final page-walk level=%u\n", __FUNCTION__, vtd_pagewalk_level);

    vtd_initialized = true;

    return true;
}

static vtd_slpgtbl_handle_t _platform_x86pc_vtd_setup_slpgtbl(u32 partition_index){
    vtd_slpgtbl_handle_t retval = {0, 0};
    u32 i, j, k, paddr=0;

    //sanity check partition index
    if(partition_index >= MAX_PRIMARY_PARTITIONS){
        _XDPRINTF_("%s: Error: partition_index >= MAX_PRIMARY_PARTITIONS. bailing out!\n", __FUNCTION__);
        return retval;
    }

    //setup device memory access for the partition
    _partitiondevtable[partition_index]._vtd_slpgtbl.pml4t[0].fields.r = 1;
    _partitiondevtable[partition_index]._vtd_slpgtbl.pml4t[0].fields.w = 1;
    _partitiondevtable[partition_index]._vtd_slpgtbl.pml4t[0].fields.slpdpt = ((u64)&_partitiondevtable[partition_index]._vtd_slpgtbl.pdpt >> 12);

    for(i=0; i < PAE_PTRS_PER_PDPT; i++){
        _partitiondevtable[partition_index]._vtd_slpgtbl.pdpt[i].fields.r = 1;
        _partitiondevtable[partition_index]._vtd_slpgtbl.pdpt[i].fields.w = 1;
        _partitiondevtable[partition_index]._vtd_slpgtbl.pdpt[i].fields.slpdt = ((u64)&_partitiondevtable[partition_index]._vtd_slpgtbl.pdt[i] >> 12);

        for(j=0; j < PAE_PTRS_PER_PDT; j++){
            _partitiondevtable[partition_index]._vtd_slpgtbl.pdt[i][j].fields.r = 1;
            _partitiondevtable[partition_index]._vtd_slpgtbl.pdt[i][j].fields.w = 1;
            _partitiondevtable[partition_index]._vtd_slpgtbl.pdt[i][j].fields.slpt = ((u64)&_partitiondevtable[partition_index]._vtd_slpgtbl.pt[i][j] >> 12);

            for(k=0; k < PAE_PTRS_PER_PT; k++){
                _partitiondevtable[partition_index]._vtd_slpgtbl.pt[i][j][k].fields.r = 1;
                _partitiondevtable[partition_index]._vtd_slpgtbl.pt[i][j][k].fields.w = 1;
                _partitiondevtable[partition_index]._vtd_slpgtbl.pt[i][j][k].fields.pageaddr = ((u64)paddr >> 12);
                paddr += PAGE_SIZE_4K;
            }
        }
    }

    retval.addr_vtd_pml4t = _partitiondevtable[partition_index]._vtd_slpgtbl.pml4t;
    retval.addr_vtd_pdpt = _partitiondevtable[partition_index]._vtd_slpgtbl.pdpt;

    return retval;
}

static xc_platformdevice_desc_t __xmhfhic_arch_initializeandenumeratedevices(context_desc_t context_desc){
    xc_platformdevice_desc_t result;
    u32 b, d, f;

    result.desc_valid = false;
    result.numdevices = 0;

    //initialize vtd hardware (if it has not been initialized already)
    if(!_platform_x86pc_vtd_initialize())
        return result;

    //enumerate PCI bus to find out all the devices
	//bus numbers range from 0-255, device from 0-31 and function from 0-7
	for(b=0; b < PCI_BUS_MAX; b++){
		for(d=0; d < PCI_DEVICE_MAX; d++){
			for(f=0; f < PCI_FUNCTION_MAX; f++){
				u32 vendor_id, device_id;

				//read device and vendor ids, if no device then both will be 0xFFFF
				xmhf_baseplatform_arch_x86_pci_type1_read(b, d, f, PCI_CONF_HDR_IDX_VENDOR_ID, sizeof(u16), &vendor_id);
				xmhf_baseplatform_arch_x86_pci_type1_read(b, d, f, PCI_CONF_HDR_IDX_DEVICE_ID, sizeof(u16), &device_id);
				if(vendor_id == 0xFFFF && device_id == 0xFFFF)
					break;

                result.arch_desc[result.numdevices].pci_bus=b;
                result.arch_desc[result.numdevices].pci_device=d;
                result.arch_desc[result.numdevices].pci_function=f;
                result.arch_desc[result.numdevices].vendor_id=vendor_id;
                result.arch_desc[result.numdevices].device_id=device_id;

                result.numdevices++;
			}
		}
	}

    result.desc_valid = true;
    return result;
}


static bool __xmhfhic_arch_allocdevices_to_partition(context_desc_t context_desc, xc_platformdevice_desc_t device_descs){
	vtd_drhd_handle_t drhd_handle;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i;

    if(!vtd_initialized)
        return false;


    //initialize partition device page tables (if it has not been initialized already)
    if(!_partitiondevtable[context_desc.partition_desc.partition_index].initialized){
        vtd_slpgtbl_handle = _platform_x86pc_vtd_setup_slpgtbl(context_desc.partition_desc.partition_index);

        if(vtd_slpgtbl_handle.addr_vtd_pml4t == 0 &&
            vtd_slpgtbl_handle.addr_vtd_pdpt == 0){
            _XDPRINTF_("%s: unable to initialize vt-d pagetables for partition %u\n", __FUNCTION__, context_desc.partition_desc.partition_index);
            return false;
        }

        _partitiondevtable[context_desc.partition_desc.partition_index].initialized = true;
    }


    for(i=0; i < device_descs.numdevices; i++){
        u32 b=device_descs.arch_desc[i].pci_bus;
        u32 d=device_descs.arch_desc[i].pci_device;
        u32 f=device_descs.arch_desc[i].pci_function;

        //sanity check b, d, f triad
        if ( !(b < PCI_BUS_MAX &&
               d < PCI_DEVICE_MAX &&
               f < PCI_FUNCTION_MAX) )
            return false;

        //b is our index into ret
        // (d* PCI_FUNCTION_MAX) + f = index into the cet
        if(vtd_pagewalk_level == VTD_PAGEWALK_4LEVEL){
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.slptptr = ((u64)_partitiondevtable[context_desc.partition_desc.partition_index]._vtd_slpgtbl.pml4t >> 12);
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.aw = 2; //4-level
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.did = (context_desc.partition_desc.partition_index + 1); //domain
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.p = 1; //present
        }else if (vtd_pagewalk_level == VTD_PAGEWALK_3LEVEL){
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.slptptr = ((u64)_partitiondevtable[context_desc.partition_desc.partition_index]._vtd_slpgtbl.pdpt >> 12);
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.aw = 1; //3-level
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.did = (context_desc.partition_desc.partition_index + 1); //domain
            _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].fields.p = 1; //present
        }else{ //unknown page walk length, fail
            return false;
        }
    }


	//invalidate vtd caches
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;
	}

    return true;
}


static bool __xmhfhic_arch_deallocdevices_from_partition(context_desc_t context_desc, xc_platformdevice_desc_t device_descs){
	vtd_drhd_handle_t drhd_handle;
    vtd_slpgtbl_handle_t vtd_slpgtbl_handle;
    u32 i;

    if(!vtd_initialized)
        return false;

    for(i=0; i < device_descs.numdevices; i++){
        u32 b=device_descs.arch_desc[i].pci_bus;
        u32 d=device_descs.arch_desc[i].pci_device;
        u32 f=device_descs.arch_desc[i].pci_function;

        //sanity check b, d, f triad
        if ( !(b < PCI_BUS_MAX &&
               d < PCI_DEVICE_MAX &&
               f < PCI_FUNCTION_MAX) )
            return false;

        //b is our index into ret
        // (d* PCI_FUNCTION_MAX) + f = index into the cet
        _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].qwords[0] = 0;
        _vtd_cet[b][((d*PCI_FUNCTION_MAX) + f)].qwords[1] = 0;
    }

	//invalidate vtd caches
	for(drhd_handle=0; drhd_handle < vtd_drhd_maxhandle; drhd_handle++){
		if(!xmhfhw_platform_x86pc_vtd_drhd_invalidatecaches(drhd_handle))
			return false;
	}

    return true;
}


static bool __xmhfhic_dev_arch_initialize(u32 partition_index){
    u32 i;
    xc_platformdevice_desc_t ddescs;
    context_desc_t ctx;

    ctx.cpu_desc.cpu_index = 0;
    ctx.cpu_desc.isbsp = true;
    ctx.partition_desc.partition_index = partition_index;

    ddescs = __xmhfhic_arch_initializeandenumeratedevices(ctx);

    if(!ddescs.desc_valid){
        _XDPRINTF_("%s: Error: could not obtain platform device descriptors\n",
                    __FUNCTION__);
        return false;
    }

    for(i=0; i < ddescs.numdevices; i++){
        _XDPRINTF_("  %02x:%02x.%1x -> vendor_id=%04x, device_id=%04x\n", ddescs.arch_desc[i].pci_bus,
          ddescs.arch_desc[i].pci_device, ddescs.arch_desc[i].pci_function,
          ddescs.arch_desc[i].vendor_id, ddescs.arch_desc[i].device_id);
    }

    if(!__xmhfhic_arch_allocdevices_to_partition(ctx, ddescs)){
            _XDPRINTF_("%s: Halting.unable to allocate devices to partition %u\n",
                        __FUNCTION__, partition_index);
            HALT();
    }

    return true;
}


static void __xmhfhic_x86vmxx86pc_postdrt(void){
	txt_heap_t *txt_heap;
	os_mle_data_t *os_mle_data;

	txt_heap = get_txt_heap();
	_XDPRINTF_("SL: txt_heap = 0x%08x\n", (u32)txt_heap);
	os_mle_data = get_os_mle_data_start((txt_heap_t*)((u32)txt_heap));
	_XDPRINTF_("SL: os_mle_data = 0x%08x\n", (u32)os_mle_data);

	// restore pre-SENTER MTRRs that were overwritten for SINIT launch
	if(!validate_mtrrs(&(os_mle_data->saved_mtrr_state))) {
		_XDPRINTF_("SECURITY FAILURE: validate_mtrrs() failed.\n");
		HALT();
	}
	_XDPRINTF_("SL: Validated MTRRs\n");

	xmhfhw_cpu_x86_restore_mtrrs(&(os_mle_data->saved_mtrr_state));
    _XDPRINTF_("SL: Restored MTRRs\n");
}




void xmhfhic_arch_setup_slab_device_allocation(void){

#if defined (__DRT__)
    //post DRT cleanup first
    __xmhfhic_x86vmxx86pc_postdrt();
#endif	//__DRT__

	//initialize platform bus
	xmhfhw_platform_bus_init();

	//check ACPI subsystem
	{
		ACPI_RSDP rsdp;
		if(!xmhfhw_platform_x86pc_acpi_getRSDP(&rsdp)){
			_XDPRINTF_("%s: ACPI RSDP not found, Halting!\n", __FUNCTION__);
			HALT();
		}
	}

    //initialize devices and allocate everything to the rich guest for now
    __xmhfhic_dev_arch_initialize(0);


}





















//////////////////////////////////////////////////////////////////////////////
// setup hypervisor slab page tables


__attribute__((aligned(4096))) static struct {
    u64 pml4t[PAE_MAXPTRS_PER_PML4T] __attribute__(( aligned(4096) ));
	u64 pdpt[PAE_MAXPTRS_PER_PDPT] __attribute__(( aligned(4096) ));
	u64 pdt[PAE_PTRS_PER_PDPT][PAE_PTRS_PER_PDT] __attribute__(( aligned(4096) ));
} _slab_pagetables[XMHF_HIC_HYP_SLABS_COUNT];


#define	_SLAB_SPATYPE_OTHER_SLAB_MASK			(0xF0)

#define	_SLAB_SPATYPE_OTHER_SLAB_CODE			(0xF0)
#define	_SLAB_SPATYPE_OTHER_SLAB_RODATA			(0xF1)
#define _SLAB_SPATYPE_OTHER_SLAB_RWDATA			(0xF2)
#define _SLAB_SPATYPE_OTHER_SLAB_STACK			(0xF3)

#define	_SLAB_SPATYPE_SLAB_CODE					(0x0)
#define	_SLAB_SPATYPE_SLAB_RODATA				(0x1)
#define _SLAB_SPATYPE_SLAB_RWDATA				(0x2)
#define _SLAB_SPATYPE_SLAB_STACK				(0x3)

#define _SLAB_SPATYPE_SLAB_TRAMPOLINE			(0x4)

#define _SLAB_SPATYPE_NOTASLAB					(0xFF00)

static u32 __xmhfhic_hyp_slab_getspatype(u32 slab_index, u32 spa){
/*	u32 i;

	//slab memory regions
	for(i=0; i < XMHF_SLAB_NUMBEROFSLABS; i++){
		u32 mask = (i == slab_index) ? 0 : _SLAB_SPATYPE_OTHER_SLAB_MASK;

		if(spa >= _slab_table[i].slab_code.start  && spa < _slab_table[i].slab_code.end)
			return _SLAB_SPATYPE_SLAB_CODE | mask;
		if (spa >= _slab_table[i].slab_rodata.start  && spa < _slab_table[i].slab_rodata.end)
			return _SLAB_SPATYPE_SLAB_RODATA | mask;
		if (spa >= _slab_table[i].slab_rwdata.start  && spa < _slab_table[i].slab_rwdata.end)
			return _SLAB_SPATYPE_SLAB_RWDATA | mask;
		if (spa >= _slab_table[i].slab_stack.start  && spa < _slab_table[i].slab_stack.end)
			return _SLAB_SPATYPE_SLAB_STACK | mask;
	}

	//slab shared data region
	//TODO: add per shared data variable access policy rather than entire section
	if(spa >= (u32)_slab_shareddata_memregion_start && spa < (u32)_slab_shareddata_memregion_end){
			if (slab_index == XMHF_SLAB_XCPRIMEON_INDEX || slab_index == XMHF_SLAB_XCSMP_INDEX || slab_index == XMHF_SLAB_XCEXHUB_INDEX)
				return _SLAB_SPATYPE_SLAB_RWDATA; //map read-write in initbs (GDT,TSS setup) and xcexhub (IDT setup)
			else
				return _SLAB_SPATYPE_SLAB_RODATA; //map read-only in all other slabs
	}

	//slab trampoline region
	if(spa >= (u32)_slab_trampoline_memregion_start && spa < (u32)_slab_trampoline_memregion_end){
			return _SLAB_SPATYPE_SLAB_TRAMPOLINE; //map read-only in all slabs
	}
*/

	return _SLAB_SPATYPE_NOTASLAB;
}

static u64 __xmhfhic_hyp_slab_getptflagsforspa(u32 slab_index, u32 spa){
	u64 flags;
/*	u32 spatype = _xcprimeon_slab_getspatype(slab_index, spa);
	//_XDPRINTF_("\n%s: slab_index=%u, spa=%08x, spatype = %x\n", __FUNCTION__, slab_index, spa, spatype);

	switch(spatype){
		case _SLAB_SPATYPE_OTHER_SLAB_CODE:
		case _SLAB_SPATYPE_OTHER_SLAB_RODATA:
		case _SLAB_SPATYPE_OTHER_SLAB_RWDATA:
			flags = 0;	//not-present
			break;
		case _SLAB_SPATYPE_OTHER_SLAB_STACK:
			//flags = (u64)(_PAGE_PRESENT | _PAGE_PSE | _PAGE_NX); //present | read-only | no execute | pse
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE | _PAGE_NX); //present | read-write | no execute | pse
			break;

		case _SLAB_SPATYPE_SLAB_CODE:
			flags = (u64)(_PAGE_PRESENT | _PAGE_PSE); // present | read-only | pse
			break;
		case _SLAB_SPATYPE_SLAB_RODATA:
			flags = (u64)(_PAGE_PRESENT | _PAGE_PSE | _PAGE_NX); //present | read-only | no-execute | pse
			break;
		case _SLAB_SPATYPE_SLAB_RWDATA:
		case _SLAB_SPATYPE_SLAB_STACK:
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_NX | _PAGE_PSE); //present | read-write | no-execute | pse
			break;

		case _SLAB_SPATYPE_SLAB_TRAMPOLINE:
			flags = (u64)(_PAGE_PRESENT | _PAGE_PSE); //present | read-only | pse;
			break;

		default:
			flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE | _PAGE_USER);
			if(spa == 0xfee00000 || spa == 0xfec00000) {
				//map some MMIO regions with Page Cache disabled
				//0xfed00000 contains Intel TXT config regs & TPM MMIO
				//0xfee00000 contains LAPIC base
				flags |= (u64)(_PAGE_PCD);
			}
			break;
	}*/

	flags = (u64)(_PAGE_PRESENT | _PAGE_RW | _PAGE_PSE | _PAGE_USER);
			if(spa == 0xfee00000 || spa == 0xfec00000) {
				//map some MMIO regions with Page Cache disabled
				//0xfed00000 contains Intel TXT config regs & TPM MMIO
				//0xfee00000 contains LAPIC base
				flags |= (u64)(_PAGE_PCD);
			}

	return flags;
}

//
// initialize slab page tables for a given slab index, returns the macm base
static u32 __xmhfhic_hyp_slab_populate_pagetables(u32 slab_index){
		u32 i, j;
		u64 default_flags = (u64)(_PAGE_PRESENT) | (u64)(_PAGE_USER) | (u64)(_PAGE_RW);

        for(i=0; i < PAE_PTRS_PER_PML4T; i++)
            _slab_pagetables[slab_index].pml4t[i] = pae_make_pml4e(hva2spa(&_slab_pagetables[slab_index].pdpt), default_flags);

		for(i=0; i < PAE_PTRS_PER_PDPT; i++)
			_slab_pagetables[slab_index].pdpt[i] = pae_make_pdpe(hva2spa(_slab_pagetables[slab_index].pdt[i]), default_flags);

		//init pdts with unity mappings
		for(i=0; i < PAE_PTRS_PER_PDPT; i++){
			for(j=0; j < PAE_PTRS_PER_PDT; j++){
				u32 hva = ((i * PAE_PTRS_PER_PDT) + j) * PAGE_SIZE_2M;
				u64 spa = hva2spa((void*)hva);
				u64 flags = __xmhfhic_hyp_slab_getptflagsforspa(slab_index, (u32)spa);
				_slab_pagetables[slab_index].pdt[i][j] = pae_make_pde_big(spa, flags);
				//debug
				//if(slab_index == XMHF_SLAB_TESTSLAB1_INDEX && (spa >=0x10000000 && spa < 0x20000000) )
				//	_XDPRINTF_("  hva/spa=%08x, flags=%08x\n", (u32)spa, (u32)flags);
			}
		}

		return (u32)_slab_pagetables[slab_index].pml4t | (u32)(slab_index+1);
}


// initialization function for the core API interface
void __xmhfhic_arch_initialize_slab_tables(void){
	u32 pgtblbase;

	_XDPRINTF_("%s: starting...\n", __FUNCTION__);

	//[debug]
	{
		u32 i;
		for(i=0; i < XMHF_HIC_HYP_SLABS_COUNT; i++){
				_XDPRINTF_("slab %u: pdpt=%08x, pdt[0]=%08x, pdt[1]=%08x\n", i, (u32)_slab_pagetables[i].pdpt, (u32)_slab_pagetables[i].pdt[0], (u32)_slab_pagetables[i].pdt[1]);
				_XDPRINTF_("                    pdt[2]=%08x, pdt[3]=%08x\n", (u32)_slab_pagetables[i].pdt[2], (u32)_slab_pagetables[i].pdt[3]);
		}

	}

	//setup slab page tables and macm id's
	{
		u32 i;
		for(i=0; i < XMHF_HIC_HYP_SLABS_COUNT; i++)
			_slab_table[i].slab_macmid = __xmhfhic_hyp_slab_populate_pagetables(i);

	}

	_XDPRINTF_("%s: setup slab page tables and macm id's\n", __FUNCTION__);


}



void xmhfhic_arch_setup_hypervisor_slab_page_tables(void){

	//print out hypervisor slab table
	{
			u32 i;

			for(i=0; i < XMHF_HIC_HYP_SLABS_COUNT; i++){
				_XDPRINTF_("slab %u: dumping slab header\n", i);
				_XDPRINTF_("	slab_index=%u\n", _slab_table[i].slab_index);
				_XDPRINTF_("	slab_macmid=%08x\n", _slab_table[i].slab_macmid);
				_XDPRINTF_("	slab_privilegemask=%08x\n", _slab_table[i].slab_privilegemask);
				_XDPRINTF_("	slab_tos=%08x\n", _slab_table[i].slab_tos);
				_XDPRINTF_("  slab_rodata(%08x-%08x)\n", _slab_table[i].slab_rodata.start, _slab_table[i].slab_rodata.end);
				_XDPRINTF_("  slab_rwdata(%08x-%08x)\n", _slab_table[i].slab_rwdata.start, _slab_table[i].slab_rwdata.end);
				_XDPRINTF_("  slab_code(%08x-%08x)\n", _slab_table[i].slab_code.start, _slab_table[i].slab_code.end);
				_XDPRINTF_("  slab_stack(%08x-%08x)\n", _slab_table[i].slab_stack.start, _slab_table[i].slab_stack.end);
				//_XDPRINTF_("\n  slab_trampoline(%08x-%08x)", _slab_table[i].slab_trampoline.start, _slab_table[i].slab_trampoline.end);
				_XDPRINTF_("  slab_entrycr3=%08x\n", _slab_table[i].entry_cr3);
				_XDPRINTF_("  slab_entrycr3_new=%08x\n", _slab_table[i].entry_cr3_new);
		}
	}


    __xmhfhic_arch_initialize_slab_tables();

}





















///////////////////////////////////////////////////////////////////////////
// setup guest slab page tables
__attribute__((aligned(4096))) static xc_partition_hptdata_x86vmx_t _hpt_data[XMHF_HIC_GUEST_SLABS_COUNT];
static struct _memorytype _vmx_ept_memorytypes[MAX_MEMORYTYPE_ENTRIES]; //EPT memory types array

static void __xmhfhic_vmx_gathermemorytypes(void);
static u32 __xmhfhic_vmx_getmemorytypeforphysicalpage(u64 pagebaseaddr);
static void __xmhfhic_vmx_setupEPT(u64 guestslab_id);


static void __xmhfhic_guestpgtbl_setentry(u64 guestslab_id,  u64 gpa, u64 entry){
    u64 *hpt = (u64 *)_hpt_data[guestslab_id].vmx_ept_p_tables;
		u32 hpt_index = (u32)gpa / PAGE_SIZE_4K;

		hpt[hpt_index] = entry;

	return;
}

static void __xmhfhic_guestpgtbl_establishshape(u64 guestslab_id){
	u64 *pml4_table, *pdp_table, *pd_table;
	u32 i, j, paddr=0;

	pml4_table = (u64 *)_hpt_data[guestslab_id].vmx_ept_pml4_table;
	pml4_table[0] = (u64) (hva2spa((void*)_hpt_data[guestslab_id].vmx_ept_pdp_table) | 0x7);

	pdp_table = (u64 *)_hpt_data[guestslab_id].vmx_ept_pdp_table;

	for(i=0; i < PAE_PTRS_PER_PDPT; i++){
		pdp_table[i] = (u64) ( hva2spa((void*)_hpt_data[guestslab_id].vmx_ept_pd_tables + (PAGE_SIZE_4K * i)) | 0x7 );
		pd_table = (u64 *)  ((u32)_hpt_data[guestslab_id].vmx_ept_pd_tables + (PAGE_SIZE_4K * i)) ;

		for(j=0; j < PAE_PTRS_PER_PDT; j++){
			pd_table[j] = (u64) ( hva2spa((void*)_hpt_data[guestslab_id].vmx_ept_p_tables + (PAGE_SIZE_4K * ((i*PAE_PTRS_PER_PDT)+j))) | 0x7 );
		}
	}
}



//---gather memory types for system physical memory------------------------------
static void __xmhfhic_vmx_gathermemorytypes(void){
 	u32 eax, ebx, ecx, edx;
	u32 index=0;
	u32 num_vmtrrs=0;	//number of variable length MTRRs supported by the CPU

	//0. sanity check
  	//check MTRR support
  	eax=0x00000001;
  	ecx=0x00000000;
	#ifndef __XMHF_VERIFICATION__
  	asm volatile ("cpuid\r\n"
            :"=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
            :"a"(eax), "c" (ecx));
  	#endif

  	if( !(edx & (u32)(1 << 12)) ){
  		_XDPRINTF_("\n%s: CPU does not support MTRRs!", __FUNCTION__);
  		HALT();
  	}

  	//check MTRR caps
  	rdmsr(IA32_MTRRCAP, &eax, &edx);
	num_vmtrrs = (u8)eax;
  	_XDPRINTF_("\nIA32_MTRRCAP: VCNT=%u, FIX=%u, WC=%u, SMRR=%u",
  		num_vmtrrs, ((eax & (1 << 8)) >> 8),  ((eax & (1 << 10)) >> 10),
  			((eax & (1 << 11)) >> 11));
	//sanity check that fixed MTRRs are supported
  	HALT_ON_ERRORCOND( ((eax & (1 << 8)) >> 8) );
  	//ensure number of variable MTRRs are within the maximum supported
  	HALT_ON_ERRORCOND( (num_vmtrrs <= MAX_VARIABLE_MEMORYTYPE_ENTRIES) );


	#ifndef __XMHF_VERIFICATION__
	//1. clear memorytypes array
	memset((void *)&_vmx_ept_memorytypes, 0, sizeof(struct _memorytype) * MAX_MEMORYTYPE_ENTRIES);
	#endif

	//2. grab memory types using FIXED MTRRs
    //0x00000000-0x0007FFFF
    rdmsr(IA32_MTRR_FIX64K_00000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x00000000; _vmx_ept_memorytypes[index].endaddr = 0x0000FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00010000; _vmx_ept_memorytypes[index].endaddr = 0x0001FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00020000; _vmx_ept_memorytypes[index].endaddr = 0x0002FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x00030000; _vmx_ept_memorytypes[index].endaddr = 0x0003FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x00040000; _vmx_ept_memorytypes[index].endaddr = 0x0004FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00050000; _vmx_ept_memorytypes[index].endaddr = 0x0005FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00060000; _vmx_ept_memorytypes[index].endaddr = 0x0006FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x00070000; _vmx_ept_memorytypes[index].endaddr = 0x0007FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x00080000-0x0009FFFF
  	rdmsr(IA32_MTRR_FIX16K_80000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x00080000; _vmx_ept_memorytypes[index].endaddr = 0x00083FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00084000; _vmx_ept_memorytypes[index].endaddr = 0x00087FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00088000; _vmx_ept_memorytypes[index].endaddr = 0x0008BFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x0008C000; _vmx_ept_memorytypes[index].endaddr = 0x0008FFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x00090000; _vmx_ept_memorytypes[index].endaddr = 0x00093FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x00094000; _vmx_ept_memorytypes[index].endaddr = 0x00097FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x00098000; _vmx_ept_memorytypes[index].endaddr = 0x0009BFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x0009C000; _vmx_ept_memorytypes[index].endaddr = 0x0009FFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000A0000-0x000BFFFF
	  rdmsr(IA32_MTRR_FIX16K_A0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000A0000; _vmx_ept_memorytypes[index].endaddr = 0x000A3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000A4000; _vmx_ept_memorytypes[index].endaddr = 0x000A7FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000A8000; _vmx_ept_memorytypes[index].endaddr = 0x000ABFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000AC000; _vmx_ept_memorytypes[index].endaddr = 0x000AFFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000B0000; _vmx_ept_memorytypes[index].endaddr = 0x000B3FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000B4000; _vmx_ept_memorytypes[index].endaddr = 0x000B7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000B8000; _vmx_ept_memorytypes[index].endaddr = 0x000BBFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000BC000; _vmx_ept_memorytypes[index].endaddr = 0x000BFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000C0000-0x000C7FFF
    rdmsr(IA32_MTRR_FIX4K_C0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000C0000; _vmx_ept_memorytypes[index].endaddr = 0x000C0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C1000; _vmx_ept_memorytypes[index].endaddr = 0x000C1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000C2000; _vmx_ept_memorytypes[index].endaddr = 0x000C2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000C3000; _vmx_ept_memorytypes[index].endaddr = 0x000C3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000C4000; _vmx_ept_memorytypes[index].endaddr = 0x000C4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C5000; _vmx_ept_memorytypes[index].endaddr = 0x000C5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000C6000; _vmx_ept_memorytypes[index].endaddr = 0x000C6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000C7000; _vmx_ept_memorytypes[index].endaddr = 0x000C7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000C8000-0x000C8FFF
	  rdmsr(IA32_MTRR_FIX4K_C8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000C8000; _vmx_ept_memorytypes[index].endaddr = 0x000C8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000C9000; _vmx_ept_memorytypes[index].endaddr = 0x000C9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000CA000; _vmx_ept_memorytypes[index].endaddr = 0x000CAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000CB000; _vmx_ept_memorytypes[index].endaddr = 0x000CBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000CC000; _vmx_ept_memorytypes[index].endaddr = 0x000CCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000CD000; _vmx_ept_memorytypes[index].endaddr = 0x000CDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000CE000; _vmx_ept_memorytypes[index].endaddr = 0x000CEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000CF000; _vmx_ept_memorytypes[index].endaddr = 0x000CFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000D0000-0x000D7FFF
    rdmsr(IA32_MTRR_FIX4K_D0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000D0000; _vmx_ept_memorytypes[index].endaddr = 0x000D0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D1000; _vmx_ept_memorytypes[index].endaddr = 0x000D1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000D2000; _vmx_ept_memorytypes[index].endaddr = 0x000D2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000D3000; _vmx_ept_memorytypes[index].endaddr = 0x000D3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000D4000; _vmx_ept_memorytypes[index].endaddr = 0x000D4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D5000; _vmx_ept_memorytypes[index].endaddr = 0x000D5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000D6000; _vmx_ept_memorytypes[index].endaddr = 0x000D6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000D7000; _vmx_ept_memorytypes[index].endaddr = 0x000D7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000D8000-0x000DFFFF
  	rdmsr(IA32_MTRR_FIX4K_D8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000D8000; _vmx_ept_memorytypes[index].endaddr = 0x000D8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000D9000; _vmx_ept_memorytypes[index].endaddr = 0x000D9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000DA000; _vmx_ept_memorytypes[index].endaddr = 0x000DAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000DB000; _vmx_ept_memorytypes[index].endaddr = 0x000DBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000DC000; _vmx_ept_memorytypes[index].endaddr = 0x000DCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000DD000; _vmx_ept_memorytypes[index].endaddr = 0x000DDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000DE000; _vmx_ept_memorytypes[index].endaddr = 0x000DEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000DF000; _vmx_ept_memorytypes[index].endaddr = 0x000DFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000E0000-0x000E7FFF
    rdmsr(IA32_MTRR_FIX4K_E0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000E0000; _vmx_ept_memorytypes[index].endaddr = 0x000E0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E1000; _vmx_ept_memorytypes[index].endaddr = 0x000E1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000E2000; _vmx_ept_memorytypes[index].endaddr = 0x000E2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000E3000; _vmx_ept_memorytypes[index].endaddr = 0x000E3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000E4000; _vmx_ept_memorytypes[index].endaddr = 0x000E4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E5000; _vmx_ept_memorytypes[index].endaddr = 0x000E5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000E6000; _vmx_ept_memorytypes[index].endaddr = 0x000E6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000E7000; _vmx_ept_memorytypes[index].endaddr = 0x000E7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000E8000-0x000EFFFF
	  rdmsr(IA32_MTRR_FIX4K_E8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000E8000; _vmx_ept_memorytypes[index].endaddr = 0x000E8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000E9000; _vmx_ept_memorytypes[index].endaddr = 0x000E9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000EA000; _vmx_ept_memorytypes[index].endaddr = 0x000EAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000EB000; _vmx_ept_memorytypes[index].endaddr = 0x000EBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000EC000; _vmx_ept_memorytypes[index].endaddr = 0x000ECFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000ED000; _vmx_ept_memorytypes[index].endaddr = 0x000EDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000EE000; _vmx_ept_memorytypes[index].endaddr = 0x000EEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000EF000; _vmx_ept_memorytypes[index].endaddr = 0x000EFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000F0000-0x000F7FFF
  	rdmsr(IA32_MTRR_FIX4K_F0000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000F0000; _vmx_ept_memorytypes[index].endaddr = 0x000F0FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F1000; _vmx_ept_memorytypes[index].endaddr = 0x000F1FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000F2000; _vmx_ept_memorytypes[index].endaddr = 0x000F2FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000F3000; _vmx_ept_memorytypes[index].endaddr = 0x000F3FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000F4000; _vmx_ept_memorytypes[index].endaddr = 0x000F4FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F5000; _vmx_ept_memorytypes[index].endaddr = 0x000F5FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000F6000; _vmx_ept_memorytypes[index].endaddr = 0x000F6FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000F7000; _vmx_ept_memorytypes[index].endaddr = 0x000F7FFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);
    //0x000F8000-0x000FFFFF
  	rdmsr(IA32_MTRR_FIX4K_F8000, &eax, &edx);
    _vmx_ept_memorytypes[index].startaddr = 0x000F8000; _vmx_ept_memorytypes[index].endaddr = 0x000F8FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000F9000; _vmx_ept_memorytypes[index].endaddr = 0x000F9FFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000FA000; _vmx_ept_memorytypes[index].endaddr = 0x000FAFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000FB000; _vmx_ept_memorytypes[index].endaddr = 0x000FBFFF; _vmx_ept_memorytypes[index++].type= ((eax & 0xFF000000) >> 24);
    _vmx_ept_memorytypes[index].startaddr = 0x000FC000; _vmx_ept_memorytypes[index].endaddr = 0x000FCFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x000000FF) >> 0);
    _vmx_ept_memorytypes[index].startaddr = 0x000FD000; _vmx_ept_memorytypes[index].endaddr = 0x000FDFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x0000FF00) >> 8);
    _vmx_ept_memorytypes[index].startaddr = 0x000FE000; _vmx_ept_memorytypes[index].endaddr = 0x000FEFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0x00FF0000) >> 16);
    _vmx_ept_memorytypes[index].startaddr = 0x000FF000; _vmx_ept_memorytypes[index].endaddr = 0x000FFFFF; _vmx_ept_memorytypes[index++].type= ((edx & 0xFF000000) >> 24);


	//3. grab memory types using variable length MTRRs
	{
		u64 paddrmask = 0x0000000FFFFFFFFFULL; //36-bits physical address, TODO: need to make this dynamic
		u64 vMTRR_base, vMTRR_mask;
		u32 msrval=IA32_MTRR_PHYSBASE0;
		u32 i;

		for(i=0; i < num_vmtrrs; i++){
			rdmsr(msrval, &eax, &edx);
			vMTRR_base = ((u64)edx << 32) | (u64)eax;
			msrval++;
			rdmsr(msrval, &eax, &edx);
			vMTRR_mask = ((u64)edx << 32) | (u64)eax;
			msrval++;
			if( (vMTRR_mask & ((u64)1 << 11)) ){
				_vmx_ept_memorytypes[index].startaddr = (vMTRR_base & (u64)0xFFFFFFFFFFFFF000ULL);
				_vmx_ept_memorytypes[index].endaddr = (vMTRR_base & (u64)0xFFFFFFFFFFFFF000ULL) +
					(u64) (~(vMTRR_mask & (u64)0xFFFFFFFFFFFFF000ULL) &
						paddrmask);
				_vmx_ept_memorytypes[index++].type = ((u32)vMTRR_base & (u32)0x000000FF);
			}else{
				_vmx_ept_memorytypes[index++].invalid = 1;
			}
		}
	}

	_XDPRINTF_("\n%s: gathered MTRR details, number of entries=%u", __FUNCTION__, index);
	HALT_ON_ERRORCOND( index <= (MAX_MEMORYTYPE_ENTRIES+1) );

  //[debug: dump the contents of _vmx_ept_memorytypes]
  //{
  //  int i;
  //  for(i=0; i < MAX_MEMORYTYPE_ENTRIES; i++){
  //    _XDPRINTF_("\nrange  0x%016llx-0x%016llx (type=%u)",
  //      _vmx_ept_memorytypes[i].startaddr, _vmx_ept_memorytypes[i].endaddr, _vmx_ept_memorytypes[i].type);
  //  }
  //}


}

//---get memory type for a given physical page address--------------------------
//
//11.11.4.1 MTRR Precedences
//  0. if MTRRs are not enabled --> MTRR_TYPE_UC
//  if enabled then
     //if physaddr < 1MB use fixed MTRR ranges return type
     //else if within a valid variable range MTRR then
        //if a single match, return type
        //if two or more and one is UC, return UC
        //if two or more and WB and WT, return WT
        //else invalid combination
     //else
       // return default memory type
//
static u32 __xmhfhic_vmx_getmemorytypeforphysicalpage(u64 pagebaseaddr){
 int i;
 u32 prev_type= MTRR_TYPE_RESV;

  //check if page base address under 1M, if so used FIXED MTRRs
  if(pagebaseaddr < (1024*1024)){
    for(i=0; i < MAX_FIXED_MEMORYTYPE_ENTRIES; i++){
      if( pagebaseaddr >= _vmx_ept_memorytypes[i].startaddr && (pagebaseaddr+PAGE_SIZE_4K-1) <= _vmx_ept_memorytypes[i].endaddr )
        return _vmx_ept_memorytypes[i].type;
    }

    _XDPRINTF_("\n%s: endaddr < 1M and unmatched fixed MTRR. Halt!", __FUNCTION__);
    HALT();
  }

  //page base address is above 1M, use VARIABLE MTRRs
  for(i= MAX_FIXED_MEMORYTYPE_ENTRIES; i < MAX_MEMORYTYPE_ENTRIES; i++){
    if( pagebaseaddr >= _vmx_ept_memorytypes[i].startaddr && (pagebaseaddr+PAGE_SIZE_4K-1) <= _vmx_ept_memorytypes[i].endaddr &&
          (!_vmx_ept_memorytypes[i].invalid) ){
       if(_vmx_ept_memorytypes[i].type == MTRR_TYPE_UC){
        prev_type = MTRR_TYPE_UC;
       }else if(_vmx_ept_memorytypes[i].type == MTRR_TYPE_WT && prev_type != MTRR_TYPE_UC){
        prev_type = MTRR_TYPE_WT;
       }else{
        if(prev_type != MTRR_TYPE_UC && prev_type != MTRR_TYPE_WT){
          if(prev_type == MTRR_TYPE_RESV){
            prev_type = _vmx_ept_memorytypes[i].type;
          }else{
            _XDPRINTF_("\nprev_type=%u, _vmx_ept_memorytypes=%u", prev_type, _vmx_ept_memorytypes[i].type);
            HALT_ON_ERRORCOND ( prev_type == _vmx_ept_memorytypes[i].type);
          }
        }
       }
    }
  }

  if(prev_type == MTRR_TYPE_RESV)
    prev_type = MTRR_TYPE_WB; //todo: need to dynamically get the default MTRR (usually WB)

  return prev_type;
}


//---setup EPT for VMX----------------------------------------------------------
static void __xmhfhic_vmx_setupEPT(u64 guestslab_id){
	u64 p_table_value;
	u64 gpa;
    slab_retval_t srval;

	for(gpa=0; gpa < ADDR_4GB; gpa += PAGE_SIZE_4K){
		u32 memorytype = __xmhfhic_vmx_getmemorytypeforphysicalpage((u64)gpa);
		//make XMHF physical pages inaccessible
		if( (gpa >= (xcbootinfo->physmem_base)) &&
			(gpa < (xcbootinfo->physmem_base + xcbootinfo->size)) ){
			p_table_value = (u64) (gpa)  | ((u64)memorytype << 3) | (u64)0x0 ;	//not-present
		}else{
			if(memorytype == 0)
				p_table_value = (u64) (gpa)  | ((u64)memorytype << 3) |  (u64)0x7 ;	//present, UC
			else
				p_table_value = (u64) (gpa)  | ((u64)6 << 3) | (u64)0x7 ;	//present, WB, track host MTRR
		}

        __xmhfhic_guestpgtbl_setentry(guestslab_id, gpa, p_table_value);

	}
}


void xmhfhic_arch_setup_guest_slab_page_tables(void){

    __xmhfhic_vmx_gathermemorytypes();

    __xmhfhic_guestpgtbl_establishshape(0);

	__xmhfhic_vmx_setupEPT(0);

}




















//////////////////////////////////////////////////////////////////////////////
// switch to smp

static bool __xmhfhic_ap_entry(void) __attribute__((naked));
static void __xmhfhic_smp_cpu_x86_smpinitialize_commonstart(void);
static u64 _xcsmp_ap_entry_lock = 1;
static mtrr_state_t _mtrrs;
static u64 _ap_cr3=0;

__attribute__(( aligned(16) )) static u64 _xcsmp_ap_init_gdt_start[]  = {
	0x0000000000000000ULL,	//NULL descriptor
	0x00af9b000000ffffULL,	//CPL-0 64-bit code descriptor (CS64)
	0x00af93000000ffffULL,	//CPL-0 64-bit data descriptor (DS/SS/ES/FS/GS)
};

__attribute__(( aligned(16) )) static arch_x86_gdtdesc_t _xcsmp_ap_init_gdt  = {
	.size=sizeof(_xcsmp_ap_init_gdt_start)-1,
	.base=&_xcsmp_ap_init_gdt_start,
};

__attribute__((naked)) static void _ap_bootstrap_code(void) {

    asm volatile (
           " .code32 \r\n"
           " movw %0, %%ax \r\n"
           " movw %%ax, %%ds \r\n"

           " movl %1, %%ebx \r\n"
           " movl (%%ebx), %%ebx \r\n"

           " jmpl *%%ebx \r\n"
           " hlt \r\n"
           " .balign 4096 \r\n"
           ".code64"
            :
            : "i" (__DS_CPL0),
              "i" ((X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_entrypoint))
            :

        );
}


static void __xmhfhic_smp_cpu_x86_savecpumtrrstate(void){
	xmhfhw_cpu_x86_save_mtrrs(&_mtrrs);
}

static void __xmhfhic_smp_cpu_x86_restorecpumtrrstate(void){
	xmhfhw_cpu_x86_restore_mtrrs(&_mtrrs);
}


//wake up APs using the LAPIC by sending the INIT-SIPI-SIPI IPI sequence
static void __xmhfhic_smp_cpu_x86_wakeupAPs(void){
	u32 eax, edx;
	volatile u32 *icr;

	//read LAPIC base address from MSR
	rdmsr(MSR_APIC_BASE, &eax, &edx);
	HALT_ON_ERRORCOND( edx == 0 ); //APIC is below 4G

	//construct the command register address (offset 0x300)
	icr = (u32 *) (((u32)eax & 0xFFFFF000UL) + 0x300);

	//our AP boot-strap code is at physical memory location 0x10000.
	//so use 0x10 as the vector (0x10000/0x1000 = 0x10)

	//send INIT
	*icr = 0x000c4500UL;

	xmhf_baseplatform_arch_x86_udelay(10000);

	//wait for command completion
	{
		u32 val;
		do{
		  val = *icr;
		}while( (val & 0x1000) );
	}

	//send SIPI (twice as per the MP protocol)
	{
		int i;
		for(i=0; i < 2; i++){
			*icr = 0x000c4610UL;
			xmhf_baseplatform_arch_x86_udelay(200);
			//wait for command completion
			{
			  u32 val;
			  do{
				val = *icr;
			  }while( (val & 0x1000) );
			}
		}
	}

}



//wake up application processors (cores) in the system
static void __xmhfhic_smp_container_vmx_wakeupAPs(void){
    static x86smp_apbootstrapdata_t apdata;

    apdata.ap_cr3 = read_cr3();
    apdata.ap_cr4 = read_cr4();
    apdata.ap_entrypoint = (u32)&__xmhfhic_ap_entry;
    apdata.ap_gdtdesc_limit = sizeof(apdata.ap_gdt) - 1;
    apdata.ap_gdtdesc_base = (X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_gdt);
    apdata.ap_cs_selector = __CS_CPL0;
    apdata.ap_eip = (X86SMP_APBOOTSTRAP_CODESEG << 4);
    apdata.ap_gdt[0] = 0x0000000000000000ULL;
    apdata.ap_gdt[1] = 0x00cf9a000000ffffULL;
    apdata.ap_gdt[2] = 0x00cf92000000ffffULL;

    _XDPRINTF_("%s: sizeof(apdata)=%u bytes\n", __FUNCTION__, sizeof(apdata));
    _XDPRINTF_("  apdata.ap_gdtdesc_limit at %08x\n", &apdata.ap_gdtdesc_limit);
    _XDPRINTF_("  apdata.ap_gdt at %08x\n", &apdata.ap_gdt);

    memcpy((void *)(X86SMP_APBOOTSTRAP_DATASEG << 4), (void *)&apdata, sizeof(apdata));

    memcpy((void *)(X86SMP_APBOOTSTRAP_CODESEG << 4), (void *)&_ap_bootstrap_code, PAGE_SIZE_4K);

#if defined (__DRT__)
    {
        txt_heap_t *txt_heap;
        os_mle_data_t *os_mle_data;
        mle_join_t *mle_join;
        sinit_mle_data_t *sinit_mle_data;
        os_sinit_data_t *os_sinit_data;

        txt_heap = get_txt_heap();
        os_mle_data = get_os_mle_data_start(txt_heap);
        sinit_mle_data = get_sinit_mle_data_start(txt_heap);
        os_sinit_data = get_os_sinit_data_start(txt_heap);

        // enable SMIs on BSP before waking APs (which will enable them on APs)
        // because some SMM may take immediate SMI and hang if AP gets in first
        //_XDPRINTF_("Enabling SMIs on BSP\n");
        //__getsec_smctrl();

        mle_join = (mle_join_t *)((u32)(X86SMP_APBOOTSTRAP_DATASEG << 4) + offsetof(x86smp_apbootstrapdata_t, ap_gdtdesc_limit));

        _XDPRINTF_("\nBSP: mle_join.gdt_limit = %x", mle_join->gdt_limit);
        _XDPRINTF_("\nBSP: mle_join.gdt_base = %x", mle_join->gdt_base);
        _XDPRINTF_("\nBSP: mle_join.seg_sel = %x", mle_join->seg_sel);
        _XDPRINTF_("\nBSP: mle_join.entry_point = %x", mle_join->entry_point);

        write_priv_config_reg(TXTCR_MLE_JOIN, (uint64_t)(unsigned long)mle_join);

        if (os_sinit_data->capabilities.rlp_wake_monitor) {
            _XDPRINTF_("\nBSP: joining RLPs to MLE with MONITOR wakeup");
            _XDPRINTF_("\nBSP: rlp_wakeup_addr = 0x%x", sinit_mle_data->rlp_wakeup_addr);
            *((uint32_t *)(unsigned long)(sinit_mle_data->rlp_wakeup_addr)) = 0x01;
        }else {
            _XDPRINTF_("\nBSP: joining RLPs to MLE with GETSEC[WAKEUP]");
            __getsec_wakeup();
            _XDPRINTF_("\nBSP: GETSEC[WAKEUP] completed");
        }
    }

#else //!__DRT__

    _XDPRINTF_("\nBSP: Using APIC to awaken APs...");
    __xmhfhic_smp_cpu_x86_wakeupAPs();
    _XDPRINTF_("\nBSP: APs should be awake.");

#endif


}

//initialize SMP
static bool __xmhfhic_smp_arch_smpinitialize(void){
	u32 i;

    //save cpu MTRR state which we will later replicate on all APs
	__xmhfhic_smp_cpu_x86_savecpumtrrstate();

    //save page table base which we will later replicate on all APs
    _ap_cr3 = read_cr3();

	//wake up APS
	if(xcbootinfo->cpuinfo_numentries > 1){
	  __xmhfhic_smp_container_vmx_wakeupAPs();
	}

	//fall through to common code
	_XDPRINTF_("%s: Relinquishing BSP thread and moving to common...\n", __FUNCTION__);
	__xmhfhic_smp_cpu_x86_smpinitialize_commonstart();

	_XDPRINTF_("%s:%u: Must never get here. Halting\n", __FUNCTION__, __LINE__);
	HALT();

}

//return 1 if the calling CPU is the BSP
static bool __xmhfhic_smp_cpu_x86_isbsp(void){
  u32 eax, edx;
  //read LAPIC base address from MSR
  rdmsr(MSR_APIC_BASE, &eax, &edx);
  HALT_ON_ERRORCOND( edx == 0 ); //APIC is below 4G

  if(eax & 0x100)
    return true;
  else
    return false;
}


//common function which is entered by all CPUs upon SMP initialization
//note: this is specific to the x86 architecture backend
void __xmhfhic_smp_cpu_x86_smpinitialize_commonstart(void){
	u64 cpuid = __xmhfhic_x86vmx_cpuidtable[xmhf_baseplatform_arch_x86_getcpulapicid()];

    xmhfhic_smp_entry(cpuid);
}



static bool __xmhfhic_ap_entry(void) __attribute__((naked)){

    asm volatile(
                    ".code32 \r\n"
					"_xcsmp_ap_start: \r\n"

					"movw %%ds, %%ax \r\n"
					"movw %%ax, %%es \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"

    				"movl %%cr4, %%eax \r\n"
   					"orl $0x00000030, %%eax \r\n"
   					"movl %%eax, %%cr4 \r\n"

                    "movl %0, %%ebx \r\n"
                    "movl (%%ebx), %%ebx \r\n"
                    "movl %%ebx, %%cr3 \r\n"

                    "movl $0xc0000080, %%ecx \r\n"
                    "rdmsr \r\n"
                    "orl $0x00000100, %%eax \r\n"
                    "orl $0x00000800, %%eax \r\n"
                    "wrmsr \r\n"

                    "movl %%cr0, %%eax \r\n"
                    "orl $0x80000015, %%eax \r\n"
                    "movl %%eax, %%cr0 \r\n"

                    "movl %1, %%esi \r\n"
                    "lgdt (%%esi) \r\n"

                    "ljmp $8, $_xcsmp_ap_start64 \r\n"

                    ".code64 \r\n"
                    "_xcsmp_ap_start64: \r\n"

					"movw $0x10, %%ax \r\n"
					"movw %%ax, %%fs \r\n"
					"movw %%ax, %%gs \r\n"
					"movw %%ax, %%ss \r\n"
					"movw %%ax, %%ds \r\n"
					"movw %%ax, %%es \r\n"

                    "movl %2, %%ecx \r\n"
                    "rdmsr \r\n"
                    "andl $0x00000FFF, %%eax \r\n"
                    "orl %3, %%eax \r\n"
                    "wrmsr \r\n"

					:
					:   "i" (&_ap_cr3), "i" (&_xcsmp_ap_init_gdt), "i" (MSR_APIC_BASE), "i" (X86SMP_LAPIC_MEMORYADDRESS)
	);


/*    asm volatile(
                 	"movl %0, %%eax\r\n"
					"movl (%%eax), %%eax\r\n"
					"shr $24, %%eax\r\n"
					"movl %2, %%ebx\r\n"
					"movl %1, %%ecx \r\n"
					"1: cmpl 0x0(%%ebx), %%eax\r\n"
					"jz 2f\r\n"
					"addl %3, %%ebx\r\n"
					"loop 1b \r\n"
					"hlt\r\n"								// we should never get here, if so just halt
					"2: movl 0x4(%%ebx), %%eax\r\n"			// eax = g_xc_cputable[ecx].cpu_index
					"movl %5, %%ecx \r\n"					// ecx = sizeof(_cpustack[0])
					"mull %%ecx \r\n"						// eax = sizeof(_cpustack[0]) * eax
					"addl %%ecx, %%eax \r\n"				// eax = (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"addl %4, %%eax \r\n"				    // eax = &_cpustack + (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"movl %%eax, %%esp \r\n"				// esp = top of stack for the cpu

                    "jmp __xmhfhic_smp_cpu_x86_smpinitialize_commonstart \r\n"

					:
					:   "i" (X86SMP_LAPIC_ID_MEMORYADDRESS), "m" (_totalcpus), "i" (&_cputable),
                        "i" (sizeof(xmhf_cputable_t)), "i" (&_init_cpustacks), "i" (sizeof(_init_cpustacks[0]))

	);*/

    asm volatile(
                 	"xorq %%rax, %%rax \r\n"                //RAX=0
                 	"movl %0, %%eax\r\n"                    //
					"movl (%%eax), %%eax\r\n"               //RAX(bits 0-7)=LAPIC ID
					"shr $24, %%eax\r\n"                    //RAX=LAPIC ID
                    "movq %1, %%rbx \r\n"                   //RBX=&__xmhfhic_x86vmx_cpuidtable
                    "movq (%%rbx, %%rax, 8), %%rax \r\n"    //EAX= 0-based cpu index for the CPU

					"movl %2, %%ecx \r\n"					// ecx = sizeof(_cpustack[0])
					"mull %%ecx \r\n"						// eax = sizeof(_cpustack[0]) * eax
					"addl %%ecx, %%eax \r\n"				// eax = (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"addl %3, %%eax \r\n"				    // eax = &_cpustack + (sizeof(_cpustack[0]) * eax) + sizeof(_cpustack[0])
					"movl %%eax, %%esp \r\n"				// esp = top of stack for the cpu

                    "jmp __xmhfhic_smp_cpu_x86_smpinitialize_commonstart \r\n"

					:
					:   "i" (X86SMP_LAPIC_ID_MEMORYADDRESS),
                        "i" (&__xmhfhic_x86vmx_cpuidtable),
                        "i" (sizeof(_init_cpustacks[0])),
                        "i" (&_init_cpustacks)

                    :
	);


}


void xmhfhic_arch_switch_to_smp(void){
	//initialize cpu table and total platform CPUs
	{
	    u32 i, j;
	    for(i=0; i < MAX_X86_APIC_ID; i++)
            __xmhfhic_x86vmx_cpuidtable[i] = 0xFFFFFFFFFFFFFFFFULL;

	    for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            u64 value = i;

            if(xcbootinfo->cpuinfo_buffer[i].isbsp)
                value |= 0x8000000000000000ULL;

            //XXX: TODO sanity check xcbootinfo->cpuinfo_buffer[i].lapic_id < MAX_X86_APIC_ID
            __xmhfhic_x86vmx_cpuidtable[xcbootinfo->cpuinfo_buffer[i].lapic_id] = value;
        }
	}

    __xmhfhic_smp_arch_smpinitialize();

}























/////////////////////////////////////////////////////////////////////
// setup base CPU data structures

//initialize GDT
static void __xmhfhic_x86vmx_initializeGDT(void){
		u32 i;

		//initialize TSS descriptors for all CPUs
		for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            TSSENTRY *t;
            u32 tss_base=(u32)&__xmhfhic_x86vmx_tss[i];

            //TSS descriptor
            t= (TSSENTRY *)&__xmhfhic_x86vmx_gdt_start[(__TRSEL/8)+(i*2)];
            t->attributes1= 0xE9;
            t->limit16_19attributes2= 0x0;
            t->baseAddr0_15= (u16)(tss_base & 0x0000FFFF);
            t->baseAddr16_23= (u8)((tss_base & 0x00FF0000) >> 16);
            t->baseAddr24_31= (u8)((tss_base & 0xFF000000) >> 24);
            t->limit0_15=0x67;
		}

}

//initialize IDT
static void __xmhfhic_x86vmx_initializeIDT(void){
	u32 i;

	for(i=0; i < EMHF_XCPHANDLER_MAXEXCEPTIONS; i++){
		__xmhfhic_x86vmx_idt_start[i].isrLow= (u16)__xmhfhic_exceptionstubs[i];
		__xmhfhic_x86vmx_idt_start[i].isrHigh= (u16) ( (u32)__xmhfhic_exceptionstubs[i] >> 16 );
		__xmhfhic_x86vmx_idt_start[i].isrSelector = __CS_CPL0;
		__xmhfhic_x86vmx_idt_start[i].count=0x0;
		__xmhfhic_x86vmx_idt_start[i].type=0xEE;	//32-bit interrupt gate
                                //present=1, DPL=11b, system=0, type=1110b
        __xmhfhic_x86vmx_idt_start[i].offset3263=0;
        __xmhfhic_x86vmx_idt_start[i].reserved=0;
	}

}


//initialize TSS
static void __xmhfhic_x86vmx_initializeTSS(void){
		u32 i;

		//initialize TSS descriptors for all CPUs
		for(i=0; i < xcbootinfo->cpuinfo_numentries; i++){
            tss_t *tss= (tss_t *)__xmhfhic_x86vmx_tss[i];
            tss->rsp0 = (u64) ( &__xmhfhic_x86vmx_tss_stack[i] + sizeof(__xmhfhic_x86vmx_tss_stack[0]) );
		}
}


void xmhfhic_arch_setup_base_cpu_data_structures(void){

    //initialize GDT
    __xmhfhic_x86vmx_initializeGDT();

    //initialize IDT
    __xmhfhic_x86vmx_initializeIDT();

    //initialize TSS
    __xmhfhic_x86vmx_initializeTSS();

}
















//////////////////////////////////////////////////////////////////////////////
// setup cpu state for hic



/*


//*
//perform basic (boot) CPU initialization
void xcprimeon_arch_cpu_basicinit(void){
	u32 cpu_vendor;

	//grab CPU vendor
	cpu_vendor = xmhf_baseplatform_arch_getcpuvendor();
	if (cpu_vendor != CPU_VENDOR_INTEL){
		_XDPRINTF_("%s: not an Intel CPU but running VMX backend. Halting!\n", __FUNCTION__);
		HALT();
	}

	//check VMX support
	{
		u32	cpu_features;
		u32 res0,res1,res2;

		cpuid(0x1, &res0, &res1, &cpu_features, &res2);

		if ( ( cpu_features & (1<<5) ) == 0 ){
			_XDPRINTF_("No VMX support. Halting!\n");
			HALT();
		}
	}



*/


//load GDT and initialize segment registers
static void __xmhfhic_x86vmx_loadGDT(u64 cpuid){

	asm volatile(
		"lgdt  %0 \r\n"
		"pushq	%1 \r\n"				// far jump to runtime entry point
		"pushq	$reloadsegs \r\n"
		"lretq \r\n"
		"reloadsegs: \r\n"
		"movw	%2, %%ax \r\n"
		"movw	%%ax, %%ds \r\n"
		"movw	%%ax, %%es \r\n"
		"movw	%%ax, %%fs \r\n"
		"movw	%%ax, %%gs \r\n"
		"movw   %%ax, %%ss \r\n"
		: //no outputs
		: "m" (__xmhfhic_x86vmx_gdt), "i" (__CS_CPL0), "i" (__DS_CPL0)
		: "eax"
	);
}


//load IDT
static void __xmhfhic_x86vmx_loadIDT(u64 cpuid){
	//load IDT
	asm volatile(
		"lidt  %0 \r\n"
		: //no outputs
		: "m" (__xmhfhic_x86vmx_idt)
		: //no clobber
	);
}

//load TR
static void __xmhfhic_x86vmx_loadTR(u64 cpuid){
	  asm volatile(
		"movq %0, %%rax\r\n"
		"ltr %%ax\r\n"				//load TR
	     :
	     : "g"(__TRSEL + ((u32)cpuid * 16) )
	     : "rax"
	  );
}


//set IOPl to CPl-3
static void __xmhfhic_x86vmx_setIOPL3(u64 cpuid){

	asm volatile(
        "pushfq \r\n"
        "popq %%rax \r\n"
		"orq $0x3000, %%rax \r\n"					// clear flags, but set IOPL=3 (CPL-3)
		"pushq %%rax \r\n"
		"popfq \r\n"
		: //no outputs
		: //no inputs
		: "rax", "cc"
	);


}


void xmhf_hic_arch_setup_cpu_state(u64 cpuid){

	//replicate common MTRR state on this CPU
	__xmhfhic_smp_cpu_x86_restorecpumtrrstate();

    //load GDT
    __xmhfhic_x86vmx_loadGDT(cpuid);
    _XDPRINTF_("%s[%u]: GDT loaded\n", __FUNCTION__, (u32)cpuid);

    //load TR
    __xmhfhic_x86vmx_loadTR(cpuid);
    _XDPRINTF_("%s[%u]: TR loaded\n", __FUNCTION__, (u32)cpuid);

    //load IDT
    __xmhfhic_x86vmx_loadIDT(cpuid);
    _XDPRINTF_("%s[%u]: IDT loaded\n", __FUNCTION__, (u32)cpuid);


    asm volatile ("int $0x03 \r\n");

    //turn on CR0.WP bit for supervisor mode write protection
    write_cr0(read_cr0() | CR0_WP);
    _XDPRINTF_("%s[%u]: Enabled supervisor mode write protection\n", __FUNCTION__, (u32)cpuid);

    //set IOPL3
    __xmhfhic_x86vmx_setIOPL3(cpuid);
    _XDPRINTF_("%s[%u]: set IOPL to CPL-3\n", __FUNCTION__, (u32)cpuid);


    //set LAPIC base address to preferred address
    {
        u64 msrapic = rdmsr64(MSR_APIC_BASE);
        wrmsr64(MSR_APIC_BASE, ((msrapic & 0x0000000000000FFFULL) | X86SMP_LAPIC_MEMORYADDRESS));
    }
    _XDPRINTF_("%s[%u]: set LAPIC base address to %016llx\n", __FUNCTION__, (u32)cpuid, rdmsr64(MSR_APIC_BASE));

	//turn on NX protections
	{
		u32 eax, edx;
		rdmsr(MSR_EFER, &eax, &edx);
		eax |= (1 << EFER_NXE);
		wrmsr(MSR_EFER, eax, edx);
	}
    _XDPRINTF_("%s[%u]: NX protections enabled\n", __FUNCTION__, (u32)cpuid);

	//enable PCIDE support
	{
		write_cr4(read_cr4() | CR4_PCIDE);
	}
    _XDPRINTF_("%s[%u]: PCIDE enabled\n", __FUNCTION__, (u32)cpuid);


	//set OSXSAVE bit in CR4 to enable us to pass-thru XSETBV intercepts
	//when the CPU supports XSAVE feature
	if(xmhf_baseplatform_arch_x86_cpuhasxsavefeature()){
        write_cr4(read_cr4() | CR4_OSXSAVE);
        _XDPRINTF_("%s[%u]: XSETBV passthrough enabled\n", __FUNCTION__, (u32)cpuid);
	}


	//set bit 5 (EM) of CR0 to be VMX compatible in case of Intel cores
	write_cr0(read_cr0() | 0x20);
    _XDPRINTF_("%s[%u]: Set CR0.EM to be VMX compatible\n", __FUNCTION__, (u32)cpuid);



}


