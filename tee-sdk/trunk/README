# Overview

This is the Trusted-Execution-Environment Software-Development-Kit
(tee-sdk). It comprises tools and documentation for developing
_services_ that run in a trusted environments, and _clients_ that
communicate with those services. Initially, this means writing PALs
that run under TrustVisor, and applications that use PALs. However,
the APIs provided here are intended to provide sufficient abstraction
such that additional back-ends can be implemented, allowing services
and applications to be ported to use alternative trusted environments
with little or no modification.

# Terminology

Service
  ~ A piece of code running in a trusted execution environment
    provided by a _device_. (e.g., a PAL)
Client
  ~ An application that communicates with one or more _services_.
Device
  ~ A module providing a trusted execution environment (e.g., TrustVisor)

# Files

  * [README](README) This file.
  * [tz](tz) TrustZone API. This library is to be used by _clients_
    to communicate with _services_. This library supports multiple
    _device_ back-ends, abstracting them in such a way that most _client_
    code can be oblivious to which back-end is in use.
  * [svcapi](svcapi) Runtime services to be used by _services_.
  * [ports](ports) Support libraries for _services_. These have been
    ported to run in a trusted environment provided by some _device_.
    i.e., they do not make system calls, and all dependencies should
    be satisfied by other ports, svcapi, or other libraries provided
    as part of this package.
  * [examples](examples) Examples and tests.
  
# Loading and unloading services

Services are loaded and unloaded through the TrustZone service manager:

~~~ {.c}
  tz_return_t tzRet;
  tz_device_t tzDevice;
  tz_session_t tzManagerSession;
  tz_uuid_t tzSvcId;

  /* open isolated execution environment device */
  /* Use NULL for default device, or 'tv' to specify trustvisor */
  tzRet = TZDeviceOpen(NULL, NULL, &tzDevice);
  assert(tzRet == TZ_SUCCESS);

  /* prepare service descriptor */
  /* this is currently device-specific (i.e., trustvisor-specific).
     eventually it'd be good to provide a common abstraction here. */
  scode_sections_info_init(&scode_info,
                           &__scode_start, scode_ptr_diff(&__scode_end, &__scode_start),
                           NULL, 0,
                           PAGE_SIZE, PAGE_SIZE);

  /* open session with device manager */
  tzRet = TZManagerOpen(&tzDevice, NULL, &tzManagerSession);
  assert(tzRet == TZ_SUCCESS);

  /* download */
  tzRet = TZManagerDownloadService(&tzManagerSession,
                                   &pal,
                                   sizeof(pal),
                                   &tzSvcId);
  assert(tzRet == TZ_SUCCESS);

  /* do useful work with the service */
  
  /* unload the service. */
  /* This is currently CRITICAL when using TrustVisor. Exiting the
     application without unloading the service will lead to system
     instability. */
  tzRet = TZManagerRemoveService(&tzManagerSession,
                                 &tzSvcId);
  assert(tzRet == TZ_SUCCESS);

  /* close session */
  tzRet = TZManagerClose(&tzManagerSession);
  assert(tzRet == TZ_SUCCESS);
~~~ 

# Calling services

Services are called through the TrustZone API. You must open a session
with a currently-loaded service. A session can be used for multiple
invocations of a service. See the
[TrustZone API specification](tz/TrustZone_API_3.0_Specification.pdf)
for details.

# Developing a service

Unfortunately this area still needs a lot of work. It is currently
very trustvisor-specific and fragile. Everything here is likely to
change significantly.

## Memory Layout

While eventually services will be compiled as standalone binaries,
currently they are compiled together with the application that calls
them. When loading the service, memory pages that contain service code
and data are registered with trustvisor to be measured and protected.
This means that service code and data must be on separate memory
pages from application code and data, and that you must be able to identify
the relevant memory ranges. This is most easily done by putting service
code in separate object files or in separate sections, e.g.

~~~ {.c}
 __attribute__ ((section (".scode")))
~~~

A linker script must then be used to ensure page-alignment, and to
identify the beginning and end of the relevant sections. See
[examples/test/inject.ld] for an example of such a linker script.

## Service entry point

The service entry point should have the following prototype:

~~~ {.c}
void pal_entry(uint32_t uiCommand, tzi_encode_buffer_t *psInBuf, tzi_encode_buffer_t *psOutBuf, tz_return_t *puiRv)
~~~

 * `uiCommand` will contain command specified in the call to
   `TZOperationPrepareInvoke`
 * `psInBuf` will contain the parameters marshalled by `TZEncode*`. 
   Use the API in [tz/include/marshal.h] to decode this buffer.
 * `psOutBuf` is an output buffer for marshalled data. Use the
   API in [tz/include/marshal.h] to encode this buffer.
 * `puiRv` is a status code to be returned. Success should be indicated
   by setting this to `TZ_SUCCESS`.

# Roadmap

## Clean API for developing services

libsvcapi is a start, but is just a quick rip from trustvisor's code.
The api is incomplete and has some serious issues (such as not
providing a way for the caller to determine how much memory to
allocate). Use this for now. It will most likely be replaced by
something cleaner, but it should be straight-forward to keep old code
from breaking by providing a compatibility layer if necessary.

## Better support for standalone service binaries

The current API for loading services is trustvisor-specific, and
requires that the service (PAL) and the application that invokes it
are compiled into the same binary. Soon we'll standardize a standalone
binary format for services, so that they may be compiled separately
from the applications that use them. Ideally they will also be at least
source-compatible with alternative devices; perhaps even binary-compatible.

## Better build management

There are a number of interdependent libraries included here, each
with their own ad-hoc configuration and build system. We should look
into cleaning this up using e.g., autotools and libtool.

# Other resources

  * [Redmine Project](https://plover.pdl.cmu.local/projects/tee-sdk/) 

This file is written in [Pandoc] Markdown for easy conversion to other
formats.

[Pandoc]: http://johnmacfarlane.net/pandoc/README.html

