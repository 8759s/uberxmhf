#!/usr/bin/perl
# script to generate XMHF slab physical memory extents
# based on the slab names provided
# author: amit vasudevan (amitvasudevan@acm.org)

use Tie::File;
use File::Basename;


# command line inputs
# 0: SLABS file with absolute path
# 1: max number of unverified slab memory page table sets

my $g_slabsfile = $ARGV[0];
my $g_totaluvslabmempgtblsets = $ARGV[1];
my $g_totalslabmempgtblsets;
my $g_uvslabcounter;
my $g_totalslabs;
my $g_rootdir;

my %slab_idtogsm;
my %slab_idtoname;
my %slab_idtotype;
my %slab_idtosubtype;
my %slab_idtouapifnmask;
my %slab_idtocallmask;

my %slab_nametoid;

my $i = 0;
my $slabdir;
my $slabname;
my $slabgsmfile;
my $slabtype;
my $slabsubtype;


$g_rootdir = dirname($g_slabsfile)."/";
$g_totalslabmempgtblsets = $g_totaluvslabmempgtblsets + 2;
$g_uvslabcounter = 0;

#print "slabsfile:", $g_slabsfile, "\n";
#print "rootdir:", $g_rootdir, "\n";


# iterate through all the entries within SLABS file and
# compute total number of slabs while populating global
# slab_idto{gsm,name,type} hashes

tie my @array, 'Tie::File', $g_slabsfile or die $!;

while( $i <= $#array) {

    my $line = $array[$i];
    chomp($line);

    my $trimline = $line;
    $trimline =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace

    # split the line using the comma delimiter
    my @slabinfo = split(/,/, $trimline);

    $slabdir = $g_rootdir.$slabinfo[0];
    $slabdir =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
    $slabname = basename($slabinfo[0]);
    $slabname =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
    $slabtype = $slabinfo[1];
    $slabtype =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
    $slabsubtype = $slabinfo[2];
    $slabsubtype =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
    $slabgsm = $slabdir."/".$slabname.".gsm.pp";

    #print "Slab name: $slabname, gsm:$slabgsm ...\n";
    $slab_idtogsm{$i} = $slabgsm;
    $slab_idtoname{$i} = $slabname;
    $slab_idtotype{$i} = $slabtype;
    $slab_idtosubtype{$i} = $slabsubtype;
    $slab_nametoid{$slabname} = $i;

    # move on to the next line
    $i = $i + 1;
}

$g_totalslabs = $i;

#print "g_totalslabs:", $g_totalslabs, "\n";

# now iterate through all the slab id's and populate callmask and
# uapimasks

$i =0;
while($i < $g_totalslabs){
    #print "slabname: $slab_idtoname{$i}, slabgsm: $slab_idtogsm{$i}, slabtype: $slab_idtotype{$i}, slabcallmask: $slab_idtocallmask{$i} \n";
    $slab_idtouapifnmask{$i} = parse_gsm($slab_idtogsm{$i}, $i, $g_totalslabs);
    #print "uapifnmask:\n";
    #print $slab_idtouapifnmask{$i};
    $i=$i+1;
}

######










######
# output
######

print "\n/* autogenerated XMHF/GEEC sentinel slab info table */";
print "\n/* author: amit vasudevan (amitvasudevan@acm.org) */";

print "\n";

$i=0;
while( $i < $g_totalslabs) {
	print "\n";
	print "\nextern u8 _slab_$slab_idtoname{$i}_code_start[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_code_end[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_data_start[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_data_end[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_stack_start[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_stack_end[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_dmadata_start[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_dmadata_end[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_entrypoint[];";

	$i++;
}

print "\n";
print "\n__attribute__(( section(\".data\") )) __attribute__((aligned(4096))) xmhfgeec_slab_info_t _xmhfhic_common_slab_info_table[] = {";


$i = 0;
while( $i < $g_totalslabs ){
	print "\n";
    print "\n	//$slab_idtoname{$i}";
    print "\n	{";

    #slab_inuse
    print "\n	    true,";

    #slab_type
    if($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "PRIME"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "SENTINEL"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_SENTINEL,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "INIT"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "XCORE"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "XHYPAPP"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "UAPI"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "EXCEPTION"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "INTERCEPT"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "uVT_SLAB" && $slab_idtosubtype{$i} eq "INIT"){
        print "\n	        XMHFGEEC_SLABTYPE_uVT_PROG,";
    }elsif($slab_idtotype{$i} eq "uVT_SLAB" && $slab_idtosubtype{$i} eq "XCORE"){
        print "\n	        XMHFGEEC_SLABTYPE_uVT_PROG,";
    }elsif($slab_idtotype{$i} eq "uVT_SLAB" && $slab_idtosubtype{$i} eq "XHYPAPP"){
        print "\n	        XMHFGEEC_SLABTYPE_uVT_PROG,";
    }elsif($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XCORE"){
        print "\n	        XMHFGEEC_SLABTYPE_uVU_PROG,";
    }elsif($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XHYPAPP"){
        print "\n	        XMHFGEEC_SLABTYPE_uVU_PROG,";
    }elsif($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XGUEST"){
        print "\n	        XMHFGEEC_SLABTYPE_uVU_PROG_GUEST,";
    }elsif($slab_idtotype{$i} eq "uVT_SLAB" && $slab_idtosubtype{$i} eq "XGUEST"){
        print "\n	        XMHFGEEC_SLABTYPE_uVT_PROG_GUEST,";
    }elsif($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XRICHGUEST"){
        print "\n	        XMHFGEEC_SLABTYPE_uVU_PROG_RICHGUEST,";
    }else{
        print "\nError: Unknown slab type!";
        exit 1;
    }

    #mempgtbl_cr3, for VfT_SLAB type point SENTINEL to the base of the page table
    #bases and for all other slabs point to PRIME slab memory page tables
    if ($slab_idtotype{$i} eq "VfT_SLAB"){
        if($slab_idtosubtype{$i} eq "SENTINEL"){
            printf "\n	        &_slab_uapi_slabmempgtbl_data_start[%u],", (0 * 4096);
        }else{
            printf "\n	        &_slab_uapi_slabmempgtbl_data_start[%u],", (1 * 4096);
        }
    }else{
        if($g_uvslabcounter >=  $g_totaluvslabmempgtblsets){
            print "\nError: Too many unverified slabs (max=$g_totaluvslabmempgtblsets)!";
            exit 1;
        }else{
            $g_uvslabcounter = $g_uvslabcounter + 1;
        }

        if( $i < $g_totalslabmempgtblsets){
          printf "\n	        &_slab_uapi_slabmempgtbl_data_start[%u],", ($i * 4096);
        }else{
            print "\nError: Illegal unverified slab id ($i)!";
            exit 1;
        }
    }

    #slab_tos
    print "\n	        {";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[1*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[2*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[3*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[4*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[5*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[6*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[7*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[8*XMHF_SLAB_STACKSIZE]),";
    print "\n	        },";

    #slab_callcaps
    printf("\n\t0x%08xUL, ", $slab_idtocallmask{$i});

    #slab_uapisupported
    if($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "UAPI"){
        print "\n       true,";
    }else{
        print "\n       false,";
    }

    #slab_uapicaps
    print "\n       {\n";
    printf("%s", $slab_idtouapifnmask{$i});
    #$j = 0;
    #while( $j < $total_slabs) {
    #    print "\n	    0xFFFFFFFFUL,";
    #    $j=$j+1;
    #}
    print "\n       },";

    #slab_memgrantreadcaps
    print "\n       0xFFFFFFFFUL,";

    #slab_memgrantwritecaps
    print "\n       0xFFFFFFFFUL,";

    #slab_devices
    if($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XRICHGUEST"){
        print "\n	    {true, 0xFFFFFFFFUL, {0}},";
    }else{
        print "\n	    {false, 0, {0}},";
    }

    #slab_physmem_extents
    print "\n	    {";
    print "\n	        {.addr_start = _slab_$slab_idtoname{$i}_code_start, .addr_end = _slab_$slab_idtoname{$i}_code_end, .protection = 0},";
    print "\n	        {.addr_start = _slab_$slab_idtoname{$i}_data_start, .addr_end = _slab_$slab_idtoname{$i}_data_end, .protection = 0},";
    print "\n	        {.addr_start = _slab_$slab_idtoname{$i}_stack_start, .addr_end = _slab_$slab_idtoname{$i}_stack_end, .protection = 0},";
    print "\n	        {.addr_start = _slab_$slab_idtoname{$i}_dmadata_start, .addr_end = _slab_$slab_idtoname{$i}_dmadata_end, .protection = 0},";
    print "\n	    },";

    #slab_entrystub
    print "\n	    (u32)_slab_$slab_idtoname{$i}_entrypoint";

    print "\n	},";
	print "\n";

	$i++;
}

print "\n};";


exit 0;






















######
# parses a gsm file and populates relevant global structures
######
sub parse_gsm {
    my($filename, $slabid, $totalslabs) = @_;
    my $i = 0;
    my $j = 0;
    my %slab_idtouapifnmask;
    my $slab_uapifnmaskstring = "";

    chomp($filename);
    tie my @array, 'Tie::File', $filename or die $!;

    #print "parse_gsm: $filename, $slabid...\n";

    while( $i <= $#array) {
        my $line = $array[$i];
        chomp($line);
        $line =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace

        my @lineentry = split(/:/, $line);

        if($lineentry[0] eq "S"){
            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";
            #lineentry[1] = name of destination slab that this slab calls
            if (exists $slab_idtocallmask{$slab_nametoid{$lineentry[1]}}){
                $slab_idtocallmask{$slab_nametoid{$lineentry[1]}} |= (1 << $slabid);
            }else {
                $slab_idtocallmask{$slab_nametoid{$lineentry[1]}} = (1 << $slabid);
            }

        }elsif( $lineentry[0] eq "U"){
            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";
            #lineentry[1] = destination slab name, lineentry[2] = uapifn
            if (exists $slab_idtouapifnmask{$slab_nametoid{$lineentry[1]}}){
                $slab_idtouapifnmask{$slab_nametoid{$lineentry[1]}} |= (1 << $lineentry[2]);
            }else{
                $slab_idtouapifnmask{$slab_nametoid{$lineentry[1]}} = (1 << $lineentry[2]);
            }

        }elsif( $lineentry[0] eq "RD"){

            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";

        }elsif( $lineentry[0] eq "RC"){

            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";

        }else{
            #we don't know/care about this line, so just skip it
        }


        $i = $i +1;
    }

    while($j < $totalslabs){
        $slab_uapifnmaskstring = $slab_uapifnmaskstring.sprintf("\t0x%08x,\n", $slab_idtouapifnmask{$j});
        $j=$j+1;
    }


    return $slab_uapifnmaskstring;

}



