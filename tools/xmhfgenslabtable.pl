#!/usr/bin/perl
# script to generate XMHF slab physical memory extents
# based on the slab names provided
# author: amit vasudevan (amitvasudevan@acm.org)

use Tie::File;
use File::Basename;


# command line inputs
# 0: SLABS file with absolute path
# 1: max number of unverified slab memory page table sets

my $g_slabsfile = $ARGV[0];
my $g_maxuvslabs = $ARGV[1];
my $g_maxincldevlistentries = $ARGV[2];
my $g_maxexcldevlistentries = $ARGV[3];

my $g_totalslabmempgtblsets;
my $g_totalslabiotblsets;
my $g_uvslabcounter;


my $g_totalslabs;
my $g_rootdir;

my %slab_idtogsm;
my %slab_idtoname;
my %slab_idtotype;
my %slab_idtosubtype;
my %slab_idtouapifnmask;
my %slab_idtocallmask;

my %slab_idtordinclentries;
my %slab_idtordinclcount;

my %slab_idtordexclentries;
my %slab_idtordexclcount;


my %slab_idtomemgrantreadcaps;
my %slab_idtomemgrantwritecaps;


my %slab_idtodatasize;
my %slab_idtocodesize;
my %slab_idtostacksize;
my %slab_idtodmadatasize;



my %slab_nametoid;

my $i = 0;
my $slabdir;
my $slabname;
my $slabgsmfile;
my $slabtype;
my $slabsubtype;


$g_rootdir = dirname($g_slabsfile)."/";

$g_totaluvslabmempgtblsets = $g_maxuvslabs;
$g_totaluvslabiotblsets = $g_maxuvslabs;
$g_totalslabmempgtblsets = $g_totaluvslabmempgtblsets + 2;
$g_totalslabiotblsets = $g_totaluvslabiotblsets + 2;

$g_uvslabcounter = 0;

#print "slabsfile:", $g_slabsfile, "\n";
#print "rootdir:", $g_rootdir, "\n";


# iterate through all the entries within SLABS file and
# compute total number of slabs while populating global
# slab_idto{gsm,name,type} hashes

tie my @array, 'Tie::File', $g_slabsfile or die $!;

while( $i <= $#array) {

    my $line = $array[$i];
    chomp($line);

    my $trimline = $line;
    $trimline =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace

    # split the line using the comma delimiter
    my @slabinfo = split(/,/, $trimline);

    $slabdir = $g_rootdir.$slabinfo[0];
    $slabdir =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
    $slabname = basename($slabinfo[0]);
    $slabname =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
    $slabtype = $slabinfo[1];
    $slabtype =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
    $slabsubtype = $slabinfo[2];
    $slabsubtype =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace
    $slabgsm = $slabdir."/".$slabname.".gsm.pp";

    #print "Slab name: $slabname, gsm:$slabgsm ...\n";
    $slab_idtogsm{$i} = $slabgsm;
    $slab_idtoname{$i} = $slabname;
    $slab_idtotype{$i} = $slabtype;
    $slab_idtosubtype{$i} = $slabsubtype;
    $slab_nametoid{$slabname} = $i;

    # move on to the next line
    $i = $i + 1;
}

$g_totalslabs = $i;

#print "g_totalslabs:", $g_totalslabs, "\n";

# now iterate through all the slab id's and populate callmask and
# uapimasks

$i =0;
while($i < $g_totalslabs){
    #print "slabname: $slab_idtoname{$i}, slabgsm: $slab_idtogsm{$i}, slabtype: $slab_idtotype{$i}, slabcallmask: $slab_idtocallmask{$i} \n";
    $slab_idtouapifnmask{$i} = parse_gsm($slab_idtogsm{$i}, $i, $g_totalslabs);
    #print "uapifnmask:\n";
    #print $slab_idtouapifnmask{$i};
    $i=$i+1;
}

######









######
# compute memory map
######
$i =0;
while($i < $g_totalslabs){
    #print "slabname: $slab_idtoname{$i}, code: $slab_idtocodesize{$i}, data: $slab_idtodatasize{$i}, stack: $slab_idtostacksize{$i}, dmadata: $slab_idtodmadatasize{$i} \n";
    $i=$i+1;
}












######
# output
######

print "\n/* autogenerated XMHF/GEEC sentinel slab info table */";
print "\n/* author: amit vasudevan (amitvasudevan@acm.org) */";

print "\n";

$i=0;
while( $i < $g_totalslabs) {
	print "\n";
	print "\nextern u8 _slab_$slab_idtoname{$i}_code_start[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_code_end[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_data_start[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_data_end[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_stack_start[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_stack_end[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_dmadata_start[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_dmadata_end[];";
	print "\nextern u8 _slab_$slab_idtoname{$i}_entrypoint[];";

	$i++;
}

print "\n";
print "\n__attribute__(( section(\".data\") )) __attribute__((aligned(4096))) xmhfgeec_slab_info_t _xmhfhic_common_slab_info_table[] = {";


$i = 0;
while( $i < $g_totalslabs ){
	print "\n";
    print "\n	//$slab_idtoname{$i}";
    print "\n	{";

    #slab_inuse
    print "\n	    true,";

    #slab_type
    if($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "PRIME"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "SENTINEL"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_SENTINEL,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "INIT"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "XCORE"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "XHYPAPP"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "UAPI"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "EXCEPTION"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "INTERCEPT"){
        print "\n	        XMHFGEEC_SLABTYPE_VfT_PROG,";
    }elsif($slab_idtotype{$i} eq "uVT_SLAB" && $slab_idtosubtype{$i} eq "INIT"){
        print "\n	        XMHFGEEC_SLABTYPE_uVT_PROG,";
    }elsif($slab_idtotype{$i} eq "uVT_SLAB" && $slab_idtosubtype{$i} eq "XCORE"){
        print "\n	        XMHFGEEC_SLABTYPE_uVT_PROG,";
    }elsif($slab_idtotype{$i} eq "uVT_SLAB" && $slab_idtosubtype{$i} eq "XHYPAPP"){
        print "\n	        XMHFGEEC_SLABTYPE_uVT_PROG,";
    }elsif($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XCORE"){
        print "\n	        XMHFGEEC_SLABTYPE_uVU_PROG,";
    }elsif($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XHYPAPP"){
        print "\n	        XMHFGEEC_SLABTYPE_uVU_PROG,";
    }elsif($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XGUEST"){
        print "\n	        XMHFGEEC_SLABTYPE_uVU_PROG_GUEST,";
    }elsif($slab_idtotype{$i} eq "uVT_SLAB" && $slab_idtosubtype{$i} eq "XGUEST"){
        print "\n	        XMHFGEEC_SLABTYPE_uVT_PROG_GUEST,";
    }elsif($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XRICHGUEST"){
        print "\n	        XMHFGEEC_SLABTYPE_uVU_PROG_RICHGUEST,";
    }else{
        print "\nError: Unknown slab type!";
        exit 1;
    }

    #mempgtbl_cr3 and iotbl_base, for VfT_SLAB type point SENTINEL to the base of the page table
    #bases and for all other slabs point to PRIME slab memory page tables
    if ($slab_idtotype{$i} eq "VfT_SLAB"){
        if($slab_idtosubtype{$i} eq "SENTINEL"){
            printf "\n	        &_slab_uapi_slabmempgtbl_data_start[%u],", (0 * 4096);
            printf "\n	        &_slab_uapi_slabiotbl_data_start[%u],", (0 * (3*4096));
        }else{
            printf "\n	        &_slab_uapi_slabmempgtbl_data_start[%u],", (1 * 4096);
            printf "\n	        &_slab_uapi_slabiotbl_data_start[%u],", (1 * (3*4096));
        }
    }else{
        if($g_uvslabcounter >=  $g_totaluvslabmempgtblsets){
            print "\nError: Too many unverified slabs (max=$g_totaluvslabmempgtblsets)!";
            exit 1;
        }else{
            $g_uvslabcounter = $g_uvslabcounter + 1;
        }

        if( $i < $g_totalslabmempgtblsets){
          printf "\n	        &_slab_uapi_slabmempgtbl_data_start[%u],", ($i * 4096);
          printf "\n	        &_slab_uapi_slabiotbl_data_start[%u],", ($i * (3*4096));
        }else{
            print "\nError: Illegal unverified slab id ($i)!";
            exit 1;
        }
    }


    #slab_tos
    print "\n	        {";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[1*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[2*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[3*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[4*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[5*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[6*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[7*XMHF_SLAB_STACKSIZE]),";
    print "\n	            ((u32)&_slab_$slab_idtoname{$i}_stack_start[8*XMHF_SLAB_STACKSIZE]),";
    print "\n	        },";

    #slab_callcaps
    printf("\n\t0x%08xUL, ", $slab_idtocallmask{$i});

    #slab_uapisupported
    if($slab_idtotype{$i} eq "VfT_SLAB" && $slab_idtosubtype{$i} eq "UAPI"){
        print "\n       true,";
    }else{
        print "\n       false,";
    }

    #slab_uapicaps
    print "\n       {\n";
    printf("%s", $slab_idtouapifnmask{$i});
    #$j = 0;
    #while( $j < $total_slabs) {
    #    print "\n	    0xFFFFFFFFUL,";
    #    $j=$j+1;
    #}
    print "\n       },";

    #slab_memgrantreadcaps
    if(exists $slab_idtomemgrantreadcaps{$i}){
        printf("\n       0x%08x,", $slab_idtomemgrantreadcaps{$i});
    }else{
        printf("\n       0x00000000UL,");
    }

    #slab_memgrantwritecaps
    if(exists $slab_idtomemgrantwritecaps{$i}){
        printf("\n       0x%08x,", $slab_idtomemgrantreadcaps{$i});
    }else{
        printf("\n       0x00000000UL,");
    }

    #slab_devices
    #if($slab_idtotype{$i} eq "uVU_SLAB" && $slab_idtosubtype{$i} eq "XRICHGUEST"){
    #    print "\n	    {true, 0xFFFFFFFFUL, {0}},";
    #}else{
    #    print "\n	    {false, 0, {0}},";
    #}

    #incl_devices
    print "\n\n".$slab_idtordinclentries{$i};

    #incl_devices_count
    printf("\n0x%08x,", $slab_idtordinclcount{$i});

    #excl_devices
    print "\n\n".$slab_idtordexclentries{$i};

    #excl_devices_count
    printf("\n0x%08x,", $slab_idtordexclcount{$i});


    #slab_physmem_extents
    print "\n	    {";
    print "\n	        {.addr_start = _slab_$slab_idtoname{$i}_code_start, .addr_end = _slab_$slab_idtoname{$i}_code_end, .protection = 0},";
    print "\n	        {.addr_start = _slab_$slab_idtoname{$i}_data_start, .addr_end = _slab_$slab_idtoname{$i}_data_end, .protection = 0},";
    print "\n	        {.addr_start = _slab_$slab_idtoname{$i}_stack_start, .addr_end = _slab_$slab_idtoname{$i}_stack_end, .protection = 0},";
    print "\n	        {.addr_start = _slab_$slab_idtoname{$i}_dmadata_start, .addr_end = _slab_$slab_idtoname{$i}_dmadata_end, .protection = 0},";
    print "\n	    },";

    #slab_entrystub
    print "\n	    (u32)_slab_$slab_idtoname{$i}_entrypoint";

    print "\n	},";
	print "\n";

	$i++;
}

print "\n};";


exit 0;






















######
# parses a gsm file and populates relevant global structures
######
sub parse_gsm {
    my($filename, $slabid, $totalslabs) = @_;
    my $i = 0;
    my $j = 0;
    my $slab_rdinclcount=0;
    my $slab_rdexclcount=0;
    my $slab_rdinclentriesstring="";
    my $slab_rdexclentriesstring="";
    my %slab_idtouapifnmask;
    my $slab_uapifnmaskstring = "";

    chomp($filename);
    tie my @array, 'Tie::File', $filename or die $!;

    #print "parse_gsm: $filename, $slabid...\n";

    $slab_rdinclentriesstring = $slab_rdinclentriesstring."{ \n";
    $slab_rdexclentriesstring = $slab_rdexclentriesstring."{ \n";

    while( $i <= $#array) {
        my $line = $array[$i];
        chomp($line);
        $line =~ s/^\s+|\s+$//g ;     # remove both leading and trailing whitespace

        my @lineentry = split(/:/, $line);

        if($lineentry[0] eq "S"){
            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";
            #lineentry[1] = name of destination slab that this slab calls
            if (exists $slab_idtocallmask{$slab_nametoid{$lineentry[1]}}){
                $slab_idtocallmask{$slab_nametoid{$lineentry[1]}} |= (1 << $slabid);
            }else {
                $slab_idtocallmask{$slab_nametoid{$lineentry[1]}} = (1 << $slabid);
            }

        }elsif( $lineentry[0] eq "U"){
            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";
            #lineentry[1] = destination slab name, lineentry[2] = uapifn
            if (exists $slab_idtouapifnmask{$slab_nametoid{$lineentry[1]}}){
                $slab_idtouapifnmask{$slab_nametoid{$lineentry[1]}} |= (1 << $lineentry[2]);
            }else{
                $slab_idtouapifnmask{$slab_nametoid{$lineentry[1]}} = (1 << $lineentry[2]);
            }

        }elsif( $lineentry[0] eq "RD"){
            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";
            #lineentry[1]=INCL or EXCL, lineentry[2] = vendor_id, lineentry[3] = device_id
            if ( $lineentry[1] eq "INCL"){
                if($slab_rdinclcount >= $g_maxincldevlistentries){
                    print "\nError: Too many RD INCL entries (max=$g_maxincldevlistentries)!";
                    exit 1;
                }
                $slab_rdinclentriesstring = $slab_rdinclentriesstring."\t{ .vendor_id= ".$lineentry[2].", .device_id= ".$lineentry[3]." },\n";
                $slab_rdinclcount = $slab_rdinclcount + 1;
            } elsif ( $lineentry[1] eq "EXCL"){
                if($slab_rdexclcount >= $g_maxexcldevlistentries){
                    print "\nError: Too many RD EXCL entries (max=$g_maxexcldevlistentries)!";
                    exit 1;
                }
                $slab_rdexclentriesstring = $slab_rdexclentriesstring."\t{ .vendor_id= ".$lineentry[2].", .device_id= ".$lineentry[3]." },\n";
                $slab_rdexclcount = $slab_rdexclcount + 1;
            }else {
                print "\nError: Illegal RD entry qualifier ($lineentry[1])!";
                exit 1;
            }

        }elsif( $lineentry[0] eq "RM"){
            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";
            #lineentry[1]=READ or WRITE, lineentry[2] = slabname
            if ( $lineentry[1] eq "READ"){

                if (exists $slab_idtomemgrantreadcaps{$slabid}){
                    $slab_idtomemgrantreadcaps{$slabid} |= (1 << $slab_nametoid{$lineentry[2]});
                }else{
                    $slab_idtomemgrantreadcaps{$slabid} = (1 << $slab_nametoid{$lineentry[2]});
                }


            } elsif ( $lineentry[1] eq "WRITE"){

                if (exists $slab_idtomemgrantwritecaps{$slabid}){
                    $slab_idtomemgrantwritecaps{$slabid} |= (1 << $slab_nametoid{$lineentry[2]});
                }else{
                    $slab_idtomemgrantwritecaps{$slabid} = (1 << $slab_nametoid{$lineentry[2]});
                }

            }else {
                print "\nError: Illegal RM entry qualifier ($lineentry[1])!";
                exit 1;
            }


        }elsif( $lineentry[0] eq "RC"){

            #print $lineentry[0], $lineentry[1], $lineentry[2], $lineentry[3], $lineentry[4], "\n";

        }elsif( $lineentry[0] eq "MS"){
            #$lineentry[1]=DATA,CODE,STACK,DMADATA, $lineentry[2] = size in bytes
            if ( $lineentry[1] eq "DATA"){
                $slab_idtodatasize{$slabid} = $lineentry[2];
            } elsif ( $lineentry[1] eq "CODE"){
                $slab_idtocodesize{$slabid} = $lineentry[2];
            } elsif ( $lineentry[1] eq "STACK"){
                $slab_idtostacksize{$slabid} = $lineentry[2];
            } elsif ( $lineentry[1] eq "DMADATA"){
                $slab_idtodmadatasize{$slabid} = $lineentry[2];
            }else {
                print "\nError: Illegal MS entry qualifier ($lineentry[1])!";
                exit 1;
            }


        }else{
            #we don't know/care about this line, so just skip it
        }


        $i = $i +1;
    }

    if($slab_rdinclcount == 0){
        $slab_rdinclentriesstring = $slab_rdinclentriesstring."0 \n}, \n";
    }else{
        $slab_rdinclentriesstring = $slab_rdinclentriesstring."}, \n";
    }
    if($slab_rdexclcount == 0){
        $slab_rdexclentriesstring = $slab_rdexclentriesstring."0 \n}, \n";
    }else{
        $slab_rdexclentriesstring = $slab_rdexclentriesstring."}, \n";
    }

    $slab_idtordinclentries{$slabid} = $slab_rdinclentriesstring;
    $slab_idtordexclentries{$slabid} = $slab_rdexclentriesstring;
    $slab_idtordinclcount{$slabid} = $slab_rdinclcount;
    $slab_idtordexclcount{$slabid} = $slab_rdexclcount;

    while($j < $totalslabs){
        $slab_uapifnmaskstring = $slab_uapifnmaskstring.sprintf("\t0x%08x,\n", $slab_idtouapifnmask{$j});
        $j=$j+1;
    }


    return $slab_uapifnmaskstring;

}



