#!/usr/bin/expect -f 
# 
#   Connect up to a device on a serial port 
#   Time stamp any incoming lines to stdout

       # port is any serial port (omit the /dev/ prefix) 
       # e.g. ttya, cua0, serialA, serialB, boca01 - boca16

# Jon based this on:
# http://www.aps.anl.gov/Sectors/33_34/controls/docs/serialWatch.html

# This script expects to be invoked from a shell script that defines
# lots of environment variables that start with FIRST_ and SECOND_.
# Its purpose in life is to manually supply boot parameters to grub's
# interactive command prompt.  This is easier than maintaining a bunch
# of distinct /boot disk images for each test host.  It solves three
# problems as compared to disk images:
# 1. Allows Intel systems to get their necessary SINIT module
# 2. Avoids the need to write to /boot (no 'savedefault' option)
# 3. Unique ISCSI_INITIATOR per client system
# 4. Any other kernel or hypervisor command line options as desired

# Uncomment this line to enable extremely verbose debug info.
# exp_internal -f internal.log 1

if {$argc != 1} { 
  puts "$argc, $argv" 
  puts "usage: serial.exp port" 
  exit 
}

proc timeStamp {} { 
  global tcl_version 
  if {$tcl_version >= 7.5} { 
    # "clock" command requires Tcl v7.5 or greater 
    # internal routine a little faster than making a system call 
    set stamp [clock format [clock seconds] -format %Y-%m-%d,%T] 
  } else { 
    # fall back to standard UNIX system call 
    set stamp [exec /bin/date +%Y-%m-%d,%T] 
  } 
  return $stamp 
}

puts "\n[timeStamp] Log starting..." 
set port /dev/$argv 
set spawned [spawn -open [open $port w+]] 
puts "[timeStamp]: [string trim $spawned \r\n]" 
set baud 115200
    # -parenb means don't use a parity bit 
    # -cstopb means "not 2 stop bits, but 1" 
    # cs8 means 8 bits 
    # -echo means no echo (full duplex?) 
stty ispeed $baud ospeed $baud raw -echo cs8 -parenb -cstopb onlcr < $port 

set timeout 60
set send_slow {1 .05}
#log_file foo.log
log_user 1

expect "Press any key to continue."
send -s "c"

expect "command-line."
send -s "c"

expect "grub>"
send -s "$env(FIRST_ROOT)\r\n"

expect "grub>"
send -s "$env(FIRST_KERNEL)\r\n"

expect "grub>"
send -s "$env(FIRST_MOD1)\r\n"

expect "grub>"
send -s "$env(FIRST_MOD2)\r\n"

expect "grub>"
send -s "$env(FIRST_MOD3)\r\n"

expect "grub>"
send -s "boot\r\n"

log_user 0
while {1} { 
    expect { 
        "Press any key to continue." {
            send -s "c"
            break
        }
        "\n" { 
            puts "[timeStamp]: [string trim $expect_out(buffer) \r\n]" 
            # send_log -- "[timeStamp]: [string trim $expect_out(buffer) \r\n]"
        }
    }
}

log_user 1

expect "command-line."
send -s "c"

expect "grub>"
send -s "$env(SECOND_ROOT)\r\n"

expect "grub>"
send -s "$env(SECOND_KERNEL)\r\n"

expect "grub>"
send -s "$env(SECOND_MOD1)\r\n"

expect "grub>"
send -s "boot\r\n"

log_user 0
while {1} { 
    expect { 
        "\n" { 
            puts "[timeStamp]: [string trim $expect_out(buffer) \r\n]" 
            # send_log -- "[timeStamp]: [string trim $expect_out(buffer) \r\n]"
        }
        "REGRESSION TESTING COMPLETED." {
            exit
        }
    }
}
