<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>W5300 - SOCKET APIs: SOCKET_REG</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SOCKET_REG<br>
<small>
[<a class="el" href="group___i_i_n_c_h_i_p___r_e_g.html">IINCHIP_REG</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<code>SOCKET</code> register group<br>
 SOCKET_REG configures and control <code>SOCKETn</code> which is necessary to a data communication. <br>
 It includes registers from <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR</a> to <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10">Sn_RX_FIFOR</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1" title="SOCKETn mode register">Sn_MR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gc566cdc416b021136bf0c0673e3e44d6" title="SOCKETn command register">Sn_CR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ge27b7f46a809601071f77362d430240f" title="SOCKETn interrupt mask register">Sn_IMR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2054e0221824ec7469e54f7b61ddaea9" title="SOCKETn interrupt register">Sn_IR</a> : <code>SOCKETn</code> Control <p>
<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4499795fb09c886fe6fedf4275add011" title="SOCKETn status register">Sn_SSR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2c78cc9b8bbd32ab7771ea6fce3b20bb" title="SOCKETn source port register">Sn_PORTR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g32f5964cdea60f653dff0b71f76f7e3d" title="SOCKETn destination hardware address register">Sn_DHAR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ga8ecdfe46e7806fb698c07ef8882194d" title="SOCKETn destination port register">Sn_DPORTR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g46949c5aed1c0ef1abe2353cf55a9d56" title="SOCKETn destination IP address register">Sn_DIPR</a> : <code>SOCKETn</code> Information <p>
<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4c0679d6d132651861d71e1f6e5d91de" title="SOCKETn maximum segment size register">Sn_MSSR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g1255fc7f2b340e51f4ad10c2e9896616" title="SOCKETn keep alive timer register">Sn_KPALVTR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gf0eb8514d24e20bf6ec51c7b966a83d8" title="SOCKETn protocol of IP header field register">Sn_PROTOR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g9c77be7d60ac5dee97cf212ce059a273" title="SOCKETn IP type of service(TOS) register">Sn_TOSR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g5a769be7546a09f3c61a8c4ca3a8ce8e" title="SOCKETn IP time to live(TTL) register">Sn_TTLR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g3ebe2655ecaaed47f35e35302cf46235" title="SOCKETn fragment register">Sn_FRAGR</a> : Internet protocol. <p>
<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ge6cfc4b3509216b2999aa410b86a7c37" title="SOCKETn TX write size register">Sn_TX_WRSR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g91d0cb53e22206b143b192e59aca4511" title="SOCKETn TX free size register">Sn_TX_FSR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g26baffcadf156ecb78ff9fda970e7abf" title="SOCKETn RX received size register">Sn_RX_RSR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ga9618a9d3252f21e1d9b21d901ccea20" title="SOCKETn TX FIFO register">Sn_TX_FIFOR</a>, <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10" title="SOCKET n RX FIFO register">Sn_RX_FIFOR</a> : Data communication </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x00)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> mode register  <a href="#g18016b523eb28c77453dd5d1bd04e8e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gc566cdc416b021136bf0c0673e3e44d6">Sn_CR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x02)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> command register  <a href="#gc566cdc416b021136bf0c0673e3e44d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ge27b7f46a809601071f77362d430240f">Sn_IMR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x04)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> interrupt mask register  <a href="#ge27b7f46a809601071f77362d430240f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2054e0221824ec7469e54f7b61ddaea9">Sn_IR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x06)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> interrupt register  <a href="#g2054e0221824ec7469e54f7b61ddaea9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4499795fb09c886fe6fedf4275add011">Sn_SSR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x08)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> status register  <a href="#g4499795fb09c886fe6fedf4275add011"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2c78cc9b8bbd32ab7771ea6fce3b20bb">Sn_PORTR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x0A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> source port register  <a href="#g2c78cc9b8bbd32ab7771ea6fce3b20bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g32f5964cdea60f653dff0b71f76f7e3d">Sn_DHAR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x0C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> destination hardware address register  <a href="#g32f5964cdea60f653dff0b71f76f7e3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ga8ecdfe46e7806fb698c07ef8882194d">Sn_DPORTR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x12)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> destination port register  <a href="#ga8ecdfe46e7806fb698c07ef8882194d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g46949c5aed1c0ef1abe2353cf55a9d56">Sn_DIPR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x14)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> destination IP address register  <a href="#g46949c5aed1c0ef1abe2353cf55a9d56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4c0679d6d132651861d71e1f6e5d91de">Sn_MSSR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x18)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> maximum segment size register  <a href="#g4c0679d6d132651861d71e1f6e5d91de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gf0eb8514d24e20bf6ec51c7b966a83d8">Sn_PROTOR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x1A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> protocol of IP header field register  <a href="#gf0eb8514d24e20bf6ec51c7b966a83d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g1255fc7f2b340e51f4ad10c2e9896616">Sn_KPALVTR</a>(n)&nbsp;&nbsp;&nbsp;Sn_PROTOR(n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> keep alive timer register  <a href="#g1255fc7f2b340e51f4ad10c2e9896616"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g9c77be7d60ac5dee97cf212ce059a273">Sn_TOSR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x1C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> IP type of service(TOS) register  <a href="#g9c77be7d60ac5dee97cf212ce059a273"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g5a769be7546a09f3c61a8c4ca3a8ce8e">Sn_TTLR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x1E)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> IP time to live(TTL) register  <a href="#g5a769be7546a09f3c61a8c4ca3a8ce8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ge6cfc4b3509216b2999aa410b86a7c37">Sn_TX_WRSR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x20)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> TX write size register  <a href="#ge6cfc4b3509216b2999aa410b86a7c37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g91d0cb53e22206b143b192e59aca4511">Sn_TX_FSR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x0024)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> TX free size register  <a href="#g91d0cb53e22206b143b192e59aca4511"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g26baffcadf156ecb78ff9fda970e7abf">Sn_RX_RSR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x0028)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> RX received size register  <a href="#g26baffcadf156ecb78ff9fda970e7abf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g3ebe2655ecaaed47f35e35302cf46235">Sn_FRAGR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x002C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> fragment register  <a href="#g3ebe2655ecaaed47f35e35302cf46235"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ga9618a9d3252f21e1d9b21d901ccea20">Sn_TX_FIFOR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x2E)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKETn</code> TX FIFO register  <a href="#ga9618a9d3252f21e1d9b21d901ccea20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10">Sn_RX_FIFOR</a>(n)&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x30)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code>SOCKET</code> n RX FIFO register  <a href="#gcea0f351173afeac324c119b4537ab10"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="gc566cdc416b021136bf0c0673e3e44d6"></a><!-- doxytag: member="w5300.h::Sn_CR" ref="gc566cdc416b021136bf0c0673e3e44d6" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_CR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x02)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> command register 
<p>
RESET : 0x--00 <br>
 It sets command type such as open, close, connect, listen, send, recv for <code>SOCKETn</code>. Command type defines as the following<ul>
<li><a class="el" href="w5300_8h.html#3f4044fe5c1bf9e70b31805212bf5474">Sn_CR_OPEN</a> : Uses in all protocol(TCP,UDP,IP raw, MAC raw, PPPoE).</li><li><a class="el" href="w5300_8h.html#d51efeaeeaa7262f9d20b0dc2a6a3fa0">Sn_CR_LISTEN</a> : Uses in TCP (only 'TCP-SERVER' mode)</li><li><a class="el" href="w5300_8h.html#7a2f5db2ee176886bb12065f91be2973">Sn_CR_CONNECT</a> : Uses in TCP (only 'TCP-CLIENT' mode)</li><li><a class="el" href="w5300_8h.html#ccca8838cb8d1b4d859fc34f6e8ea605">Sn_CR_DISCON</a> : Uses in TCP (both 'TCP-SERVER' and 'TCP-CLIENT' mode)</li><li><a class="el" href="w5300_8h.html#5a404e5aa37ab05315c465c7902a4134">Sn_CR_CLOSE</a> : Uses in all protocol.</li><li><a class="el" href="w5300_8h.html#77bad5ce966d13306653a83b47a3caed">Sn_CR_SEND</a> : Uses in all protocol.</li><li><a class="el" href="w5300_8h.html#f610323614efc4011feff02ede392939">Sn_CR_SEND_MAC</a> : Uses in UDP and IP raw.</li><li><a class="el" href="w5300_8h.html#2f256f6b27ce37836cc08d4f7f36ab62">Sn_CR_SEND_KEEP</a> : Uses in TCP (both 'TCP-SERVER' and 'TCP-CLIENT' mode).</li><li><a class="el" href="w5300_8h.html#282df6e5d976e94953d4f9f32f182827">Sn_CR_RECV</a> : Uses in all.</li><li><a class="el" href="w5300_8h.html#79d28ee84b24abfe2cd3c1ca72fb1d7e">Sn_CR_PCON</a> : Uses in PPPoE.</li><li><a class="el" href="w5300_8h.html#8dd155f9910fa606ccda925504da4045">Sn_CR_PDISCON</a> : Uses in PPPoE.</li><li><a class="el" href="w5300_8h.html#9acb4b9b02eaabaa9a55c3706c264b19">Sn_CR_PCR</a> : Uses in PPPoE.</li><li><a class="el" href="w5300_8h.html#5c385b15561473714786664b5be5151c">Sn_CR_PCN</a> : Uses in PPPoE.</li><li><a class="el" href="w5300_8h.html#7e6602fb4ee7701b07c69298aced4b00">Sn_CR_PCJ</a> : Uses in PPPoE. </li></ul>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00577">577</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00295">getSn_CR()</a>, and <a class="el" href="w5300_8c-source.html#l00299">setSn_CR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g32f5964cdea60f653dff0b71f76f7e3d"></a><!-- doxytag: member="w5300.h::Sn_DHAR" ref="g32f5964cdea60f653dff0b71f76f7e3d" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_DHAR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x0C)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> destination hardware address register 
<p>
It sets or is set as destination hardware address of <code>SOCKETn</code>. Also, if <code>SOCKET0</code> is used for PPPoE mode, <code>S0_DHAR</code> sets as PPPoE server hardware address that is already known.<br>
<br>
<ul>
<li>When using <a class="el" href="w5300_8h.html#f610323614efc4011feff02ede392939">Sn_CR_SEND_MAC</a> at the UDP or IPRAW mode, <br>
 it sets destination hardware address of <code>SOCKETn</code>.</li><li>At the TCP, UDP and IPRAW mode, <br>
 <code>Sn_DHAR</code> is set as destination hardware address that is acquired by ARP-process of <a class="el" href="w5300_8h.html#7a2f5db2ee176886bb12065f91be2973">Sn_CR_CONNECT</a> or <a class="el" href="w5300_8h.html#77bad5ce966d13306653a83b47a3caed">Sn_CR_SEND</a>. The host can acquire the destination hardware address through <code>Sn_DHAR</code> after successfully performing <a class="el" href="w5300_8h.html#7a2f5db2ee176886bb12065f91be2973">Sn_CR_CONNECT</a> or <a class="el" href="w5300_8h.html#77bad5ce966d13306653a83b47a3caed">Sn_CR_SEND</a>.</li><li>When using PPPoE-process of <b>W5300</b>, <br>
 PPPoE server hardware address is not required to be set. However, even if PPPoE-process of <b>W5300</b> is not used but implemented by yourself with MACRAW mode, in order to transmit or receive the PPPoE packet, PPPoE server hardware address (acquired by your PPPoE-process), PPPoE server IP address, and PPP session ID <b>should</b> be set, and <a class="el" href="group___m_o_d_e___r_e_g.html#g9ecbd9f86f95534f1bcf71015d5ae81a" title="Mode register.">MR(PPPoE)</a> also <b>should</b> be set as '1'. <code>S0_DHAR</code> sets PPPoE server hardware address before <a class="el" href="w5300_8h.html#3f4044fe5c1bf9e70b31805212bf5474">Sn_CR_OPEN</a>. PPPoE server hardware address which is set by <code>S0_DHAR</code> is applied to <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#gcf9041e8c31a5c732bb306053e8916c7">PDHAR</a> after <a class="el" href="w5300_8h.html#3f4044fe5c1bf9e70b31805212bf5474">Sn_CR_OPEN</a>. The configured PPPoE information is internally valid even after <a class="el" href="w5300_8h.html#5a404e5aa37ab05315c465c7902a4134">Sn_CR_CLOSE</a>. </li></ul>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00709">709</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00348">getSn_DHAR()</a>, and <a class="el" href="w5300_8c-source.html#l00358">setSn_DHAR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g46949c5aed1c0ef1abe2353cf55a9d56"></a><!-- doxytag: member="w5300.h::Sn_DIPR" ref="g46949c5aed1c0ef1abe2353cf55a9d56" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_DIPR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x14)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> destination IP address register 
<p>
It sets or is set as destination IP address of <code>SOCKETn</code>.<br>
 If <code>SOCKET0</code> is used as PPPoE mode, <code>S0_DIPR</code> sets PPPoE server IP address that is already known. It is valid only in TCP, UDP, IPRAW or PPPoE mode, but ignored in MACRAW mode.<ul>
<li>At the TCP mode,<br>
 when operating as "TCP CLIENT" it sets as IP address of "TCP SERVER" before <a class="el" href="w5300_8h.html#7a2f5db2ee176886bb12065f91be2973">Sn_CR_CONNECT</a>, And when operating as "TCP SERVER", it is internally set as IP address of "TCP CLIENT" after successfully establishing connection.</li><li>At the UDP or IPRAW mode,<br>
 <code>Sn_DIPR</code> sets as destination IP address to be used for transmitting UDP or IPRAW <b>DATA</b> packet before <a class="el" href="w5300_8h.html#77bad5ce966d13306653a83b47a3caed">Sn_CR_SEND</a> or Sn_CR_SEND_MAC.</li><li>At the PPPoE mode,<br>
 <code>S0_DIPR</code> sets as PPPoE server IP address that is already known. Refer to the description of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g32f5964cdea60f653dff0b71f76f7e3d">Sn_DHAR</a> in PPPoE mode. </li></ul>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00758">758</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="socket_8c-source.html#l00086">connect()</a>, <a class="el" href="w5300_8c-source.html#l00377">getSn_DIPR()</a>, <a class="el" href="socket_8c-source.html#l00284">sendto()</a>, and <a class="el" href="w5300_8c-source.html#l00386">setSn_DIPR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga8ecdfe46e7806fb698c07ef8882194d"></a><!-- doxytag: member="w5300.h::Sn_DPORTR" ref="ga8ecdfe46e7806fb698c07ef8882194d" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_DPORTR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x12)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> destination port register 
<p>
It sets as destination port number of <code>SOCKETn</code>. If <code>SOCKET0</code> is used as PPPoE mode, <code>S0_DPORTR</code> sets PPP session ID that is already known. It is valid only in TCP, UDP or PPPoE mode, and ignored in other modes.<ul>
<li>At the TCP mode, <br>
 when operating as "TCP CLIENT" it sets as the listen port number of "TCP SERVER" before <a class="el" href="w5300_8h.html#7a2f5db2ee176886bb12065f91be2973">Sn_CR_CONNECT</a>.</li><li>At the UDP mode, <br>
 <code>Sn_DPORTR</code> sets as the destination port number to be used for transmitting UDP <b>DATA</b> packet before <a class="el" href="w5300_8h.html#77bad5ce966d13306653a83b47a3caed">Sn_CR_SEND</a> or <a class="el" href="w5300_8h.html#f610323614efc4011feff02ede392939">Sn_CR_SEND_MAC</a>.</li><li>At the PPPoE mode, <code>S0_DPORTR</code> sets as PPP session ID that is already known. PPP session ID (set by <code>S0_DPORTR</code>) is applied to <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g38623bdb10024e303a5dcd7a443bd89c">PSIDR</a> after <a class="el" href="w5300_8h.html#3f4044fe5c1bf9e70b31805212bf5474">Sn_CR_OPEN</a>. Refer to the description of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g32f5964cdea60f653dff0b71f76f7e3d">Sn_DHAR</a> in PPPoE mode. </li></ul>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00735">735</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="socket_8c-source.html#l00086">connect()</a>, <a class="el" href="socket_8c-source.html#l00284">sendto()</a>, and <a class="el" href="w5300_8c-source.html#l00372">setSn_DPORTR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3ebe2655ecaaed47f35e35302cf46235"></a><!-- doxytag: member="w5300.h::Sn_FRAGR" ref="g3ebe2655ecaaed47f35e35302cf46235" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_FRAGR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x002C)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> fragment register 
<p>
It sets the fragment field of the IP header at the IP layer. <b>W5300</b> does <b>not</b> support the packet fragment at the IP layer. Even though <code>Sn_FRAGR</code> is configured, IP data is not fragmented. And its configuration is <b>not</b> recommended. It <b>should</b> be configured before <a class="el" href="w5300_8h.html#3f4044fe5c1bf9e70b31805212bf5474">Sn_CR_OPEN</a>. 
<p>Definition at line <a class="el" href="w5300_8h-source.html#l00934">934</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00501">getSn_FRAGR()</a>, and <a class="el" href="w5300_8c-source.html#l00506">setSn_FRAGR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge27b7f46a809601071f77362d430240f"></a><!-- doxytag: member="w5300.h::Sn_IMR" ref="ge27b7f46a809601071f77362d430240f" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_IMR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x04)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> interrupt mask register 
<p>
RESET : 0x--FF <br>
 It configures the interrupt of <code>SOCKETn</code> so as to notify to the host.<br>
 Interrupt mask bit of Sn_IMR corresponds to interrupt bit of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2054e0221824ec7469e54f7b61ddaea9">Sn_IR</a>. If interrupt occurs in any <code>SOCKET</code> and the bit is set as '1', its corresponding bit of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2054e0221824ec7469e54f7b61ddaea9">Sn_IR</a> is set as '1'. <br>
 When the bits of Sn_IMR and <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2054e0221824ec7469e54f7b61ddaea9">Sn_IR</a> are '1', <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g68e22635ff207d8ca10459833856bd75">IR(n)</a> becomes '1'. At this time, if <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g30fd4faef73fc23b1f09a0bd643455c1">IMR(n)</a> is '1', the interrupt is issued to the host. 
<p>Definition at line <a class="el" href="w5300_8h-source.html#l00593">593</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00305">getSn_IMR()</a>, and <a class="el" href="w5300_8c-source.html#l00309">setSn_IMR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2054e0221824ec7469e54f7b61ddaea9"></a><!-- doxytag: member="w5300.h::Sn_IR" ref="g2054e0221824ec7469e54f7b61ddaea9" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_IR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x06)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> interrupt register 
<p>
RESET : 0x--00 <br>
 It is the register to notify interrupt type (establishment, termination, receiving data, timeout) of SOCKENTn to the host. <br>
 When any interrupt occurs and the mask bit of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ge27b7f46a809601071f77362d430240f">Sn_IMR</a> is '1', the interrupt bit of Sn_IR becomes '1'. In order to clear the bit of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2054e0221824ec7469e54f7b61ddaea9">Sn_IR</a> which is set as '1', the host <b>should</b> write the bit as '1'. <br>
 When all the bits of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2054e0221824ec7469e54f7b61ddaea9">Sn_IR</a> is cleared as '0', <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g68e22635ff207d8ca10459833856bd75">IR(n)</a> is <b>automatically</b> cleared.<br>
<br>
<p>
The interrupt type defines as the following<ul>
<li><a class="el" href="w5300_8h.html#a0d44177fb3ae0d39f0433ce0ca69fb6">Sn_IR_PRECV</a> : 7 bit, PPP Receive Interrupt</li><li><a class="el" href="w5300_8h.html#1e7c69a32cf2d69069ac98fd8c884e31">Sn_IR_PFAIL</a> : 6 bit, PPP Fail Interrupt</li><li><a class="el" href="w5300_8h.html#ea7f84b8fb05284cded5f7fff842f79f">Sn_IR_PNEXT</a> : 5 bit, PPP Next Phase Interrupt</li><li><a class="el" href="w5300_8h.html#8973589ea9a777133aa1bec1c03298c9">Sn_IR_SENDOK</a> : 4 bit, SEND OK Interrupt</li><li><a class="el" href="w5300_8h.html#d6824296c8047b1f8963e20ea8283b02">Sn_IR_TIMEOUT</a> : 3 bit, TIMEOUT Interrupt</li><li><a class="el" href="w5300_8h.html#16ff1d53b8a4f4021169224008d4bad1">Sn_IR_RECV</a> : 2 bit, Receive Interrupt</li><li><a class="el" href="w5300_8h.html#8a702b3d763f3f9ac1c4ea316d605308">Sn_IR_DISCON</a> : 1 bit, Disconnect Interrupt</li><li><a class="el" href="w5300_8h.html#ab062cd504413d28bab4ddb338f6ff35">Sn_IR_CON</a> : 0 bit, Connect Interrupt </li></ul>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00621">621</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00314">getSn_IR()</a>, <a class="el" href="w5300_8c-source.html#l00536">iinchip_irq()</a>, and <a class="el" href="w5300_8c-source.html#l00322">setSn_IR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g1255fc7f2b340e51f4ad10c2e9896616"></a><!-- doxytag: member="w5300.h::Sn_KPALVTR" ref="g1255fc7f2b340e51f4ad10c2e9896616" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_KPALVTR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;Sn_PROTOR(n)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> keep alive timer register 
<p>
It is 1 byte register that sets transmitting timer of KEEP ALIVE(<b>KA</b>) packet of <code>SOCKETn</code>. It is valid only in TCP mode, and ignored in other modes. The unit is <b>5</b> seconds.<br>
 <b>KA</b> packet can be transmitted after <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4499795fb09c886fe6fedf4275add011">Sn_SSR</a> is changed to <a class="el" href="w5300_8h.html#9cdcdeddeeb7b7bf82bbc5eb415f677c">SOCK_ESTABLISHED</a> and more than one time <b>DATA</b> packet transmitting or receiving.<ul>
<li>In case of '<code>Sn_KPALVTR</code> &gt; 0', <br>
 <b>W5300</b> automatically transmits <b>KA</b> packet after time-period, and checks TCP connection(Auto-keep-alive-process). <br>
</li><li>In case of '<code>Sn_KPALVTR</code> = 0', Auto-keep-alive-process does not operate, and <b>KA</b> packet can be transmitted by <a class="el" href="w5300_8h.html#2f256f6b27ce37836cc08d4f7f36ab62">Sn_CR_SEND_KEEP</a>(Manual-keep-alive-process). Manual-keep-alive-process is ignored in case of '<code>Sn_KPALVTR</code> &gt; 0'</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Be <b>careful</b> of writting a value to it when using 16bit data bus width(<a class="el" href="w5300_8h.html#4e725009267278c39126e215a95c393e">MR_DBW</a> = '1'). </dd></dl>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00846">846</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00405">getSn_KPALVTR()</a>, and <a class="el" href="w5300_8c-source.html#l00410">setSn_KPALVTR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g18016b523eb28c77453dd5d1bd04e8e1"></a><!-- doxytag: member="w5300.h::Sn_MR" ref="g18016b523eb28c77453dd5d1bd04e8e1" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_MR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x00)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> mode register 
<p>
RESET : 0x0000 <br>
 It configures the protocol type or option of <code>SOCKETn</code>. Each bit of Sn_MR defines as the following<ul>
<li><a class="el" href="w5300_8h.html#eaa24ab8cd0c2a4dd8af7e5cc1e95488">Sn_MR_ALIGN</a> : 8 bit</li><li><a class="el" href="w5300_8h.html#c93105c327d64a318d7388c31ccb5075">Sn_MR_MULTI</a> : 7 bit</li><li><a class="el" href="w5300_8h.html#ee30c1b91458498c61c4b9958e31bfc1">Sn_MR_MF</a> : 6 bit</li><li><a class="el" href="w5300_8h.html#82bfbc5d456722cbe5200317860d3fb8">Sn_MR_IGMPv</a>, <a class="el" href="w5300_8h.html#ffbdfabc2d0bb33ef649d916506f040e">Sn_MR_ND</a> : 5 bit</li><li><a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1" title="SOCKETn mode register">Sn_MR(P3:P0)</a> : 3~0 bit. This bits are defined as the following.<ol type=a>
<li><a class="el" href="w5300_8h.html#80e8e39522a1df333f5ebee0873ac878">Sn_MR_CLOSE</a></li><li><a class="el" href="w5300_8h.html#111a5f7d5eb14054bd5a895dabad372d">Sn_MR_TCP</a></li><li><a class="el" href="w5300_8h.html#1a31c891ae1c9cf808542b96ae8fdeb8">Sn_MR_UDP</a></li><li><a class="el" href="w5300_8h.html#e2eb5ec5fdac56d474184b34db00d92a">Sn_MR_IPRAW</a></li><li><a class="el" href="w5300_8h.html#8426a69a5d58f909bb1c7ce12afad0a5">Sn_MR_MACRAW</a></li><li><a class="el" href="w5300_8h.html#8971fc245493cc0ff2a6e7b2df484a13">Sn_MR_PPPoE</a> </li></ol>
</li></ul>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00551">551</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00286">getSn_MR()</a>, <a class="el" href="socket_8c-source.html#l00217">recv()</a>, <a class="el" href="socket_8c-source.html#l00342">recvfrom()</a>, <a class="el" href="w5300_8c-source.html#l00290">setSn_MR()</a>, and <a class="el" href="socket_8c-source.html#l00038">socket()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4c0679d6d132651861d71e1f6e5d91de"></a><!-- doxytag: member="w5300.h::Sn_MSSR" ref="g4c0679d6d132651861d71e1f6e5d91de" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_MSSR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x18)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> maximum segment size register 
<p>
It sets MTU(Maximum Transfer Unit) of <code>SOCKETn</code> or notifies MTU that is already set. If the host does not set the <code>Sn_MSSR</code>, it is set as default MTU. It just supports TCP or UDP mode.<ul>
<li>When using PPPoE (<a class="el" href="group___m_o_d_e___r_e_g.html#g9ecbd9f86f95534f1bcf71015d5ae81a">MR</a>(<a class="el" href="w5300_8h.html#9c9560815fe3ca6ef4aa85fb3d82d007">MR_PPPoE</a>)='1'), <br>
 the MTU of TCP or UDP mode is assigned in the range of MTU of PPPoE.</li><li>At the IPRAW or MACRAW,<br>
 MTU is not processed internally, but default MTU is used. Therefore, when transmitting the data bigger than default MTU, the host <b>should</b> <b>manually</b> divide the data into the unit of default MTU.</li><li>At the TCP or UDP mode, <br>
 if transmitting data is bigger than MTU, W5300 <b>automatically</b> divides the data into the unit of MTU. MTU is called as MSS at the TCP mode. By selecting from Host-Written-Value and peer's MSS, MSS is set as smaller value through TCP connection process.</li></ul>
<p>
Below is the default MTU according to <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR(P3:P0)</a>.<p>
<div align="center">
<img src="MTU.jpg" alt="MTU.jpg">
<p><strong>&lt;The default MTU&gt;</strong></p></div>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>At the UDP mode,<br>
 there is no connection-process of TCP mode, and Host-Written-Value is just used. When communicating with the peer having different MTU, <b>W5300</b> is able to receive ICMP(Fragment MTU) packet. In this case, <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g68e22635ff207d8ca10459833856bd75">IR</a>(<a class="el" href="w5300_8h.html#3c5837fd0013e4f411887b2b4920cb09">IR_FMTU</a>) becomes '1', and the host can acquire the fragment MTU and destination IP address through <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g70f93824d374ecd8394fa92e73907c7d">FMTUR</a> and <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g6ce7e2945cd7d83c6f8c7f97bd9c27b0">UIPR</a> respectively. In case of <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g68e22635ff207d8ca10459833856bd75">IR</a>(<a class="el" href="w5300_8h.html#3c5837fd0013e4f411887b2b4920cb09">IR_FMTU</a>)='1', the UDP communication with the peer, is not possible. So, you should close the <code>SOCKET</code>, set <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g70f93824d374ecd8394fa92e73907c7d">FMTUR</a> as <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4c0679d6d132651861d71e1f6e5d91de">Sn_MSSR</a> and retry the communication with <a class="el" href="w5300_8h.html#3f4044fe5c1bf9e70b31805212bf5474">Sn_CR_OPEN</a>.</dd></dl>
<dl compact><dt><b><a class="el" href="warning.html#_warning000004">Warning:</a></b></dt><dd></dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If HOST set a value to <code>Sn_MSSR</code>, the value keeps on the MTU of SOCKETn regardless of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR</a> and <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4499795fb09c886fe6fedf4275add011">Sn_SSR</a>. For example, If Sn_MSSR set a smaller value than the default MTU by HOST or peer, even though the SOCKETn is closed and then reopened with a different protocol, Sn_MSSR keeps on the previous written value and does't not recovery the default value. If you want to recovery the default MTU value according to the protocol(<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR(P3:P0)</a>), Write Sn_MSSR to '0xFFFF' before <code>SOCKETn</code> is opened. <div class="fragment"><pre class="fragment">           set_Sn_MSSR(s,0xFFFF);
           <a class="code" href="socket_8h.html#8b0247cecfe600e1e8b0df8ed2e77e79" title="Open a SOCKET.">socket</a>(s,<a class="code" href="w5300_8h.html#111a5f7d5eb14054bd5a895dabad372d" title="Protocol bits of Sn_MR.">Sn_MR_TCP</a>,3000,0);  <span class="comment">// The MTU will be the default value of TCP(1460);</span>
</pre></div> </dd></dl>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00806">806</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00392">getSn_MSSR()</a>, and <a class="el" href="w5300_8c-source.html#l00397">setSn_MSSR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2c78cc9b8bbd32ab7771ea6fce3b20bb"></a><!-- doxytag: member="w5300.h::Sn_PORTR" ref="g2c78cc9b8bbd32ab7771ea6fce3b20bb" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_PORTR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x0A)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> source port register 
<p>
It sets source port number. It is valid when SOCKETn is used as TCP or UDP mode, and ignored when used as other. <dl class="note" compact><dt><b>Note:</b></dt><dd>It <b>should</b> be set before Sn_CR_OPEN. </dd></dl>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00680">680</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="socket_8c-source.html#l00038">socket()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gf0eb8514d24e20bf6ec51c7b966a83d8"></a><!-- doxytag: member="w5300.h::Sn_PROTOR" ref="gf0eb8514d24e20bf6ec51c7b966a83d8" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_PROTOR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x1A)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> protocol of IP header field register 
<p>
It is 1 byte register that sets protocol number field of IP header at the IP layer. It is valid only in IPRAW mode, and ignored in other modes. <code>Sn_PROTOR</code> is set before <a class="el" href="w5300_8h.html#3f4044fe5c1bf9e70b31805212bf5474">Sn_CR_OPEN</a>. <code>SOCKETn</code> opened as IPRAW mode, transmits and receives the data of protocol number set in <code>Sn_PROTOR</code>. <code>Sn_PROTOR</code> can be assigned in the range of 0x00 ~ 0xFF, but W5300 does not support TCP(0x06) and UDP(0x11) protocol number.<br>
 Protocol number is defined in <a href="http://www.iana.org/assignments/protocol-numbers">IANA</a> (Internet assigned numbers authority).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="w5300_8h.html#bf96615d54d7d81630efc2e8f1770223">IPPROTO_IP</a>, <a class="el" href="w5300_8h.html#98edd0af28e1b5f97c806c9cae442339">IPPROTO_ICMP</a>, <a class="el" href="w5300_8h.html#27694062feaa6fa3bd01d6df67f36762">IPPROTO_IGMP</a>, <a class="el" href="w5300_8h.html#aa167811bca5c964e9b051a10d962b1d">IPPROTO_GGP</a>, <a class="el" href="w5300_8h.html#94f83c72c1e5e6ef453e47cf59885fb5">IPPROTO_TCP</a>, <a class="el" href="w5300_8h.html#a05667a919736823cc5e264f7376b84a">IPPROTO_PUP</a>, <a class="el" href="w5300_8h.html#b332d40b15142f33a88d4fcb1d6a5920">IPPROTO_UDP</a>, <a class="el" href="w5300_8h.html#bfda09909326d0d4c6fe906fae58a960">IPPROTO_IDP</a>, <a class="el" href="w5300_8h.html#a863498e1c23af0986b3932c23251e77">IPPROTO_ND</a>, <a class="el" href="w5300_8h.html#0154c93d7a162b8576ee47e10be53239">IPPROTO_RAW</a>, etc.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Be <b>careful</b> of writting a value to it when using 16bit data bus width(<a class="el" href="w5300_8h.html#4e725009267278c39126e215a95c393e">MR_DBW</a> = '1'). </dd></dl>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00827">827</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00472">getSn_PROTOR()</a>, and <a class="el" href="w5300_8c-source.html#l00476">setSn_PROTOR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcea0f351173afeac324c119b4537ab10"></a><!-- doxytag: member="w5300.h::Sn_RX_FIFOR" ref="gcea0f351173afeac324c119b4537ab10" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_RX_FIFOR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x30)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKET</code> n RX FIFO register 
<p>
It indirectly accesses to internal RX memory of <code>SOCKETn</code>.<br>
 The internal RX memory can't be directly accessed by the host, but can be accessed through <code>Sn_RX_FIFOR</code>. If <a class="el" href="group___m_o_d_e___r_e_g.html#g9ecbd9f86f95534f1bcf71015d5ae81a">MR</a>(<a class="el" href="w5300_8h.html#8e95ded2155ed3f15eed5508e5b67e56">MR_MT</a>) = '0', only the Host-Read of internal RX memory is allowed through <code>Sn_RX_FIFOR</code>. But <a class="el" href="group___m_o_d_e___r_e_g.html#g9ecbd9f86f95534f1bcf71015d5ae81a">MR</a>(<a class="el" href="w5300_8h.html#8e95ded2155ed3f15eed5508e5b67e56">MR_MT</a>) = '1', both of Host-Read and Host-Write are allowed. It <b>should</b> be set as '0' after verifying the interface between <b>W5300</b> and the host system. (Refer to "How to Test Internal TX/RX memory").<p>
When the host reads the received <b>DATA</b> packet in internal RX memory through <code>Sn_RX_FIFOR</code> by 2 bytes, the low and high data in internal RX memory can be read through <code>Sn_RX_FIFOR0</code> and <code>Sn_RX_FIFOR1</code> respectively. The host performs Sn_CR_RECV after processing the received <b>DATA</b> packet in internal RX memory.<br>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is <b>not</b> allowed to access <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10">Sn_RX_FIFOR0</a> and <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10">Sn_RX_FIFOR1</a> right after accessing <code>Sn_TX_FIFOR0</code> and <code>Sn_TX_FIFOR1</code> when using 8bit data bus width(<a class="el" href="group___m_o_d_e___r_e_g.html#g9ecbd9f86f95534f1bcf71015d5ae81a">MR</a>(<a class="el" href="w5300_8h.html#4e725009267278c39126e215a95c393e">MR_DBW</a>='0'). These are cause for the incorrect read. In order to prevent this, after reading <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ga9618a9d3252f21e1d9b21d901ccea20">Sn_TX_FIFOR</a>, the host reads any register such as <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR</a> and then access <code>Sn_RX_FIFOR</code>. </dd></dl>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00979">979</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00464">getSn_RX_FIFOR()</a>, and <a class="el" href="w5300_8c-source.html#l00714">wiz_read_buf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g26baffcadf156ecb78ff9fda970e7abf"></a><!-- doxytag: member="w5300.h::Sn_RX_RSR" ref="g26baffcadf156ecb78ff9fda970e7abf" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_RX_RSR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x0028)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> RX received size register 
<p>
It informs the byte size of received data in internal RX memory of <code>SOCKETn</code>. The host can't read data through <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10">Sn_RX_FIFOR</a> as the size bigger than Sn_RX_RSR. So, after checking Sn_RX_RSR, the host read the received data though <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10">Sn_RX_FIFOR</a> smaller than or as same size as <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g26baffcadf156ecb78ff9fda970e7abf">Sn_RX_RSR</a>, and copies the data into the host system memory.<br>
 After memory copy, the host should inform the copy completion of data to <b>W5300</b> by <a class="el" href="w5300_8h.html#282df6e5d976e94953d4f9f32f182827">Sn_CR_RECV</a>. <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g26baffcadf156ecb78ff9fda970e7abf">Sn_RX_RSR</a> automatically decreases by 2bytes whenever the host reads <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10">Sn_RX_FIFOR</a>.<br>
 In case of '<code>Sn_RX_RSR</code> &gt; 0', there is one or more <b>DATA</b> packet in internal RX memory. And the received data <b>should</b> be processed in DATA packet unit. Refer to <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gcea0f351173afeac324c119b4537ab10">Sn_RX_FIFOR</a>. 
<p>Definition at line <a class="el" href="w5300_8h-source.html#l00920">920</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00444">getSn_RX_RSR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4499795fb09c886fe6fedf4275add011"></a><!-- doxytag: member="w5300.h::Sn_SSR" ref="g4499795fb09c886fe6fedf4275add011" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_SSR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x08)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> status register 
<p>
RESET : 0x--00 <br>
 It notifies <code>SOCKETn</code> status.<br>
 <code>SOCKETn</code> status can be changed by <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#gc566cdc416b021136bf0c0673e3e44d6">Sn_CR</a> or packet transmission/receipt. Sn_SSR values define as the following.<br>
<ul>
<li>Use in all mode<ol type=a>
<li><a class="el" href="w5300_8h.html#8e14b15b210852d2812514526de5c004">SOCK_CLOSED</a></li></ol>
</li><li>Use in TCP mode(<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR(P3:P0)</a> = <a class="el" href="w5300_8h.html#111a5f7d5eb14054bd5a895dabad372d">Sn_MR_TCP</a>)<ol type=a>
<li><a class="el" href="w5300_8h.html#a3ecdc449468d915c67d4a0323a5d21d">SOCK_INIT</a></li><li><a class="el" href="w5300_8h.html#912ab8726f570d29f6285d80ec130425">SOCK_LISTEN</a></li><li><a class="el" href="w5300_8h.html#7428968f08071a5ebd9ecf1f05e6e823">SOCK_SYNSENT</a></li><li><a class="el" href="w5300_8h.html#46a0f9a9fa055fa586a36d7f6606aaac">SOCK_SYNRECV</a></li><li><a class="el" href="w5300_8h.html#9cdcdeddeeb7b7bf82bbc5eb415f677c">SOCK_ESTABLISHED</a></li><li><a class="el" href="w5300_8h.html#3b15a9f2533a519938c870c70bc32a25">SOCK_FIN_WAIT</a></li><li><a class="el" href="w5300_8h.html#03809cd0a5ed29fd444de609381e9d96">SOCK_CLOSING</a></li><li><a class="el" href="w5300_8h.html#d4b1ed26ba978cbd8fa4bbbd52e1cbf6">SOCK_TIME_WAIT</a></li><li><a class="el" href="w5300_8h.html#9375ae181e82024c1ed2d44b4b51a2a6">SOCK_CLOSE_WAIT</a></li><li><a class="el" href="w5300_8h.html#2fe071fc2718917f051cedf9b2c582d3">SOCK_LAST_ACK</a></li></ol>
</li><li>Use in UDP mode(<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR(P3:P0)</a> = <a class="el" href="w5300_8h.html#1a31c891ae1c9cf808542b96ae8fdeb8">Sn_MR_UDP</a>)<ol type=a>
<li><a class="el" href="w5300_8h.html#ed90ae30cba33085bfc6a7212356c33a">SOCK_UDP</a></li></ol>
</li><li>Use in IPRAW mode(<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR(P3:P0)</a> = <a class="el" href="w5300_8h.html#e2eb5ec5fdac56d474184b34db00d92a">Sn_MR_IPRAW</a>)<ol type=a>
<li><a class="el" href="w5300_8h.html#4d12a3b266e7b5d8ce806f27aaf3a46b">SOCK_IPRAW</a></li></ol>
</li><li>Use in MACRAW mode(<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR(P3:P0)</a> = <a class="el" href="w5300_8h.html#8426a69a5d58f909bb1c7ce12afad0a5">Sn_MR_MACRAW</a>)<ol type=a>
<li><a class="el" href="w5300_8h.html#aa1a6ffb014a972dbbe82a7fc8b4673b">SOCK_MACRAW</a></li></ol>
</li><li>Use in PPPoE mode(<a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g18016b523eb28c77453dd5d1bd04e8e1">Sn_MR(P3:P0)</a> = <a class="el" href="w5300_8h.html#8971fc245493cc0ff2a6e7b2df484a13">Sn_MR_PPPoE</a>)<ol type=a>
<li><a class="el" href="w5300_8h.html#57eeef363120ec137726a3bcda02c0c3">SOCK_PPPoE</a></li></ol>
</li><li>Use in TCP, UDP and IPRAW mode<ol type=a>
<li><a class="el" href="w5300_8h.html#2734ae4e2287744356e7a2e75e8ef21e">SOCK_ARP</a></li></ol>
</li></ul>
<p>
Below show the transition of Sn_SSR. <div align="center">
<img src="SSR_Transition.jpg" alt="SSR_Transition.jpg">
<p><strong>&lt;Sn_SSR Transition Diagram&gt;</strong></p></div>
 <dl compact><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>At TCP communication, it happens that <code>Sn_SSR</code> value does't change the undefined status to the defined. This case is occurred because the previous TCP communication is abnormlay terminated when W5300 couldn't be receive the <b>ACK</b> packet of transmitted <b>DATA</b> from the peer. That is, <code>SOCKET</code> is closed when the transmit DATA are still remained in the SOCKET.<br>
 To solve this problem, you must be close the <code>SOCKET</code> after all DATA are transmitted completly. Refer to <a class="el" href="socket_8h.html#4243cf1670c850a7bf1e77799afdc53f">close()</a>.</dd></dl>

<p>Definition at line <a class="el" href="w5300_8h-source.html#l00668">668</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00334">getSn_SSR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9c77be7d60ac5dee97cf212ce059a273"></a><!-- doxytag: member="w5300.h::Sn_TOSR" ref="g9c77be7d60ac5dee97cf212ce059a273" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_TOSR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x1C)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> IP type of service(TOS) register 
<p>
It sets TOS(Type of Service) field of IP header at the IP layer. It <b>should</b> be set before <a class="el" href="w5300_8h.html#3f4044fe5c1bf9e70b31805212bf5474">Sn_CR_OPEN</a>.<br>
 Refer to <a href="http://www.iana.org/assignments/ip-parameters">IANA </a>. 
<p>Definition at line <a class="el" href="w5300_8h-source.html#l00856">856</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00483">getSn_TOSR()</a>, and <a class="el" href="w5300_8c-source.html#l00487">setSn_TOSR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5a769be7546a09f3c61a8c4ca3a8ce8e"></a><!-- doxytag: member="w5300.h::Sn_TTLR" ref="g5a769be7546a09f3c61a8c4ca3a8ce8e" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_TTLR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x1E)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> IP time to live(TTL) register 
<p>
It sets TTL(Time To Live) field of IP header at the IP layer. It <b>should</b> be set before OPEN command.<br>
 Refer to <a href="http://www.iana.org/assignments/ip-parameters">IANA </a>. 
<p>Definition at line <a class="el" href="w5300_8h-source.html#l00867">867</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00492">getSn_TTLR()</a>, and <a class="el" href="w5300_8c-source.html#l00496">setSn_TTLR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga9618a9d3252f21e1d9b21d901ccea20"></a><!-- doxytag: member="w5300.h::Sn_TX_FIFOR" ref="ga9618a9d3252f21e1d9b21d901ccea20" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_TX_FIFOR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x2E)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> TX FIFO register 
<p>
It indirectly accesses internal TX memory of SOCKETn.<br>
 The internal TX memory can't be accessed directly by the host, but can be accessed through <code>Sn_TX_FIFOR</code>. If <a class="el" href="group___m_o_d_e___r_e_g.html#g9ecbd9f86f95534f1bcf71015d5ae81a">MR</a>(<a class="el" href="w5300_8h.html#8e95ded2155ed3f15eed5508e5b67e56">MR_MT</a>) = '0', the Host-Write of internal TX memory is allowed through <code>Sn_TX_FIFOR</code>. But if <a class="el" href="group___m_o_d_e___r_e_g.html#g9ecbd9f86f95534f1bcf71015d5ae81a">MR</a>(<a class="el" href="w5300_8h.html#8e95ded2155ed3f15eed5508e5b67e56">MR_MT</a>) = '1', both of Host-Read and Host-Write are allowed. Be sure to set it as '0' after verifying interface between <b>W5300</b> and the host system. (for the detail, refer to "How to Test Internal TX/RX memory").<br>
<p>
When any data is written by the host through <code>Sn_TX_FIFOR</code>, the data is sequentially copied into internal TX memory. The data of <b>Sn_TX_FIFOR0</b> and <b>Sn_TX_FIFOR1</b> are respectively saved in <b>low</b> and <b>high</b> addresses of internal TX memory. The data in internal TX memory is transmitted in order of low address by <a class="el" href="w5300_8h.html#77bad5ce966d13306653a83b47a3caed">Sn_CR_SEND</a> or <a class="el" href="w5300_8h.html#f610323614efc4011feff02ede392939">Sn_CR_SEND_MAC</a>. 
<p>Definition at line <a class="el" href="w5300_8h-source.html#l00954">954</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="socket_8c-source.html#l00217">recv()</a>, <a class="el" href="w5300_8c-source.html#l00459">setSn_TX_FIFOR()</a>, and <a class="el" href="w5300_8c-source.html#l00648">wiz_write_buf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g91d0cb53e22206b143b192e59aca4511"></a><!-- doxytag: member="w5300.h::Sn_TX_FSR" ref="g91d0cb53e22206b143b192e59aca4511" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_TX_FSR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x0024)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> TX free size register 
<p>
It notifies the free size of internal TX memory(the byte size of transmittable data) of <code>SOCKETn</code>. <br>
 The host can't write data through <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ga9618a9d3252f21e1d9b21d901ccea20">Sn_TX_FIFOR</a> as the size bigger than <code>Sn_TX_FSR</code>. Therefore, be sure to check Sn_TX_FSR before transmitting data, and if data size is smaller than or same as <code>Sn_TX_FSR</code>, transmit the data with <a class="el" href="w5300_8h.html#77bad5ce966d13306653a83b47a3caed">Sn_CR_SEND</a> or <a class="el" href="w5300_8h.html#f610323614efc4011feff02ede392939">Sn_CR_SEND_MAC</a> after copying the data.<br>
<br>
 At the TCP mode, if the peer checks the transmitted <b>DATA</b> packet(if <b>DATA/ACK</b> packet is received from the peer), <code>Sn_TX_FSR</code> is automatically increased by the size of transmitted <b>DATA</b> packet. At the other modes, when <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g2054e0221824ec7469e54f7b61ddaea9">Sn_IR</a>(<a class="el" href="w5300_8h.html#8973589ea9a777133aa1bec1c03298c9">Sn_IR_SENDOK</a>) is '1', <code>Sn_TX_FSR</code> is automatically increased by the size of transmitted data. 
<p>Definition at line <a class="el" href="w5300_8h-source.html#l00901">901</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00430">getSn_TX_FSR()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge6cfc4b3509216b2999aa410b86a7c37"></a><!-- doxytag: member="w5300.h::Sn_TX_WRSR" ref="ge6cfc4b3509216b2999aa410b86a7c37" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Sn_TX_WRSR          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(SOCKET_REG_BASE + n * SOCKET_REG_SIZE + 0x20)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>SOCKETn</code> TX write size register 
<p>
It sets the byte size of the data written in internal TX memory through <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#ga9618a9d3252f21e1d9b21d901ccea20">Sn_TX_FIFOR</a>. <br>
 It is set before <a class="el" href="w5300_8h.html#77bad5ce966d13306653a83b47a3caed">Sn_CR_SEND</a> or <a class="el" href="w5300_8h.html#f610323614efc4011feff02ede392939">Sn_CR_SEND_MAC</a>, and can't be bigger than internal TX memory size set by <a class="el" href="group___c_o_m_m_o_n___r_e_g.html#g645e0e3979d614184a0cae20d799bcfc">TMSRn</a>.<br>
<br>
 <b>W5300</b> automatically divides the data in the unit of <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4c0679d6d132651861d71e1f6e5d91de">Sn_MSSR</a> in case of '<code>Sn_TX_WRSR</code> &gt; <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4c0679d6d132651861d71e1f6e5d91de">Sn_MSSR</a>' at the TCP or UDP mode. In other modes, Sn_TX_WRSR <b>should</b> not be set bigger than <a class="el" href="group___s_o_c_k_e_t___r_e_g.html#g4c0679d6d132651861d71e1f6e5d91de">Sn_MSSR</a>. 
<p>Definition at line <a class="el" href="w5300_8h-source.html#l00882">882</a> of file <a class="el" href="w5300_8h-source.html">w5300.h</a>.</p>

<p>Referenced by <a class="el" href="w5300_8c-source.html#l00417">getSn_TX_WRSR()</a>, and <a class="el" href="w5300_8c-source.html#l00424">setSn_TX_WRSR()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jan 2 12:20:01 2009 for W5300 - SOCKET APIs by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
