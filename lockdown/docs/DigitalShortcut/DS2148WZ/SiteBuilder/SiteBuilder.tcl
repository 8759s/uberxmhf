 #!/bin/sh
 # The next line is executed by /bin/sh, but not tcl \
 exec wish "$0" ${1+"$@"}
#############################################################################
#
#############################################################################
 package require Tk 8.5
 #
 proc iniVars {} {
    array unset ::SiB
    set ::SiB(proj) {};
    set ::SiB(srdir) {};     #-- site root directory
    set ::SiB(flst) {};      #-- list  fname cmd .....fname cmd
    set ::SiB(cLnum) 1;      #-- insertion point line number for text window
    set ::SiB(ip) [list C0 A8 00 28];   #-- default ip   192.168.0.40
    set ::SiB(mk) [list FF FF FF 00];   #-- default mask 255.255.255.0
    set ::SiB(gt) [list C0 A8 00 01];   #-- default gate 192.168.0.1
    set ::SiB(port) [list 00 50];       #-- default port 80
    #-- set flash parameters for XC3S50AN                          
    set ::SiB(pageSize) 264;    #-- Spartan 3AN flash page size    
    set ::SiB(maxPageNo) 511;   #-- Spartan 3AN last page number
    set ::SiB(phplen) 0;   
 }
 #
 proc main {{root .}} {
    buildMenubar
    buildToolbar
    buildTextWdw
    iniVars
    wm geom . "900x700+100+20"
    wm title . "site builder"
    focus -force .t
 }
 #
 proc buildTextWdw {} {
    pack [entry .cline -borderwidth 2 -background bisque] -side bottom -fill x
    pack [scrollbar .y -command ".t yview"] -side right -fill y
    pack [text .t -wrap word -yscrollc ".y set" -undo 1] -side right -fill both -expand 1
    .t tag configure hili -background yellow
    .t insert end "                               ********* Web Site Builder *********\n"
    .t insert end " \n"
    .t insert end "Converts existing web site into set of files stored in a folder named \"SiteBuilderGernerated\"  \n"
    .t insert end "It builds a list of files, appends a hex index to the file name, adjusts HTML links, compresses files with extensions \"html\" and \"css\" \
                   and copies all files to sub folder \"SiteBuilderGernerated\". Script creates \"siteArm.hex\" and \"siteArm.bin\" files later used by make \
                   when generating firmware for DS2148WZ board, and \"site.hex\" and \"site.bin\" later used when generating a programming file for DSX50WZ board.\n\n"
    .t insert end "When building new file list script will collect all file names in a root folder and in all sub folders one level deep. \
                   To remove file from the list simply delete whole line, HTML links will stay intact, use \"Skip\" button if you need to disable all links to specific file \
                    (insertion point mut be inside word \"include\"), \"Move Up\" and \"Move Down\" buttons let you adjust index of a file. \
                   Files \"index.html\" and \"favicon.ico\" always have index 00 and 01 but keep their names intact. Button \"Build Site\" starts the whole process. \n"
    .t insert end "Please be aware that this script works only for error free static web sites. If site doesn't work when viewed by browser from root folder it will \
                   not work after \"Site Builder\". Dynamic pages generated by PHP, CGI have to be converted to static ones before running SiteBuilder. \"*.php\" \
                   files are used to trigger embeded server services (like reading A/D converter) only. They are not interpreted. \n \n"                                                                                                                           
    .t insert end "File -> New_Project  - please select root folder of your website (typically the folder where index.html is).\n \n"   
    .t insert end "File -> Open_Project - reads saved list of files. \n \n"                                                          
    .t insert end "                                           ---- ---- \n"                                                                   
 }                                                                                                                                            
 #
 proc buildToolbar {} {
    pack [frame .f -relief sunken -borderwidth 1] -anchor w -fill x
    button .f.include -text "Include" -width 10 -command { cmdModify .t "include" }
    button .f.skip -text "Skip" -width 10    -command { cmdModify .t "skip_it" }
    button .f.mup -text "Move Up" -width 10 -command {movLine .t "up" }
    button .f.mdn -text "Move Down" -width 10 -command {movLine .t "dn" }
    button .f.build -text "Build Site" -width 12 -command {build }
    button .f.upload -text "Upload Spartan" -width 15 -command {source UpLoad.tcl }
    button .f.restart -text "Restart" -width 10 -command { exec wish85 $argv0 &; exit }
    button .f.con -text "Console" -width 10 -command { showConsole }
    eval pack [winfo children .f] -side left
    pack configure .f.restart -side right
    pack configure .f.con -side right
 }
 #
 proc buildMenubar {} {
    . configure -menu [menu .m]
    m+ File New_Project { selSiteRootDir .t }
    m+ File Open_Project { openProject .t }
    m+ File Save_Project { saveProject .t }
 }
 proc m+ {head name {cmd ""}} {
    if {![winfo exists .m.m$head]} {
         .m add cascade -label $head -menu [menu .m.m$head -tearoff 0]
    }
    if [regexp ^-+$ $name] {
            .m.m$head add separator
    } else {.m.m$head add command -label $name -comm $cmd}
 }
 proc every {ms body} {eval $body; after $ms [info level 0]}
 #
 proc showConsole {} {
    console show
    set cmd [list wm geometry . "95x12+10+440"]
    console eval $cmd
 }
 proc h2d {hex} {        
    set decimal 0        
    scan $hex %x decimal 
    return $decimal      
 }                       
 proc dispAddr { name hx } {                                                                           
    return "$name [h2d [lindex $hx 0]].[h2d [lindex $hx 1]].[h2d [lindex $hx 2]].[h2d [lindex $hx 3]]" 
 }
 proc dispPort { name hx } {                     
    append px [lindex $hx 0] [lindex $hx 1]      
    return "$name [h2d $px]"                     
 }                                               
 
 
 proc selSiteRootDir { w } {
    set ::SiB(srdir) [tk_chooseDirectory ]
    if {$::SiB(srdir) eq ""} { return }
    set ::SiB(newdir) [file join $::SiB(srdir) "SiteBuilderGenerated"]
    file delete -force -- $::SiB(newdir)
    $w delete 1.0 end 
    $w insert end "[dispPort "port " $::SiB(port)]             ;# \n"
    $w insert end "[dispAddr "ip__ " $::SiB(ip)]   ;# \n" 
    $w insert end "[dispAddr "mask " $::SiB(mk)]  ;# \n"
    $w insert end "[dispAddr "gate " $::SiB(gt)]    ;# \n"
    $w insert end "siteRootDir $::SiB(srdir) ;# \n"
    #-- add all files in root dir
    set ::SiB(flst) {}
    set indx ""; set fav "";
    foreach f [glob -directory $::SiB(srdir) -type f -nocomplain -tails -- *] {
       if { -1 ne [string first "index." $f ]} { set indx $f; continue }
       if { -1 ne [string first "favicon." $f ]} { set fav $f; continue }
       lappend ::SiB(flst) [list $f "include" "" ""]
    }
    #-- add all files in subdirectories (if any)
    foreach sd [glob -directory $::SiB(srdir) -type d -nocomplain -tails -- *] {
       set sdir [file join $::SiB(srdir) $sd]
       set flist [glob -directory $sdir -type f -nocomplain -tails -- *]
       foreach f [glob -directory $sdir -type f -nocomplain -tails -- *] {
          lappend ::SiB(flst) [list [file join $sd $f]  "include"  "" ""]
       }
    }
    if { $fav ne "" } { set ::SiB(flst) [linsert $::SiB(flst) 0 [list $fav "include" "" ""]] }
    if { $indx ne "" } { set ::SiB(flst) [linsert $::SiB(flst) 0 [list $indx "include" "" ""]] }
    loadTxtFlst $w;            #-- load text int window
 }
 proc loadTxtFlst { w } {
    set maxNameLen 0
    foreach f $::SiB(flst) {
        set nx [string length [getInpFileName $f]]
        if { $nx > $maxNameLen } { set maxNameLen $nx }
    }
    incr maxNameLen 8
    foreach f $::SiB(flst) {
        $w insert end "[addSpacesToName [getInpFileName $f] $maxNameLen]"
        $w insert end "[getCommand $f] ;#\n"
    }
 }

 proc addSpacesToName { name maxLen } {
    set r "f+ \"$name\""
    while { $maxLen > [string length $r] } { append r " " }
    return $r
 }
 #
 proc saveProject {w} {
     set ::SiB(proj) [tk_getSaveFile -initialdir [pwd] -defaultextension "sbp" -filetypes {{"project file" .sbp} {"All files" .*}}]
     #-- remove all characters past '#'
     set lastline [expr int([ .t index "end - 1 c"])]
     for {set i 1} {$i < $lastline} {incr i} {
          set ix [.t search -exact ";#" ${i}.0]
          .t delete $ix+2c ${i}.end
     }
     saveText $w $::SiB(proj)
     set ::SiB(flst) {}
     source $::SiB(proj);
 }
 #
 proc openProject {w} {
    set ::projName [tk_getOpenFile  -filetypes {{"project file" .sbp} {"All files" .*}}]
    source $::projName
    loadText .t $::projName
 }
 proc loadText {w fn} {
    if {$fn==""} return
    $w delete 1.0 end
    wm title . [file tail $fn]
    set fp [open $fn]
    fconfigure $fp -buffering line
    while {[gets $fp line] >= 0} {
        $w insert end $line\n
    }
    close $fp
    $w mark set insert 1.0
 }
 proc saveText {w fn} {
    if {$fn==""} return
    set fp [open $fn w]
    puts -nonewline $fp [$w get 1.0 "end - 1c"]
    close $fp
 }
 proc hiCursorLine { w } {
    set cLnum [expr int([ $w index "insert"])]
    if { $::SiB(cLnum) eq $cLnum} { return }
       $w tag configure "hili" -background white
       $w tag remove "hili" "1.0" "end"
       $w tag add "hili" $cLnum.0 $cLnum.end
       $w tag configure "hili" -background yellow
       $w tag raise "hili"
       set ::SiB(cLnum) $cLnum
 }
 proc movLine { w dir } {
    set cinsert [ $w index "insert"]
    set aLnum [expr int( $cinsert )]
    set lastLnum [ expr int( [ $w index "end"])]
    if {$dir eq "up" } {
        if { $aLnum < 5 } { return }
        set lineA [$w get $aLnum.0 $aLnum.end]
        set bLnum [expr $aLnum - 1]
        set lineB [$w get "$bLnum.0" "$bLnum.end"]
        $w delete "$bLnum.0" "$aLnum.end"
        $w insert "$bLnum.0" "$lineA\n"
        $w insert "$aLnum.0" $lineB
        $w mark set insert "$cinsert - 1 line"
    } else {
        if { $aLnum < 4 } { return }
        if {$lastLnum == 0 } { return }
        incr lastLnum -1
        if { $aLnum < $lastLnum } {
           set lineA [$w get $aLnum.0 $aLnum.end]
           set bLnum [expr $aLnum + 1]
           set lineB [$w get "$bLnum.0" "$bLnum.end"]
           $w delete "$aLnum.0" "$bLnum.end"
           $w insert "$aLnum.0" "$lineB\n"
           $w insert "$bLnum.0" "$lineA"
           $w mark set insert "$cinsert + 1 line"
        }
    }
 }

 proc cmdModify { w txt } {
    set cStart [ $w index "insert wordstart"]
    set cEnd [ $w index "insert wordend"]
    set oldtxt [.t get $cStart $cEnd]
    switch -- $oldtxt {
               "include"    -
               "skip_it"    { .t delete $cStart $cEnd; .t insert $cStart $txt; .t mark set insert "$cStart + 1 lines" }
               default      {}
    }
 }

 proc siteRootDir { dir } {
     set ::SiB(srdir) $dir
     
 }
 proc f+ { name cmd } {
    lappend ::SiB(flst) [list $name $cmd "" ""]
 }
 proc port {pnum} {
   set px [format %4.4X $pnum]
   set ::SiB(port) [list [string range $px 0 1] [string range $px 2 3]]
   
 }
 proc ip__ {dec} {
   set ::SiB(ip) [newAddr $dec]
 } 
 proc mask {dec} {
   set ::SiB(mk) [newAddr $dec]
 } 
 proc gate {dec} {
   set ::SiB(gt) [newAddr $dec]
 }  
 proc newAddr { d } {
   foreach dx [string map {"." " "} $d] {
       lappend ipHex [format %2.2X $dx]
   }
   return $ipHex
 }
 
 
 #---------------------------------------------------------------------------------------------
 proc addHexIndex { name xx } {
     #-- first remove subdir if any
     set fn [lindex [file split $name] end]
     if { -1 ne [string first "index." $fn]} { return $fn }
     if { -1 ne [string first "favicon." $fn] } { return $fn }
     return [string map [ list "." "_$xx." ] $fn]
 }
 #-- ::SiB(flst) access
 proc getInpFileName {flst} {
    return [lindex $flst 0]
 }
 proc getInpFileExt {flst} {
    return [file extension [getInpFileName flst]]
 }
 proc getCommand { flst } {
    return [lindex $flst 1]
 }
 proc getHexName { flst } {
    return [lindex $flst 2]
 }
 proc getHexOffset { l } {
    return [lindex $flst 3]
 }
 #--------------------------------------------------------------------
 proc armFileType {fname} {
     switch -exact -nocase -- [file extension $fname ] {
        .png       { set type 7 }
        .jpg       { set type 6 }
        .gif       { set type 2 }
        .ico       { set type 8 }
        .html      { set type 4 }
        .htm       { set type 4 }
        .css       { set type 5 }
        .php       { set type 9 }
        default    { set type 1; #text }
     }
     return $type
 }
 proc mkNewFileSet {flst} {
     set finName [file join $::SiB(srdir) [ getInpFileName $flst ]]
     set foutName [file join $::SiB(newdir) [getHexName $flst]]
     #--puts "$finName -> $foutName"
     switch -exact -nocase -- [file extension $finName ] {
        .css       -
        .htm       -
        .html      { modifyHtmlLinks $finName $foutName }
        .php       -
        .png       -
        .jpg       -
        .gif       -
        .ico       -
        default    { file copy -force $finName $foutName}
     }
     return $foutName
 }

 proc genHttpHeader { fname bodylen } {
     set len $bodylen
     set header [concat [ mkHeadHex "HTTP/1.1 200 OK" ] [mkHeadHex "Server: DSX50-WZ demo" ]]
     switch  -exact -nocase -- [file extension $fname] {
        .css       {set header [concat $header [mkHeadHex "Content-Type: text/css"] \
                                               [mkHeadHex "Content-Encoding: gzip"] \
                                               [mkHeadHex "Content-Length: $bodylen"] "0D" "0A" ]
                   }
        .htm       {set header [concat $header [mkHeadHex "Content-Type: text/html"] \
                                               [mkHeadHex "Content-Encoding: gzip"] \
                                               [mkHeadHex "Content-Length: $bodylen"] "0D" "0A" ]
                   }
        .html      {set header [concat $header [mkHeadHex "Content-Type: text/html"] \
                                               [mkHeadHex "Content-Encoding: gzip"] \
                                               [mkHeadHex "Content-Length: $bodylen"] "0D" "0A" ]                             
                   }
        .png       {set header [concat $header [mkHeadHex "Content-Type: image/png"] \
                                               [mkHeadHex "Content-Length: $bodylen"] "0D" "0A" ]
                   }
        .jpg       {set header [concat $header [mkHeadHex "Content-Type: image/jpeg"] \
                                               [mkHeadHex "Content-Length: $bodylen"] "0D" "0A" ]
                   }
        .gif       {set header [concat $header [mkHeadHex "Content-Type: image/gif"] \
                                               [mkHeadHex "Content-Length: $bodylen"] "0D" "0A" ]
                   }
        .ico       {set header [concat $header [mkHeadHex "Content-Type: image/x-icon"] \
                                               [mkHeadHex "Content-Length: $bodylen"] "0D" "0A" ]
                   }
        .php       {set header [mkPhpHeader $fname];
                    set len 0;
                   }           
        default    {set header [concat $header [mkHeadHex "Content-Type: text/txt"] \
                                               [mkHeadHex "Content-Length: $bodylen"] "0D" "0A" ]
                   }
    }
    #-- make total length even - spartan firmware requires that
    set total [expr ([llength $header] + $len)]
    if { [expr ($total % 2)] == 1 } {
       set header [linsert $header end-4 "20"]
    }
    #-- for Spartan only - insert length of header and body before header characters
    set byteCntHex [format %04X [expr ((([llength $header] + $len) / 2) - 1 )]]
    set header [linsert $header 0 "[string range $byteCntHex 0 1]" "[string range $byteCntHex 2 3]"]
    return $header
 }                          
 #--
 proc mkPhpHeader {fname} {
    set code ""
    set fi [open $fname r]
    set ::SiB(phplen) {}
    while {[gets $fi line] >= 0} {
        if { [string first "#--sbHdrAdd" $line] == 0} {
           set exelen [string map {"#--sbHdrAdd" extractPhpLen} $line]
           eval $exelen 
           #--
           set exe [string map {"#--sbHdrAdd" mkHeadHex} $line]
           set code [concat $code [eval $exe]]
        }
    }
    close $fi    
    set code [concat $code "0D" "0A" ]
    return $code
 }
 #--
 proc extractPhpLen {str} {
    if { [string first "Content-Length:" $str] == 0 } {
        set len [lindex [split $str " "] 1]
        set lw [format %08X [expr ($len - 1 )/2]]
        set ::SiB(phplen) [list [string range $lw 4 5] [string range $lw 6 7] [string range $lw 0 1] [string range $lw 2 3]] 
    }
 }
 #-- takes string and converts it into a list of hex ascii codes
 proc mkHeadHex { str } {
     set code ""
     foreach ch [split $str {}] {
         scan $ch %c code
         lappend res "[format %02X $code]"
     }
     lappend res "0D" "0A"
     return $res
 }
 proc mkHeaderEven {lst} {
     set lstLen [llength $lst]
     if { [expr ($lstLen % 2)] == 1 } {
         return [linsert $lst end-4 "20"]               ;# add character "space"
     } else {
         return $lst
     }
 }
 #
 proc genBytes {fname} {
    set hex {}
    if { [string equal -nocase [file extension $fname ] ".php"] == 1 } {
        return $hex
    }
    switch  -exact -nocase -- [file extension $fname] {
        .htm     -
        .html    -
        .css     { set fi [open "|gzip -c -9 $fname" r+] }
        default  { set fi [open $fname r]}
    }
    fconfigure $fi -buffering none -encoding binary -translation binary
    foreach byte [split [read $fi] {}] {
       binary scan $byte H* xx
       lappend hex [string toupper $xx]
    }

    close $fi
    return $hex
 }
 #
 proc modifyHtmlLinks {finName foutName } {
    set fi [open $finName r]
    fconfigure $fi -buffering line
    set ftmp [open "tmp.txt" w]
    while {[gets $fi line] >= 0} {
         foreach flst $::SiB(flst) {
            set line [ string map [list "../" "" [getInpFileName $flst] [getHexName $flst]] $line]
         }
         #-- remove multiple spaces
         while { -1 ne [string first "  " $line] } {
            set line [string map [list "     " " " "    " " " "   " " " "  " " "] $line ]
         }
         puts $ftmp $line
    }
    close $fi
    close $ftmp
    file copy -force "tmp.txt" $foutName
    file delete "tmp.txt"
 }
 #--
 proc incrFlashAddr {} {
     incr ::SiB(curAddr)
     if { $::SiB(curAddr) >= $::SiB(pageSize)} {
         incr ::SiB(curPage)
         set ::SiB(curAddr) 0
     }
 }
 proc getIndexNumber { fname } {
     set n [string tolower $fname]
     if { [string first "index." $n] >= 0 } {
         set ix 0
     } elseif { [string first "favicon." $n] >= 0 } {
         set ix 1
     } else {
         set ix 2
         #-- extract index from file name and convert it from hex into number
         scan [string range [file rootname $fname] end-1 end] %x ix
     }
     return $ix
 }
 # - convert hex file to binary file
 proc cnv_h2b { iName oName } {
    set fi [open $iName r]
    fconfigure $fi -buffering line
    set fo [open $oName w]
    fconfigure $fo -encoding binary -translation binary
    while {[gets $fi line] >= 0} {
        foreach xx $line {
           puts -nonewline $fo [binary format H2 $xx]
        }
    }
    close $fi
    close $fo
    return [file size $oName]
 }
 #--------------------------------------------------------------------
 #-- this proc produces img.hex/imgArm.hex temporary files; format is  space separated hex codes
 #-- from input files
 proc processFiles {} {
     #-- build file name substitution table ::SiB(flst)
     set i 0
     set ix 0
     foreach flst $::SiB(flst) {
         switch -- [getCommand $flst] {
            "include"    { lset ::SiB(flst) $i 2 [addHexIndex [getInpFileName $flst] [format %02X $ix]]; incr i; incr ix }
            "skip_it"    { incr i }
            default      {tk_messageBox -icon error -message "$cmd  - invalid command" -title "command error"}
         }
     }
     #-- setup result dir
     set ::SiB(newdir) [file join $::SiB(srdir) "SiteBuilderGenerated"]
     file delete -force -- $::SiB(newdir)
     file mkdir $::SiB(newdir)
     #-- open img.hex -- temporary file where we will  store all converted files in (hex-space format)
     set fo [open "img.hex" w]
     set foArm [open "imgArm.hex" w]
     set lnum 6;
     foreach lst $::SiB(flst) {
         #-- only process files with command = "include"
         if {-1 ne [string first "include" [getCommand $lst]] } {
             #-- step 1 flaten directory tree, modify html and copy to "new" dir
             .t tag add "done" $lnum.0 $lnum.end
             .t tag configure "done" -background khaki1
             .t insert "$lnum.end" " [getHexName $lst]"
             #-- copy or ( copy and modify if html)
             set foutHexName [mkNewFileSet $lst];     #-- hexName with path
             #-- step 2 -read, gzip, make headers and generate space separated hex
             set body [genBytes $foutHexName ]
             set header [genHttpHeader $foutHexName [llength $body]]; #-- used by Spartan only
             #-- detect php ( and possibly other script files)
             set phpType [string equal [file extension $foutHexName] ".php"]
             if { $phpType == 1 } {
                 set byteLenArm [llength $header]
             } else { 
                 set byteLenArm [llength $body]
             }
             set prm [updateAddrTable $foutHexName $byteLenArm]
             .t insert "$lnum.end" " - $prm"
             #-- write header
             writeHeader $header $fo $foArm 29 $phpType
                          
             #-- write body
             set i 0
             foreach xx $body {
                 puts -nonewline $fo "$xx "
                 puts -nonewline $foArm "$xx "
                 incr i
                 incrFlashAddr
                 incr ::SiB(curAddrArm)
                 if { $i > 31 } { set i 0; puts $fo ""; puts $foArm "" }
             }
             #-- send CR (ARM only) -- siteARM.hex looks nicer with this
             if { $i ne 0 } { puts $foArm "" }
             #-- for php (and may be js) put sbHdrTail bytes here
             set tail [list FF FF]
             if { $phpType == 1 } { set tail [genPhpTail $foutHexName]}
             writeHeader $tail $fo $foArm 31 $phpType
         }
         incr lnum
         update   
      }
      close $fo
      close $foArm
 }
 
 proc writeHeader { h f1 f2 n php } {
      set i 0
      foreach xx $h {
          puts -nonewline $f1 "$xx "
          incr i
          incrFlashAddr
          if { $php == 1 } {
              puts -nonewline $f2 "$xx "
              incr ::SiB(curAddrArm)
          }
          if { $i > $n } {
              set i 0;
              puts $f1 ""
              if { $php == 1 } { puts $f2 ""}
          }
      }
      if { $i ne 0 } { puts $f1 ""; puts $f2 ""}
 }
  
 #---------------------------------------------------------------------------------------------
 # For spartan only
 # we store FF FF after each file indicating to server that after serving that prticular file
 # there is nothing more to do. 
 # If first byte isn't FF then server has to perform additional tasks and that byte becomes ID of 
 # a new task, next bytes ( at least one) are parameters of that task
 # These bytes are defined in sbHdrTail section of partticular .php file 
 # 
 proc genPhpTail { fname } {
    set fi [open $fname r]
    while {[gets $fi line] >= 0} {
        if { [string first "#--sbHdrTail" $line] == 0} {
           set exe [string map {"#--sbHdrTail" "list"} $line]
           set tail [eval $exe]
        }
    }
    close $fi                                           
    #-- check if format is XX
    foreach xx $tail {
       if { [string length $xx] != 2 } {
           return [list FF FF]
       } 
       if { [string is xdigit -strict $xx] == 0 } {
           return [list FF FF]
       }
    }
    if { [llength $tail] < 2 } {
       #-- wrong number of params
        set tail [list FF FF]
    } elseif { [llength $tail] == 2 } {       
        if {[llength $::SiB(phplen)] > 0 } {
           #-- add LENGTH bytes
           set tail [concat $tail $::SiB(phplen)]
        } else {
           #-- missing length statement
           set tail [list FF FF]
        }
    }
    return $tail
 }    
 #---------------------------------------------------------------------------------------------
 #-- page 208 stores programming values of WIZnet registers
 #-- format is: length is in words
 #  [lenH][lenL] [addrH][addrL] [dataH][dataL]...... [dataH][dataL]
 #
 #---------------------------------------------------------------------------------------------
 #-- page 208 stores programming values of WIZnet registers
 #-- format is: length is in words
 #  [lenH][lenL] [addrH][addrL] [dataH][dataL]...... [dataH][dataL]
 #
 proc genPage208 {} {
    #-- fill up page with FF
    set page [list 00 10];           #-- (lenght-1)
    lappend page 00 20 08 08;        #-- TMSR01 (tx memory size ) sock0(8k) sock1(8k)
    lappend page 00 22 08 08;        #-- TMSR23 (tx memory size ) sock2(8k) sock3(8k)
    lappend page 00 24 08 08;        #-- TMSR45 (tx memory size ) sock4(8k) sock5(8k)
    lappend page 00 26 08 08;        #-- TMSR67 (tx memory size ) sock6(8k) sock7(8k)
    lappend page 00 28 08 08;        #-- RMSR01 (rx memory size ) sock0(8k) sock1(8k)     
    lappend page 00 2A 08 08;        #-- RMSR23 (rx memory size ) sock2(8k) sock3(8k)
    lappend page 00 2C 08 08;        #-- RMSR45 (rx memory size ) sock4(8k) sock5(8k)
    lappend page 00 2E 08 08;        #-- RMSR67 (rx memory size ) sock6(8k) sock7(8k)
    lappend page 00 30 00 FF;        #-- MTYPER (memory type reg) 0-rx, 1-tx memory
    lappend page 00 10 [lindex $::SiB(gt) 0] [lindex $::SiB(gt) 1]; #-- GAR (gateway ip address)
    lappend page 00 12 [lindex $::SiB(gt) 2] [lindex $::SiB(gt) 3]; #--
    lappend page 00 14 [lindex $::SiB(mk) 0] [lindex $::SiB(mk) 1]; #-- SUBR ( subnet mask reg)
    lappend page 00 16 [lindex $::SiB(mk) 2] [lindex $::SiB(mk) 3]; #--              
    lappend page 00 18 [lindex $::SiB(ip) 0] [lindex $::SiB(ip) 1]; #--  SIPR ( ip address reg) 
    lappend page 00 1A [lindex $::SiB(ip) 2] [lindex $::SiB(ip) 3]; #--                         
    lappend page 00 1C 07 D0;        #-- RTR (retransmition timeout)  200ms
    
    while {[llength $page] < [expr ($::SiB(pageSize)- 24)]} { lappend page "FF" }

    lappend page 00 03;              #-- (length-1)
    lappend page 02 00 00 21;        #-- Sn_MR Socket mode register  ( 20-NDack,  01-TCP )
    lappend page 02 0A [lindex $::SiB(port) 0] [lindex $::SiB(port) 1]; #-- Sn_PortR
    lappend page 02 04 00 10;        #-- Sn_IMR int mask reg ( sendOk only )
    lappend page 02 02 00 01;        #-- Sn_CR Socket command reg ( OPEN )
    
    while {[llength $page] < $::SiB(pageSize)} { lappend page "FF" }
    return $page
 }
 #-- Page 209 stores 404 and 400 headers  and POST 200 ----------------------------
 proc genPage209 {} {
     #-- make fixed header 404
     set h404 [ mkHeadHex "HTTP/1.1 404 Not Found" ]
     set h404 [ concat $h404 [mkHeadHex "Server: DSX50-WZ demo"] "0D" "0A"]
     set h404 [ mkHeaderEven $h404 ]
     set h404lenHex [format %04X [expr (([llength $h404] / 2) - 1) ]]
     set h404 [linsert $h404 0 [string range $h404lenHex 0 1] [string range $h404lenHex 2 3]]
     #-- make fixed header 400
     #-- 34
     set h400 [mkHeadHex "HTTP/1.1 400 Bad Request"]
     set h400 [ concat $h400 [mkHeadHex "Server: DSX50-WZ demo"] "0D" "0A"];
     set h400 [ mkHeaderEven $h400 ]
     set h400lenHex [format %04X [expr (([llength $h400] / 2) - 1) ]]
     set h400 [linsert $h400 0 [string range $h400lenHex 0 1] [string range $h400lenHex 2 3]]
     #-- make fixed header for POST request
     #-- 6A
     set h200 [ mkHeadHex "HTTP/1.1 200 OK" ]
     set h200 [ concat $h200 [mkHeadHex "Server: DSX50-WZ demo"]]
     set h200 [ concat $h200 [mkHeadHex "Content-Type: text/html"]]
     set h200 [ concat $h200 [mkHeadHex "Content-Length: 28"] "0D" "0A" ]
     set h200 [ concat $h200 [mkHeadHex "The file has been uploaded"] "0D" "0A"]
     set h200 [ mkHeaderEven $h200 ]
     set h200lenHex [format %04X [expr (([llength $h200] / 2) - 1) ]]
     set h200 [linsert $h200 0 [string range $h200lenHex 0 1] [string range $h200lenHex 2 3]]
     #-- build page image
     set page [concat $h404 $h400 $h200]
     while {[llength $page] < $::SiB(pageSize)} { lappend page "FF" }
     return $page
 }
 #------------------------------------------------------------------------------------------------
 #-- address table ::SiB(addrTbl) -- list of lists (88)
 #
 #-- Sapartan - table takes one flash page (264 bytes), each file needs 4 bytes so there is space for 66 files
 #-- format: [FileAddr [byteHigh],[byteMid],[byteLow]][type], type - not used now  
 #-- ARM      - table takes 1024 bytes of flash - 3 * 32bits words per file / space for 85 files
 #-- format: FileAddr 7..0 15..8 23..16 31..24 FileLength 7..0 15..8 23..16 31..24 FileType 7..0 15..8 23..16 31..24

 proc initAddressTable {} {
    set ::SiB(addrTbl) {}
    set ::SiB(addrTblArm) {}
    #-- spartan address table takes whole page 210 - (cappacity 88 files)
    #-- it can be prefilled with:
    #-- 01 A2 00 start of page 209 where "file not found" header signalling error
    #-- 01 A6 00 start of page 211 where index.html resides
    for { set i 0} { $i < 66 } { incr i } {
       lappend ::SiB(addrTbl) [list 01 A2 00 00]
    }
    #-- ARM7 address table takes 1024 bytes - (cappacity 85 files)
    #-- it can be prefilled with "not_found.html" or "index.html"
    for { set i 0} { $i < 85 } { incr i} {
       lappend ::SiB(addrTblArm) [ mkArmAddrTblEntry 1024 2048 1 ]
    }
    lappend ::SiB(addrTblArm) [list 12 34 56 78];  #-- make table 1024 bytes long (will look nicer)
    return [list [llength $::SiB(addrTbl)] [llength $::SiB(addrTblArm)]]
}
 #--
 proc mkArmAddrTblEntry {addr length type} {
     set hex [format %08X $addr]
     lappend lst [string range $hex 6 7] [string range $hex 4 5] [string range $hex 2 3] [string range $hex 0 1]
     set hex [format %08X $length]
     lappend lst [string range $hex 6 7] [string range $hex 4 5] [string range $hex 2 3] [string range $hex 0 1]
     set hex [format %08X $type]
     lappend lst [string range $hex 6 7] [string range $hex 4 5] [string range $hex 2 3] [string range $hex 0 1]
     return $lst
 }
 #--
 proc updateAddrTable { fname length} {
      set ix [getIndexNumber $fname]
      #--  for Spartan 
      set type "00"
      if { [string equal -nocase [file extension $fname ] ".php"] == 1 } {
          set type "01"
      }
      set fA [format %06X [expr {($::SiB(curPage) * 512) + $::SiB(curAddr)}]]
      lset ::SiB(addrTbl) $ix [ list [string range $fA 0 1] [string range $fA  2 3] [string range $fA 4 5] $type]

      #-- for ARM   adress
      lset ::SiB(addrTblArm) $ix [mkArmAddrTblEntry $::SiB(curAddrArm) $length [armFileType $fname]]
      return "Spartan($::SiB(curPage), $::SiB(curAddr), $fA); - Arm( [format %06X $::SiB(curAddrArm)]);"
 }
 #-----------------------------------------------------------------------------------------------
 proc build {} {
     saveProject .t
     #-- set ::SiB(ix) 2; # setup current index - skip 00 (index.html) and 01 (favicon.ico)
     #-- set flash parameters for XC3S50AN
     
     set ::SiB(curPage) 211;     #--  208-reg init, 209-400/404, 210- AddrTable  211- data
     set ::SiB(curAddr) 0;       #-- addres in page
     set ::SiB(curAddrArm) 1024; #-- flash address for arm (move past address table )
     initAddressTable
     processFiles
     #-- at that point there are img.hex and imgArm.hex teporary files and  address table
     #-- sits in a global variable
     #-- our goal is to make binary images but now we will generate site.hex and siteArm.hex to make debug easier
     set fo [open [file join $::SiB(newdir) "site.hex"] w]

     #-- for spartan
     #-- write page 208
     set i 0
     foreach xx [genPage208] {
        puts -nonewline $fo "$xx "
        incr i
        if { $i > 23 } { puts $fo ""; set i 0}
     }
     #write page 209
     set i 0
     foreach xx [genPage209] {
        puts -nonewline $fo "$xx "
        incr i
        if { $i > 21 } { puts $fo ""; set i 0}
     }
     #-- write Address Table for Spartan
     set i 0
     foreach xx $::SiB(addrTbl) {
        puts -nonewline $fo "$xx  "
        incr i
        if { $i > 7 } { puts $fo ""; set i 0}
     }
     puts $fo ""
     #-- append img.hex
     set fi [open "img.hex" r]
     fconfigure $fi -buffering line
     while {[gets $fi line] >= 0} {
        puts $fo $line
     }
     close $fi
     close $fo
     file delete "img.hex"
     #-- ARM
     set foA [open [file join $::SiB(newdir) "siteArm.hex"] w]
     #-- write address table for ARM
     set i 0
     foreach xx $::SiB(addrTblArm) {
        puts -nonewline $foA "$xx  "
        incr i
        if { $i > 1 } { puts $foA ""; set i 0}
     }
     set fi [open "imgArm.hex" r]
     fconfigure $fi -buffering line
     while {[gets $fi line] >= 0} {
        puts $foA $line
     }
     close $fi
     close $foA
     file delete "imgArm.hex"
     #-- make binary files
     set spartanFsize [cnv_h2b [file join $::SiB(newdir) "site.hex"] [file join $::SiB(newdir) "site.bin"]]
     set armFsize [cnv_h2b [file join $::SiB(newdir) "siteArm.hex"] [file join $::SiB(newdir) "siteArm.bin"]]
     #-- report results
     if { $::SiB(curPage) > $::SiB(maxPageNo)} {
        set x [string length [.t get 1.0 1.end]]
        incr x
        .t insert 1.end " Spartan memory Overflow! p$::SiB(curPage), $spartanFsize"
        .t tag add "error" 1.$x 1.end
        .t tag configure "error" -background red
     } else {
        .t insert 1.end " Spartan Ok! p$::SiB(curPage), $spartanFsize"
     }
     .t insert 1.end " ; ARM [expr { int($::SiB(curAddrArm) / 1024)}]kB, $armFsize"
     #-- convert binary spartan image site.bin to site.mcs using program: srec_cat.exe
     cnv_b2mcs [file join $::SiB(newdir) "site.bin"] [file join $::SiB(newdir) "site.mcs"]
 }
 proc cnv_b2mcs {inName outName } {
     exec -- srec_cat $inName -binary -offset 0 -o $outName -intel -address-length=2
 #    exec -- xmcsutil -accept_notice -d -0 -i $inName -o $outName
 }
 #-------------------------------------------------------------------------------------------
 main
 every 200 { hiCursorLine .t };
