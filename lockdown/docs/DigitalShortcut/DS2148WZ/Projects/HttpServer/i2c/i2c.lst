   1              		.file	"i2c.c"
   9              	.Ltext0:
  10              		.align	2
  12              	i2cStatus:
  13              	.LFB4:
  14              		.file 1 "i2c/i2c.c"
   1:i2c/i2c.c     **** //#include <stdio.h>
   2:i2c/i2c.c     **** 
   3:i2c/i2c.c     **** #include	"i2c.h"
   4:i2c/i2c.c     **** #include	"../ARM2148/lpc21xx.h"
   5:i2c/i2c.c     **** #include	"../ARM2148/processor.h"
   6:i2c/i2c.c     **** #include	"../ARM2148/lpcI2C.h"
   7:i2c/i2c.c     **** 
   8:i2c/i2c.c     **** extern	uint32		miliSec;
   9:i2c/i2c.c     **** 
  10:i2c/i2c.c     **** extern	void	delay(unsigned long d);
  11:i2c/i2c.c     **** extern	int 	printf(const char *format, ...);
  12:i2c/i2c.c     **** extern	void	LogWr(uint16 data);
  13:i2c/i2c.c     **** 
  14:i2c/i2c.c     **** int i2cTransferBytes (uint8 address, uint8 *buffer, int bufferLenWrite, int bufferLenRead);
  15:i2c/i2c.c     **** int i2cWriteBufferEx (uint8 address, uint8 *buffer, uint32 bufferLength, int milliseconds);
  16:i2c/i2c.c     **** int i2cReadBufferEx (uint8 address, uint8 *buffer, uint32 bufferLength, int milliseconds);
  17:i2c/i2c.c     **** int i2cWriteReadBufferEx (uint8 address, uint8 *buffer, uint32 putLength, uint32 getLength, int mil
  18:i2c/i2c.c     **** int eepromRdSBlk (uint16 addr, uint8 *buffer, uint16 Length);
  19:i2c/i2c.c     **** int eepromWrSBlk (uint16 addr, uint8 *buffer, uint16 Length);
  20:i2c/i2c.c     **** 
  21:i2c/i2c.c     **** 
  22:i2c/i2c.c     **** //  Default timeout, in milliseconds for generic read/write
  23:i2c/i2c.c     **** #define I2C_DEFAULT_TIMEOUT 100
  24:i2c/i2c.c     **** 
  25:i2c/i2c.c     **** volatile int i2cBusInUse;
  26:i2c/i2c.c     **** uint8 i2cAddress;
  27:i2c/i2c.c     **** uint8 *i2cDataBuffer;
  28:i2c/i2c.c     **** int i2cDataLenWrite;
  29:i2c/i2c.c     **** int i2cDataLenRead;
  30:i2c/i2c.c     **** uint32 i2cTimeout = I2C_DEFAULT_TIMEOUT;
  31:i2c/i2c.c     **** uint8 *i2cDataPtr;
  32:i2c/i2c.c     **** 
  33:i2c/i2c.c     **** 
  34:i2c/i2c.c     **** int i2cWaitComplete (int milliseconds);
  35:i2c/i2c.c     **** 
  36:i2c/i2c.c     **** 
  37:i2c/i2c.c     **** i2cErr_e i2cErrno;
  38:i2c/i2c.c     **** 
  39:i2c/i2c.c     **** //
  40:i2c/i2c.c     **** //
  41:i2c/i2c.c     **** //
  42:i2c/i2c.c     **** typedef enum
  43:i2c/i2c.c     **** {
  44:i2c/i2c.c     ****   I2CFLAGS_START         = 0x0001,
  45:i2c/i2c.c     ****   I2CFLAGS_REPEATEDSTART = 0x0002,
  46:i2c/i2c.c     ****   I2CFLAGS_STOP          = 0x0004,
  47:i2c/i2c.c     ****   I2CFLAGS_ADDRESS       = 0x0008,
  48:i2c/i2c.c     ****   I2CFLAGS_WRITEDATA     = 0x0010,
  49:i2c/i2c.c     ****   I2CFLAGS_READDATA      = 0x0020,
  50:i2c/i2c.c     **** }
  51:i2c/i2c.c     **** i2cFlags_e;
  52:i2c/i2c.c     **** 
  53:i2c/i2c.c     **** typedef enum
  54:i2c/i2c.c     **** {
  55:i2c/i2c.c     ****   I2CMODE_ACK = 0,
  56:i2c/i2c.c     ****   I2CMODE_NACK,
  57:i2c/i2c.c     ****   I2CMODE_READ
  58:i2c/i2c.c     **** }
  59:i2c/i2c.c     **** i2cMode_e;
  60:i2c/i2c.c     **** 
  61:i2c/i2c.c     **** static void i2cISR (void) __attribute__((naked));
  62:i2c/i2c.c     **** static void i2cISR (void)
  63:i2c/i2c.c     **** {
  64:i2c/i2c.c     **** 	ISR_ENTRY();
  65:i2c/i2c.c     **** 	
  66:i2c/i2c.c     ****   i2cErrno = (I2C0_STAT & I2C_STAT_STATMASK);
  67:i2c/i2c.c     **** 	LogWr(0x49); LogWr(i2cErrno);
  68:i2c/i2c.c     **** 
  69:i2c/i2c.c     **** 	switch (i2cErrno)  {
  70:i2c/i2c.c     **** 	//  Transmit conditions
  71:i2c/i2c.c     **** 	case I2CERR_BUSERRORx : // 0x00
  72:i2c/i2c.c     **** 		I2C0_CONSET = I2C_CONSET_STO | I2C_CONSET_AA;
  73:i2c/i2c.c     **** 		i2cBusInUse = 0;
  74:i2c/i2c.c     **** 		break;
  75:i2c/i2c.c     **** 
  76:i2c/i2c.c     **** 	case I2CERR_STARTTX : // 0x08
  77:i2c/i2c.c     **** 		I2C0_DAT = i2cAddress;
  78:i2c/i2c.c     **** 		break;
  79:i2c/i2c.c     **** 
  80:i2c/i2c.c     **** 	case I2CERR_REPEATEDSTARTTX : // 0x10
  81:i2c/i2c.c     **** 		I2C0_DAT = i2cAddress;
  82:i2c/i2c.c     **** 		break;
  83:i2c/i2c.c     **** 
  84:i2c/i2c.c     **** 	case I2CERR_SLAWTX_ACKRX : // 0x18
  85:i2c/i2c.c     **** 		I2C0_DAT = *i2cDataPtr++;
  86:i2c/i2c.c     **** 		I2C0_CONCLR = I2C_CONCLR_STAC;
  87:i2c/i2c.c     **** 		break;
  88:i2c/i2c.c     **** 
  89:i2c/i2c.c     **** 	case I2CERR_SLAWTX_NACKRX : // 0x20
  90:i2c/i2c.c     **** 		I2C0_CONSET = I2C_CONSET_STO;
  91:i2c/i2c.c     **** 		i2cBusInUse = 0;
  92:i2c/i2c.c     **** 		break;
  93:i2c/i2c.c     **** 
  94:i2c/i2c.c     **** 	case I2CERR_DATTX_ACKRX : // 0x28
  95:i2c/i2c.c     **** 		if (--i2cDataLenWrite)  {
  96:i2c/i2c.c     **** 			I2C0_DAT = *i2cDataPtr++;
  97:i2c/i2c.c     **** 			I2C0_CONCLR = I2C_CONCLR_STAC;
  98:i2c/i2c.c     **** 		}
  99:i2c/i2c.c     **** 		else {
 100:i2c/i2c.c     **** 			if (!i2cDataLenRead) {
 101:i2c/i2c.c     **** 				I2C0_CONCLR = I2C_CONCLR_STAC;
 102:i2c/i2c.c     **** 				I2C0_CONSET = I2C_CONSET_STO;
 103:i2c/i2c.c     **** 				i2cBusInUse = 0;
 104:i2c/i2c.c     **** 			}
 105:i2c/i2c.c     **** 			else  {
 106:i2c/i2c.c     **** 				i2cAddress |= 0x01;
 107:i2c/i2c.c     **** 				i2cDataPtr = i2cDataBuffer;
 108:i2c/i2c.c     **** 				I2C0_CONSET = I2C_CONSET_STA;
 109:i2c/i2c.c     **** 			}
 110:i2c/i2c.c     **** 		}
 111:i2c/i2c.c     **** 		break;
 112:i2c/i2c.c     **** 
 113:i2c/i2c.c     **** 	case I2CERR_DATTX_NACKRX : // 0x30
 114:i2c/i2c.c     **** 		I2C0_CONCLR = I2C_CONCLR_STAC;
 115:i2c/i2c.c     **** 		I2C0_CONSET = I2C_CONSET_STO;
 116:i2c/i2c.c     **** 		i2cBusInUse = 0;
 117:i2c/i2c.c     **** 		break;
 118:i2c/i2c.c     **** 
 119:i2c/i2c.c     **** 	case I2CERR_ARBLOST : // 0x38
 120:i2c/i2c.c     **** 		I2C0_CONSET = I2C_CONSET_STA;
 121:i2c/i2c.c     **** 		break;
 122:i2c/i2c.c     **** 
 123:i2c/i2c.c     ****     //  Receive byte conditions
 124:i2c/i2c.c     ****     //
 125:i2c/i2c.c     **** 	case I2CERR_SLARTX_ACKRX : // 0x40
 126:i2c/i2c.c     **** 		I2C0_CONCLR = I2C_CONCLR_STAC;
 127:i2c/i2c.c     **** 		I2C0_CONSET = I2C_CONSET_AA;
 128:i2c/i2c.c     **** 		break;
 129:i2c/i2c.c     **** 
 130:i2c/i2c.c     **** 	case I2CERR_SLARTX_NACKRX : // 0x48
 131:i2c/i2c.c     **** 		I2C0_CONCLR = I2C_CONCLR_STAC;
 132:i2c/i2c.c     **** 		I2C0_CONSET = I2C_CONSET_STO;
 133:i2c/i2c.c     **** 		i2cBusInUse = 0;
 134:i2c/i2c.c     **** 		break;
 135:i2c/i2c.c     **** 
 136:i2c/i2c.c     **** 	case I2CERR_DATRX_ACKTX : // 0x50
 137:i2c/i2c.c     **** 		*i2cDataPtr++ = I2C0_DAT;
 138:i2c/i2c.c     **** 		if (--i2cDataLenRead) {
 139:i2c/i2c.c     **** 			I2C0_CONCLR = I2C_CONCLR_STAC;
 140:i2c/i2c.c     **** 			I2C0_CONSET = I2C_CONSET_AA;
 141:i2c/i2c.c     **** 		} 
 142:i2c/i2c.c     **** 		else {
 143:i2c/i2c.c     **** 			I2C0_CONCLR = I2C_CONCLR_STAC | I2C_CONCLR_AAC;
 144:i2c/i2c.c     **** 			i2cBusInUse = 0;
 145:i2c/i2c.c     **** 		}
 146:i2c/i2c.c     **** 		break;
 147:i2c/i2c.c     **** 
 148:i2c/i2c.c     **** 	case I2CERR_DATRX_NACKTX : // 0x58
 149:i2c/i2c.c     **** 		I2C0_CONCLR = I2C_CONCLR_STAC;
 150:i2c/i2c.c     **** 		I2C0_CONSET = I2C_CONSET_STO;
 151:i2c/i2c.c     **** 		i2cBusInUse = 0;
 152:i2c/i2c.c     **** 		break;
 153:i2c/i2c.c     **** 
 154:i2c/i2c.c     **** 	case I2CERR_NOINFO :
 155:i2c/i2c.c     **** 		break;
 156:i2c/i2c.c     **** 
 157:i2c/i2c.c     **** 	default:
 158:i2c/i2c.c     **** 		I2C0_CONCLR = I2C_CONCLR_I2ENC;
 159:i2c/i2c.c     **** 		i2cBusInUse = 0;
 160:i2c/i2c.c     **** 		break;
 161:i2c/i2c.c     ****   }
 162:i2c/i2c.c     **** 
 163:i2c/i2c.c     ****   I2C0_CONCLR = I2C_CONSET_SI;
 164:i2c/i2c.c     ****   
 165:i2c/i2c.c     ****   VICVectAddr = 0;		// clear this interrupt from the VIC
 166:i2c/i2c.c     ****   
 167:i2c/i2c.c     **** 	ISR_EXIT();                           // recover registers and return
 168:i2c/i2c.c     ****   
 169:i2c/i2c.c     **** }
 170:i2c/i2c.c     **** 
 171:i2c/i2c.c     **** 
 172:i2c/i2c.c     **** //  Our PCLK is 60Mhz (12Mhz Xtal, PLL x 4, VBPDIV = /1), we want ~400KHz SCLK
 173:i2c/i2c.c     **** void i2cInit (void)
 174:i2c/i2c.c     **** {
 175:i2c/i2c.c     ****   
 176:i2c/i2c.c     **** 	PCONP |= PCONP_PCI2C0;
 177:i2c/i2c.c     **** 	
 178:i2c/i2c.c     **** 	// setup SCL pin P02
 179:i2c/i2c.c     **** 	PINSEL0 &= ~(PINSEL0_P02_MASK );
 180:i2c/i2c.c     **** 	PINSEL0 |=   PINSEL0_P02_SCL0;
 181:i2c/i2c.c     **** 	
 182:i2c/i2c.c     **** 	// setup SDA pin P03
 183:i2c/i2c.c     **** 	PINSEL0 &= ~(PINSEL0_P03_MASK);
 184:i2c/i2c.c     **** 	PINSEL0 |=   PINSEL0_P03_SDA0;
 185:i2c/i2c.c     **** 
 186:i2c/i2c.c     **** 	// set default bitrate of ~400KHz, empirical value + Users Manual p.147 
 187:i2c/i2c.c     ****   I2C0_SCLL   = 76;
 188:i2c/i2c.c     ****   I2C0_SCLH   = 76;
 189:i2c/i2c.c     **** 
 190:i2c/i2c.c     **** 	// disable and reset interface
 191:i2c/i2c.c     **** 	I2C0_CONCLR = 0xFF;
 192:i2c/i2c.c     **** 	delay(10);
 193:i2c/i2c.c     **** 
 194:i2c/i2c.c     **** 	// enable interface
 195:i2c/i2c.c     ****   I2C0_CONCLR = I2C_CONCLR_MASK;
 196:i2c/i2c.c     **** 	I2C0_CONSET |= I2C_CONSET_I2EN;
 197:i2c/i2c.c     **** 	
 198:i2c/i2c.c     ****   //  Initialize I2C0 interrupt
 199:i2c/i2c.c     ****   VICIntSelect &= ~(1<<VIC_I2C0);					// setup I2C0 interrupt as IRQ
 200:i2c/i2c.c     ****   VICVectCntl7 = VIC_ENABLE | VIC_I2C0;		// assign VIC slot
 201:i2c/i2c.c     ****   VICVectAddr7 = (unsigned int)i2cISR;
 202:i2c/i2c.c     **** 	// enable I2C0 interrupt
 203:i2c/i2c.c     **** 	VICIntEnable |= (1<<VIC_I2C0);
 204:i2c/i2c.c     **** 
 205:i2c/i2c.c     **** }
 206:i2c/i2c.c     **** 
 207:i2c/i2c.c     **** //
 208:i2c/i2c.c     **** //
 209:i2c/i2c.c     **** //
 210:i2c/i2c.c     **** static i2cErr_e i2cStatus (void)
 211:i2c/i2c.c     **** {
  15              		.loc 1 211 0
  16              		@ Function supports interworking.
  17              		@ args = 0, pretend = 0, frame = 0
  18              		@ frame_needed = 0, uses_anonymous_args = 0
  19              		@ link register save eliminated.
  20              		@ lr needed for prologue
  21              	.L3:
 212:i2c/i2c.c     ****   i2cErr_e status;
 213:i2c/i2c.c     **** 
 214:i2c/i2c.c     ****   while (!(I2C0_CONSET & I2C_CONSET_SI))
  22              		.loc 1 214 0
  23 0000 18209FE5 		ldr	r2, .L11
  24 0004 0030D2E5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
  25 0008 080013E3 		tst	r3, #8
  26 000c FBFFFF0A 		beq	.L3
 215:i2c/i2c.c     ****     ;
 216:i2c/i2c.c     **** 
 217:i2c/i2c.c     ****   if ((status = I2C0_STAT) == I2CERR_BUSERRORx)
  27              		.loc 1 217 0
  28 0010 0400D2E5 		ldrb	r0, [r2, #4]	@ zero_extendqisi2
 218:i2c/i2c.c     ****     return I2CERR_BUSERROR;
 219:i2c/i2c.c     **** 
 220:i2c/i2c.c     ****   return status;
 221:i2c/i2c.c     **** }
  29              		.loc 1 221 0
  30 0014 000050E3 		cmp	r0, #0
  31 0018 0800A003 		moveq	r0, #8
  32 001c 1EFF2FE1 		bx	lr
  33              	.L12:
  34              		.align	2
  35              	.L11:
  36 0020 00C001E0 		.word	-536756224
  37              	.LFE4:
  39              		.align	2
  41              	i2cStop:
  42              	.LFB5:
 222:i2c/i2c.c     **** 
 223:i2c/i2c.c     **** //
 224:i2c/i2c.c     **** //
 225:i2c/i2c.c     **** //
 226:i2c/i2c.c     **** static i2cErr_e i2cStop (void)
 227:i2c/i2c.c     **** {
  43              		.loc 1 227 0
  44              		@ Function supports interworking.
  45              		@ args = 0, pretend = 0, frame = 0
  46              		@ frame_needed = 0, uses_anonymous_args = 0
  47              		@ link register save eliminated.
 228:i2c/i2c.c     ****   I2C0_CONCLR = I2C_CONCLR_SIC;
  48              		.loc 1 228 0
  49 0024 20309FE5 		ldr	r3, .L19
  50 0028 0820A0E3 		mov	r2, #8
  51 002c 1820C3E5 		strb	r2, [r3, #24]
 229:i2c/i2c.c     ****   I2C0_CONSET = I2C_CONSET_STO;
  52              		.loc 1 229 0
  53 0030 022082E0 		add	r2, r2, r2
  54 0034 0020C3E5 		strb	r2, [r3, #0]
  55              		.loc 1 227 0
  56              		@ lr needed for prologue
  57              	.L14:
 230:i2c/i2c.c     **** 
 231:i2c/i2c.c     ****   while (I2C0_CONSET & I2C_CONSET_STO) ;
  58              		.loc 1 231 0
  59 0038 0C309FE5 		ldr	r3, .L19
  60 003c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
  61 0040 100013E2 		ands	r0, r3, #16
  62 0044 FBFFFF1A 		bne	.L14
 232:i2c/i2c.c     **** 
 233:i2c/i2c.c     ****   return I2CERR_NONE;
 234:i2c/i2c.c     **** }
  63              		.loc 1 234 0
  64 0048 1EFF2FE1 		bx	lr
  65              	.L20:
  66              		.align	2
  67              	.L19:
  68 004c 00C001E0 		.word	-536756224
  69              	.LFE5:
  71              		.align	2
  73              	i2cStart:
  74              	.LFB6:
 235:i2c/i2c.c     **** 
 236:i2c/i2c.c     **** //
 237:i2c/i2c.c     **** //
 238:i2c/i2c.c     **** //
 239:i2c/i2c.c     **** static i2cErr_e i2cStart (void)
 240:i2c/i2c.c     **** {
  75              		.loc 1 240 0
  76              		@ Function supports interworking.
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
 241:i2c/i2c.c     ****   I2C0_CONCLR = I2C_CONCLR_SIC;
  79              		.loc 1 241 0
  80 0050 58309FE5 		ldr	r3, .L31
  81 0054 0820A0E3 		mov	r2, #8
  82              		.loc 1 240 0
  83 0058 04E02DE5 		str	lr, [sp, #-4]!
  84              	.LCFI0:
  85              		.loc 1 241 0
  86 005c 1820C3E5 		strb	r2, [r3, #24]
 242:i2c/i2c.c     ****   I2C0_CONSET = I2C_CONSET_STA;
  87              		.loc 1 242 0
  88 0060 182082E2 		add	r2, r2, #24
  89 0064 0020C3E5 		strb	r2, [r3, #0]
  90              	.LVL0:
  91              	.L22:
  92              	.LBB2:
 243:i2c/i2c.c     **** 
 244:i2c/i2c.c     ****   while (1)  {
 245:i2c/i2c.c     ****     i2cErr_e status;
 246:i2c/i2c.c     **** 
 247:i2c/i2c.c     ****     if (((status = i2cStatus ()) == I2CERR_STARTTX) || (status == I2CERR_REPEATEDSTARTTX)) {
  93              		.loc 1 247 0
  94 0068 E4FFFFEB 		bl	i2cStatus
  95              	.LVL1:
  96 006c 080050E3 		cmp	r0, #8
  97 0070 0100000A 		beq	.L23
  98 0074 100050E3 		cmp	r0, #16
  99 0078 0100001A 		bne	.L25
 100              	.L23:
 248:i2c/i2c.c     ****       I2C0_CONCLR = I2C_CONCLR_STAC;
 101              		.loc 1 248 0
 102 007c 0000A0E3 		mov	r0, #0
 103 0080 010000EA 		b	.L30
 104              	.L25:
 249:i2c/i2c.c     ****       return I2CERR_NONE;
 250:i2c/i2c.c     ****     }
 251:i2c/i2c.c     ****     else if (status != I2CERR_NOINFO) {
 105              		.loc 1 251 0
 106 0084 F80050E3 		cmp	r0, #248
 107 0088 0400000A 		beq	.L27
 108              	.L30:
 252:i2c/i2c.c     ****       I2C0_CONCLR = I2C_CONCLR_STAC;
 109              		.loc 1 252 0
 110 008c 1C309FE5 		ldr	r3, .L31
 111 0090 2020A0E3 		mov	r2, #32
 112 0094 1820C3E5 		strb	r2, [r3, #24]
 113              	.LVL2:
 114              	.LBE2:
 253:i2c/i2c.c     ****       return status;
 254:i2c/i2c.c     ****     } else
 255:i2c/i2c.c     ****       I2C0_CONCLR = I2C_CONCLR_SIC;
 256:i2c/i2c.c     ****   }
 257:i2c/i2c.c     **** }
 115              		.loc 1 257 0
 116 0098 04E09DE4 		ldr	lr, [sp], #4
 117 009c 1EFF2FE1 		bx	lr
 118              	.LVL3:
 119              	.L27:
 120              	.LBB3:
 121              		.loc 1 255 0
 122 00a0 08309FE5 		ldr	r3, .L31
 123 00a4 0820A0E3 		mov	r2, #8
 124 00a8 1820C3E5 		strb	r2, [r3, #24]
 125 00ac EDFFFFEA 		b	.L22
 126              	.L32:
 127              		.align	2
 128              	.L31:
 129 00b0 00C001E0 		.word	-536756224
 130              	.LBE3:
 131              	.LFE6:
 133              		.align	2
 135              	i2cRepeatedStart:
 136              	.LFB7:
 258:i2c/i2c.c     **** 
 259:i2c/i2c.c     **** //
 260:i2c/i2c.c     **** //
 261:i2c/i2c.c     **** //
 262:i2c/i2c.c     **** static i2cErr_e i2cRepeatedStart (void)
 263:i2c/i2c.c     **** {
 137              		.loc 1 263 0
 138              		@ Function supports interworking.
 139              		@ args = 0, pretend = 0, frame = 0
 140              		@ frame_needed = 0, uses_anonymous_args = 0
 141 00b4 04E02DE5 		str	lr, [sp, #-4]!
 142              	.LCFI1:
 143              	.L35:
 264:i2c/i2c.c     ****   while (!(I2C0_CONSET & I2C_CONSET_SI)) ;
 144              		.loc 1 264 0
 145 00b8 60209FE5 		ldr	r2, .L48
 146 00bc 0030D2E5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 147 00c0 080013E3 		tst	r3, #8
 148 00c4 FBFFFF0A 		beq	.L35
 265:i2c/i2c.c     **** 
 266:i2c/i2c.c     ****   I2C0_CONCLR = I2C_CONCLR_SIC;
 149              		.loc 1 266 0
 150 00c8 0830A0E3 		mov	r3, #8
 151 00cc 1830C2E5 		strb	r3, [r2, #24]
 267:i2c/i2c.c     ****   I2C0_CONSET = I2C_CONSET_STA;
 152              		.loc 1 267 0
 153 00d0 183083E2 		add	r3, r3, #24
 154 00d4 0030C2E5 		strb	r3, [r2, #0]
 155              	.LVL4:
 156              	.L37:
 157              	.LBB4:
 268:i2c/i2c.c     **** 
 269:i2c/i2c.c     ****   while (1) {
 270:i2c/i2c.c     ****     i2cErr_e status;
 271:i2c/i2c.c     **** 
 272:i2c/i2c.c     ****     if (((status = i2cStatus ()) == I2CERR_STARTTX) || (status == I2CERR_REPEATEDSTARTTX)) {
 158              		.loc 1 272 0
 159 00d8 C8FFFFEB 		bl	i2cStatus
 160              	.LVL5:
 161 00dc 080050E3 		cmp	r0, #8
 162 00e0 0100000A 		beq	.L38
 163 00e4 100050E3 		cmp	r0, #16
 164 00e8 0100001A 		bne	.L40
 165              	.L38:
 273:i2c/i2c.c     ****       I2C0_CONCLR = I2C_CONCLR_STAC;
 166              		.loc 1 273 0
 167 00ec 0000A0E3 		mov	r0, #0
 168 00f0 010000EA 		b	.L47
 169              	.L40:
 274:i2c/i2c.c     ****       return I2CERR_NONE;
 275:i2c/i2c.c     ****     } 
 276:i2c/i2c.c     ****     else if (status != I2CERR_NOINFO)  {
 170              		.loc 1 276 0
 171 00f4 F80050E3 		cmp	r0, #248
 172 00f8 0400000A 		beq	.L42
 173              	.L47:
 277:i2c/i2c.c     ****       I2C0_CONCLR = I2C_CONCLR_STAC;
 174              		.loc 1 277 0
 175 00fc 1C309FE5 		ldr	r3, .L48
 176 0100 2020A0E3 		mov	r2, #32
 177 0104 1820C3E5 		strb	r2, [r3, #24]
 178              	.LVL6:
 179              	.LBE4:
 278:i2c/i2c.c     ****       return status;
 279:i2c/i2c.c     ****     }
 280:i2c/i2c.c     ****     else
 281:i2c/i2c.c     ****       I2C0_CONCLR = I2C_CONCLR_SIC;
 282:i2c/i2c.c     ****   }
 283:i2c/i2c.c     **** }
 180              		.loc 1 283 0
 181 0108 04E09DE4 		ldr	lr, [sp], #4
 182 010c 1EFF2FE1 		bx	lr
 183              	.LVL7:
 184              	.L42:
 185              	.LBB5:
 186              		.loc 1 281 0
 187 0110 08309FE5 		ldr	r3, .L48
 188 0114 0820A0E3 		mov	r2, #8
 189 0118 1820C3E5 		strb	r2, [r3, #24]
 190 011c EDFFFFEA 		b	.L37
 191              	.L49:
 192              		.align	2
 193              	.L48:
 194 0120 00C001E0 		.word	-536756224
 195              	.LBE5:
 196              	.LFE7:
 198              		.align	2
 200              	i2cPutByte:
 201              	.LFB8:
 284:i2c/i2c.c     **** 
 285:i2c/i2c.c     **** //
 286:i2c/i2c.c     **** //
 287:i2c/i2c.c     **** //
 288:i2c/i2c.c     **** static i2cErr_e i2cPutByte (uint8 data)
 289:i2c/i2c.c     **** {
 202              		.loc 1 289 0
 203              		@ Function supports interworking.
 204              		@ args = 0, pretend = 0, frame = 0
 205              		@ frame_needed = 0, uses_anonymous_args = 0
 206              		@ link register save eliminated.
 207              	.LVL8:
 290:i2c/i2c.c     ****   if (!(I2C0_CONSET & I2C_CONSET_SI))
 208              		.loc 1 290 0
 209 0124 24209FE5 		ldr	r2, .L55
 210 0128 0030D2E5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 211 012c 080013E3 		tst	r3, #8
 212              		.loc 1 289 0
 213 0130 FF0000E2 		and	r0, r0, #255
 214              		.loc 1 290 0
 215 0134 0130A0E3 		mov	r3, #1
 291:i2c/i2c.c     ****     return I2CERR_BUSY;
 292:i2c/i2c.c     **** 
 293:i2c/i2c.c     ****   I2C0_DAT = data;
 294:i2c/i2c.c     ****   I2C0_CONCLR = I2C_CONCLR_SIC;
 216              		.loc 1 294 0
 217 0138 0830A013 		movne	r3, #8
 218              		.loc 1 293 0
 219 013c 0800C215 		strneb	r0, [r2, #8]
 220              		.loc 1 294 0
 221 0140 1830C215 		strneb	r3, [r2, #24]
 222 0144 0030A013 		movne	r3, #0
 295:i2c/i2c.c     **** 
 296:i2c/i2c.c     ****   return I2CERR_NONE;
 297:i2c/i2c.c     **** }
 223              		.loc 1 297 0
 224 0148 0300A0E1 		mov	r0, r3
 225              	.LVL9:
 226              		.loc 1 289 0
 227              		@ lr needed for prologue
 228              		.loc 1 297 0
 229 014c 1EFF2FE1 		bx	lr
 230              	.L56:
 231              		.align	2
 232              	.L55:
 233 0150 00C001E0 		.word	-536756224
 234              	.LFE8:
 236              		.align	2
 238              	i2cGetByte:
 239              	.LFB9:
 298:i2c/i2c.c     **** 
 299:i2c/i2c.c     **** //
 300:i2c/i2c.c     **** //
 301:i2c/i2c.c     **** //
 302:i2c/i2c.c     **** static i2cErr_e i2cGetByte (i2cMode_e mode, uint8 *pData)
 303:i2c/i2c.c     **** {
 240              		.loc 1 303 0
 241              		@ Function supports interworking.
 242              		@ args = 0, pretend = 0, frame = 0
 243              		@ frame_needed = 0, uses_anonymous_args = 0
 244              		@ link register save eliminated.
 245              	.LVL10:
 304:i2c/i2c.c     ****   switch (mode)  {
 246              		.loc 1 304 0
 247 0154 010050E3 		cmp	r0, #1
 248              		.loc 1 303 0
 249              		@ lr needed for prologue
 305:i2c/i2c.c     ****     case I2CMODE_ACK :
 306:i2c/i2c.c     ****       I2C0_CONCLR = I2C_CONCLR_SIC;
 307:i2c/i2c.c     ****       I2C0_CONSET = I2C_CONSET_AA;
 308:i2c/i2c.c     ****       break;
 309:i2c/i2c.c     **** 
 310:i2c/i2c.c     ****     case I2CMODE_NACK :
 311:i2c/i2c.c     ****       I2C0_CONCLR = (I2C_CONCLR_AAC | I2C_CONCLR_SIC);
 250              		.loc 1 311 0
 251 0158 00C0A0E3 		mov	ip, #0
 252              		.loc 1 304 0
 253 015c 0900000A 		beq	.L60
 254              		.loc 1 306 0
 255 0160 50209FE5 		ldr	r2, .L66
 256              		.loc 1 304 0
 257 0164 0200003A 		bcc	.L59
 258 0168 020050E3 		cmp	r0, #2
 259 016c 0900000A 		beq	.L61
 260 0170 0E0000EA 		b	.L62
 261              	.L59:
 262              		.loc 1 306 0
 263 0174 0830A0E3 		mov	r3, #8
 264 0178 1830C2E5 		strb	r3, [r2, #24]
 265              		.loc 1 307 0
 266 017c 0430A0E3 		mov	r3, #4
 267 0180 0030C2E5 		strb	r3, [r2, #0]
 268 0184 090000EA 		b	.L62
 269              	.L60:
 270              		.loc 1 311 0
 271 0188 28309FE5 		ldr	r3, .L66
 272 018c 0C20A0E3 		mov	r2, #12
 273 0190 1820C3E5 		strb	r2, [r3, #24]
 274 0194 050000EA 		b	.L62
 275              	.L61:
 312:i2c/i2c.c     ****       break;
 313:i2c/i2c.c     **** 
 314:i2c/i2c.c     ****     case I2CMODE_READ :
 315:i2c/i2c.c     ****       {
 316:i2c/i2c.c     ****         if (!(I2C0_CONSET & I2C_CONSET_SI))
 276              		.loc 1 316 0
 277 0198 0030D2E5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 278 019c 080013E3 		tst	r3, #8
 317:i2c/i2c.c     ****           return I2CERR_EMPTY;
 318:i2c/i2c.c     **** 
 319:i2c/i2c.c     ****         *pData = (uint8) I2C0_DAT;
 279              		.loc 1 319 0
 280 01a0 0830D215 		ldrneb	r3, [r2, #8]	@ zero_extendqisi2
 281 01a4 0030C115 		strneb	r3, [r1, #0]
 282              		.loc 1 316 0
 283 01a8 00C0A0E1 		mov	ip, r0
 284              		.loc 1 319 0
 285 01ac 00C0A013 		movne	ip, #0
 286              	.L62:
 320:i2c/i2c.c     ****       }
 321:i2c/i2c.c     ****       break;
 322:i2c/i2c.c     ****   }
 323:i2c/i2c.c     **** 
 324:i2c/i2c.c     ****   return I2CERR_NONE;
 325:i2c/i2c.c     **** } 
 287              		.loc 1 325 0
 288 01b0 0C00A0E1 		mov	r0, ip
 289              	.LVL11:
 290 01b4 1EFF2FE1 		bx	lr
 291              	.L67:
 292              		.align	2
 293              	.L66:
 294 01b8 00C001E0 		.word	-536756224
 295              	.LFE9:
 297              		.align	2
 299              	i2cWriteBufferEx_o:
 300              	.LFB10:
 326:i2c/i2c.c     **** 
 327:i2c/i2c.c     **** 
 328:i2c/i2c.c     **** static i2cErr_e i2cWriteBufferEx_o (uint8 address, uint8 *buffer, uint32 bufferLength, i2cFlags_e f
 329:i2c/i2c.c     **** {
 301              		.loc 1 329 0
 302              		@ Function supports interworking.
 303              		@ args = 0, pretend = 0, frame = 0
 304              		@ frame_needed = 0, uses_anonymous_args = 0
 305              	.LVL12:
 330:i2c/i2c.c     ****   uint32 i;
 331:i2c/i2c.c     ****   i2cErr_e status;
 332:i2c/i2c.c     **** 
 333:i2c/i2c.c     ****   if (flags & I2CFLAGS_START) {
 306              		.loc 1 333 0
 307 01bc 010013E3 		tst	r3, #1
 308              		.loc 1 329 0
 309 01c0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 310              	.LCFI2:
 311              		.loc 1 329 0
 312 01c4 0350A0E1 		mov	r5, r3
 313 01c8 0180A0E1 		mov	r8, r1
 314 01cc 0270A0E1 		mov	r7, r2
 315 01d0 FF6000E2 		and	r6, r0, #255
 316              		.loc 1 333 0
 317 01d4 0100000A 		beq	.L69
 318              	.LVL13:
 334:i2c/i2c.c     ****     if ((status = i2cStart ()) != I2CERR_NONE) {
 319              		.loc 1 334 0
 320 01d8 9CFFFFEB 		bl	i2cStart
 321 01dc 020000EA 		b	.L105
 322              	.LVL14:
 323              	.L69:
 335:i2c/i2c.c     ****       i2cStop ();
 336:i2c/i2c.c     ****       return status;
 337:i2c/i2c.c     ****     }
 338:i2c/i2c.c     ****   }
 339:i2c/i2c.c     ****   else if (flags & I2CFLAGS_REPEATEDSTART) {
 324              		.loc 1 339 0
 325 01e0 020013E3 		tst	r3, #2
 326 01e4 0200000A 		beq	.L71
 327              	.LVL15:
 340:i2c/i2c.c     ****     if ((status = i2cRepeatedStart ()) != I2CERR_NONE) {
 328              		.loc 1 340 0
 329 01e8 B1FFFFEB 		bl	i2cRepeatedStart
 330              	.LVL16:
 331              	.L105:
 332 01ec 004050E2 		subs	r4, r0, #0
 333              	.LVL17:
 334 01f0 2D00001A 		bne	.L104
 335              	.LVL18:
 336              	.L71:
 341:i2c/i2c.c     ****       i2cStop ();
 342:i2c/i2c.c     ****       return status;
 343:i2c/i2c.c     ****     }
 344:i2c/i2c.c     ****   }
 345:i2c/i2c.c     **** 
 346:i2c/i2c.c     ****   if (flags & I2CFLAGS_ADDRESS) {
 337              		.loc 1 346 0
 338 01f4 080015E3 		tst	r5, #8
 339 01f8 0600000A 		beq	.L76
 340              	.L100:
 347:i2c/i2c.c     ****     do
 348:i2c/i2c.c     ****       if (((status = i2cPutByte (address & ~0x01)) != I2CERR_NONE) && (status != I2CERR_BUSY))
 341              		.loc 1 348 0
 342 01fc FE0006E2 		and	r0, r6, #254
 343 0200 C7FFFFEB 		bl	i2cPutByte
 344 0204 004050E2 		subs	r4, r0, #0
 345 0208 0200000A 		beq	.L76
 346 020c 010054E3 		cmp	r4, #1
 347 0210 2600001A 		bne	.L73
 348 0214 F8FFFFEA 		b	.L100
 349              	.LVL19:
 350              	.L76:
 349:i2c/i2c.c     ****         return status;
 350:i2c/i2c.c     ****     while (status == I2CERR_BUSY);
 351:i2c/i2c.c     ****   }
 352:i2c/i2c.c     **** 
 353:i2c/i2c.c     ****   if (flags & I2CFLAGS_WRITEDATA) {
 351              		.loc 1 353 0
 352 0218 100015E3 		tst	r5, #16
 353 021c 0060A013 		movne	r6, #0
 354              	.LVL20:
 355 0220 1100001A 		bne	.L81
 356 0224 120000EA 		b	.L79
 357              	.LVL21:
 358              	.L96:
 354:i2c/i2c.c     ****     for (i = 0; i < bufferLength; i++, buffer++) {
 355:i2c/i2c.c     ****       while (1) {
 356:i2c/i2c.c     ****         if (((status = i2cStatus ()) == I2CERR_SLAWTX_ACKRX) || (status == I2CERR_DATTX_ACKRX)) {
 359              		.loc 1 356 0
 360 0228 74FFFFEB 		bl	i2cStatus
 361              	.LVL22:
 362 022c 180050E3 		cmp	r0, #24
 363 0230 0040A0E1 		mov	r4, r0
 364 0234 0100000A 		beq	.L101
 365 0238 280050E3 		cmp	r0, #40
 366 023c 0600001A 		bne	.L85
 367              	.L101:
 357:i2c/i2c.c     ****           do
 358:i2c/i2c.c     ****             if (((status = i2cPutByte (*buffer)) != I2CERR_NONE) && (status != I2CERR_BUSY))
 368              		.loc 1 358 0
 369 0240 0800D6E7 		ldrb	r0, [r6, r8]	@ zero_extendqisi2
 370 0244 B6FFFFEB 		bl	i2cPutByte
 371 0248 004050E2 		subs	r4, r0, #0
 372 024c 0500000A 		beq	.L86
 373 0250 010054E3 		cmp	r4, #1
 374 0254 1500001A 		bne	.L73
 375 0258 F8FFFFEA 		b	.L101
 376              	.LVL23:
 377              	.L85:
 359:i2c/i2c.c     ****               return status;
 360:i2c/i2c.c     ****           while (status == I2CERR_BUSY);
 361:i2c/i2c.c     ****           break;
 362:i2c/i2c.c     ****         }
 363:i2c/i2c.c     ****         else if (status != I2CERR_NOINFO) {
 378              		.loc 1 363 0
 379 025c F80050E3 		cmp	r0, #248
 380 0260 F0FFFF0A 		beq	.L96
 381 0264 100000EA 		b	.L104
 382              	.LVL24:
 383              	.L86:
 384              		.loc 1 354 0
 385 0268 016086E2 		add	r6, r6, #1
 386              	.LVL25:
 387              	.L81:
 388 026c 070056E1 		cmp	r6, r7
 389 0270 ECFFFF1A 		bne	.L96
 390              	.L79:
 364:i2c/i2c.c     ****           i2cStop ();
 365:i2c/i2c.c     ****           return status;
 366:i2c/i2c.c     ****         }
 367:i2c/i2c.c     ****       }
 368:i2c/i2c.c     ****     }
 369:i2c/i2c.c     ****   }
 370:i2c/i2c.c     **** 
 371:i2c/i2c.c     ****   if (flags & I2CFLAGS_STOP) {
 391              		.loc 1 371 0
 392 0274 040015E2 		ands	r0, r5, #4
 393              	.LVL26:
 394 0278 0040A001 		moveq	r4, r0
 395 027c 0B00000A 		beq	.L73
 396              	.LVL27:
 397              	.L97:
 372:i2c/i2c.c     ****     while (1) {
 373:i2c/i2c.c     ****       if (((status = i2cStatus ()) == I2CERR_SLAWTX_ACKRX) || (status == I2CERR_DATTX_ACKRX)) {
 398              		.loc 1 373 0
 399 0280 5EFFFFEB 		bl	i2cStatus
 400 0284 180050E3 		cmp	r0, #24
 401 0288 0040A0E1 		mov	r4, r0
 402 028c 0100000A 		beq	.L91
 403 0290 280050E3 		cmp	r0, #40
 404 0294 0200001A 		bne	.L93
 405              	.L91:
 374:i2c/i2c.c     ****         i2cStop ();
 406              		.loc 1 374 0
 407 0298 61FFFFEB 		bl	i2cStop
 408 029c 0040A0E3 		mov	r4, #0
 409 02a0 020000EA 		b	.L73
 410              	.LVL28:
 411              	.L93:
 375:i2c/i2c.c     ****         return I2CERR_NONE;
 376:i2c/i2c.c     ****       }
 377:i2c/i2c.c     ****       else if (status != I2CERR_NOINFO) {
 412              		.loc 1 377 0
 413 02a4 F80050E3 		cmp	r0, #248
 414 02a8 F4FFFF0A 		beq	.L97
 415              	.LVL29:
 416              	.L104:
 378:i2c/i2c.c     ****         i2cStop ();
 417              		.loc 1 378 0
 418 02ac 5CFFFFEB 		bl	i2cStop
 419              	.LVL30:
 420              	.L73:
 379:i2c/i2c.c     ****         return status;
 380:i2c/i2c.c     ****       }
 381:i2c/i2c.c     ****     }
 382:i2c/i2c.c     ****   }
 383:i2c/i2c.c     ****   return I2CERR_NONE;
 384:i2c/i2c.c     **** }
 421              		.loc 1 384 0
 422 02b0 0400A0E1 		mov	r0, r4
 423 02b4 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 424 02b8 1EFF2FE1 		bx	lr
 425              	.LFE10:
 427              		.align	2
 429              	i2cReadBufferEx_o:
 430              	.LFB11:
 385:i2c/i2c.c     **** 
 386:i2c/i2c.c     **** 
 387:i2c/i2c.c     **** static i2cErr_e i2cReadBufferEx_o (uint8 address, uint8 *buffer, uint32 bufferLength, i2cFlags_e fl
 388:i2c/i2c.c     **** {
 431              		.loc 1 388 0
 432              		@ Function supports interworking.
 433              		@ args = 0, pretend = 0, frame = 0
 434              		@ frame_needed = 0, uses_anonymous_args = 0
 435              	.LVL31:
 389:i2c/i2c.c     ****   uint32 i;
 390:i2c/i2c.c     ****   i2cErr_e status;
 391:i2c/i2c.c     **** 
 392:i2c/i2c.c     ****   if (flags & I2CFLAGS_START) {
 436              		.loc 1 392 0
 437 02bc 010013E3 		tst	r3, #1
 438              		.loc 1 388 0
 439 02c0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 440              	.LCFI3:
 441              		.loc 1 388 0
 442 02c4 0350A0E1 		mov	r5, r3
 443 02c8 0170A0E1 		mov	r7, r1
 444 02cc 0280A0E1 		mov	r8, r2
 445 02d0 FF6000E2 		and	r6, r0, #255
 446              		.loc 1 392 0
 447 02d4 0100000A 		beq	.L107
 448              	.LVL32:
 393:i2c/i2c.c     ****     if ((status = i2cStart ()) != I2CERR_NONE) {
 449              		.loc 1 393 0
 450 02d8 5CFFFFEB 		bl	i2cStart
 451 02dc 020000EA 		b	.L138
 452              	.LVL33:
 453              	.L107:
 394:i2c/i2c.c     ****       i2cStop ();
 395:i2c/i2c.c     ****       return status;
 396:i2c/i2c.c     ****     }
 397:i2c/i2c.c     ****   }
 398:i2c/i2c.c     ****   else if (flags & I2CFLAGS_REPEATEDSTART) {
 454              		.loc 1 398 0
 455 02e0 020013E3 		tst	r3, #2
 456 02e4 0200000A 		beq	.L109
 457              	.LVL34:
 399:i2c/i2c.c     ****     if ((status = i2cRepeatedStart ()) != I2CERR_NONE) {
 458              		.loc 1 399 0
 459 02e8 71FFFFEB 		bl	i2cRepeatedStart
 460              	.LVL35:
 461              	.L138:
 462 02ec 004050E2 		subs	r4, r0, #0
 463              	.LVL36:
 464 02f0 2100001A 		bne	.L137
 465              	.LVL37:
 466              	.L109:
 400:i2c/i2c.c     ****       i2cStop ();
 401:i2c/i2c.c     ****       return status;
 402:i2c/i2c.c     ****     }
 403:i2c/i2c.c     ****   }
 404:i2c/i2c.c     **** 
 405:i2c/i2c.c     ****   if (flags & I2CFLAGS_ADDRESS) {
 467              		.loc 1 405 0
 468 02f4 080015E3 		tst	r5, #8
 469 02f8 0600000A 		beq	.L114
 470              	.L133:
 406:i2c/i2c.c     ****     do
 407:i2c/i2c.c     ****       if (((status = i2cPutByte (address | 0x01)) != I2CERR_NONE) && (status != I2CERR_BUSY))
 471              		.loc 1 407 0
 472 02fc 010086E3 		orr	r0, r6, #1
 473 0300 87FFFFEB 		bl	i2cPutByte
 474 0304 004050E2 		subs	r4, r0, #0
 475 0308 0200000A 		beq	.L114
 476 030c 010054E3 		cmp	r4, #1
 477 0310 2400001A 		bne	.L111
 478 0314 F8FFFFEA 		b	.L133
 479              	.LVL38:
 480              	.L114:
 408:i2c/i2c.c     ****         return status;
 409:i2c/i2c.c     ****     while (status == I2CERR_BUSY);
 410:i2c/i2c.c     ****   }
 411:i2c/i2c.c     **** 
 412:i2c/i2c.c     ****   if (flags & I2CFLAGS_READDATA) {
 481              		.loc 1 412 0
 482 0318 200015E3 		tst	r5, #32
 483 031c 0060A013 		movne	r6, #0
 484              	.LVL39:
 485 0320 1900001A 		bne	.L119
 486 0324 1A0000EA 		b	.L117
 487              	.LVL40:
 488              	.L130:
 413:i2c/i2c.c     ****     for (i = 0; i < bufferLength; i++, buffer++)  {
 414:i2c/i2c.c     ****       while (1) {
 415:i2c/i2c.c     ****         if (((status = i2cStatus ()) == I2CERR_SLARTX_ACKRX) || (status == I2CERR_SLARTX_NACKRX) ||
 489              		.loc 1 415 0
 490 0328 34FFFFEB 		bl	i2cStatus
 491              	.LVL41:
 492 032c 400050E3 		cmp	r0, #64
 493 0330 0040A0E1 		mov	r4, r0
 494 0334 0200000A 		beq	.L121
 495 0338 500050E3 		cmp	r0, #80
 496 033c 48005013 		cmpne	r0, #72
 497 0340 0B00001A 		bne	.L123
 498              	.L121:
 416:i2c/i2c.c     ****           i2cGetByte ((i != bufferLength - 1) ? I2CMODE_ACK : I2CMODE_NACK, NULL);
 499              		.loc 1 416 0
 500 0344 010048E2 		sub	r0, r8, #1
 501 0348 000056E1 		cmp	r6, r0
 502 034c 0000A013 		movne	r0, #0
 503 0350 0100A003 		moveq	r0, #1
 504 0354 0010A0E3 		mov	r1, #0
 505 0358 7DFFFFEB 		bl	i2cGetByte
 506              	.L124:
 417:i2c/i2c.c     **** 
 418:i2c/i2c.c     ****           do
 419:i2c/i2c.c     ****             status = i2cGetByte (I2CMODE_READ, buffer);
 507              		.loc 1 419 0
 508 035c 0710A0E1 		mov	r1, r7
 509 0360 0200A0E3 		mov	r0, #2
 510 0364 7AFFFFEB 		bl	i2cGetByte
 420:i2c/i2c.c     ****           while (status == I2CERR_EMPTY);
 511              		.loc 1 420 0
 512 0368 020050E3 		cmp	r0, #2
 513 036c 0400001A 		bne	.L134
 514 0370 F9FFFFEA 		b	.L124
 515              	.LVL42:
 516              	.L123:
 421:i2c/i2c.c     **** 
 422:i2c/i2c.c     ****           break;
 423:i2c/i2c.c     ****         }
 424:i2c/i2c.c     ****         else if (status != I2CERR_NOINFO) {
 517              		.loc 1 424 0
 518 0374 F80050E3 		cmp	r0, #248
 519 0378 EAFFFF0A 		beq	.L130
 520              	.LVL43:
 521              	.L137:
 425:i2c/i2c.c     ****           i2cStop ();
 522              		.loc 1 425 0
 523 037c 28FFFFEB 		bl	i2cStop
 524 0380 080000EA 		b	.L111
 525              	.LVL44:
 526              	.L134:
 527              		.loc 1 413 0
 528 0384 016086E2 		add	r6, r6, #1
 529 0388 017087E2 		add	r7, r7, #1
 530              	.LVL45:
 531              	.L119:
 532 038c 080056E1 		cmp	r6, r8
 533 0390 E4FFFF1A 		bne	.L130
 534              	.L117:
 426:i2c/i2c.c     ****           return status;
 427:i2c/i2c.c     ****         }
 428:i2c/i2c.c     ****       }
 429:i2c/i2c.c     ****     }
 430:i2c/i2c.c     ****   }
 431:i2c/i2c.c     **** 
 432:i2c/i2c.c     ****   if (flags & I2CFLAGS_STOP)
 535              		.loc 1 432 0
 536 0394 040015E2 		ands	r0, r5, #4
 537              	.LVL46:
 538 0398 0040A001 		moveq	r4, r0
 539 039c 0100000A 		beq	.L111
 433:i2c/i2c.c     ****     i2cStop ();
 540              		.loc 1 433 0
 541 03a0 1FFFFFEB 		bl	i2cStop
 542 03a4 0040A0E3 		mov	r4, #0
 543              	.LVL47:
 544              	.L111:
 434:i2c/i2c.c     **** 
 435:i2c/i2c.c     ****   return I2CERR_NONE;
 436:i2c/i2c.c     **** }
 545              		.loc 1 436 0
 546 03a8 0400A0E1 		mov	r0, r4
 547 03ac F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 548 03b0 1EFF2FE1 		bx	lr
 549              	.LFE11:
 551              		.align	2
 553              	i2cPoll:
 554              	.LFB12:
 437:i2c/i2c.c     **** 
 438:i2c/i2c.c     **** //
 439:i2c/i2c.c     **** //
 440:i2c/i2c.c     **** static int i2cPoll (uint8 address)
 441:i2c/i2c.c     **** {
 555              		.loc 1 441 0
 556              		@ Function supports interworking.
 557              		@ args = 0, pretend = 0, frame = 0
 558              		@ frame_needed = 0, uses_anonymous_args = 0
 559              	.LVL48:
 442:i2c/i2c.c     ****   uint32 theFuture = miliSec + i2cTimeout;
 560              		.loc 1 442 0
 561 03b4 98309FE5 		ldr	r3, .L151
 562              		.loc 1 441 0
 563 03b8 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 564              	.LCFI4:
 565              		.loc 1 442 0
 566 03bc 002093E5 		ldr	r2, [r3, #0]
 567 03c0 90309FE5 		ldr	r3, .L151+4
 568 03c4 003093E5 		ldr	r3, [r3, #0]
 569              		.loc 1 441 0
 570 03c8 FF5000E2 		and	r5, r0, #255
 571              		.loc 1 442 0
 572 03cc 036082E0 		add	r6, r2, r3
 573              	.LVL49:
 574 03d0 0D0000EA 		b	.L140
 575              	.LVL50:
 576              	.L141:
 443:i2c/i2c.c     **** 
 444:i2c/i2c.c     ****   while (miliSec < theFuture)  {
 445:i2c/i2c.c     ****     if ((i2cErrno = i2cStart ()) != I2CERR_NONE)
 577              		.loc 1 445 0
 578 03d4 1DFFFFEB 		bl	i2cStart
 579 03d8 0030A0E1 		mov	r3, r0
 580 03dc 000053E3 		cmp	r3, #0
 446:i2c/i2c.c     ****       break;
 447:i2c/i2c.c     ****     if ((i2cErrno = i2cPutByte (address & ~0x01)) != I2CERR_NONE)
 581              		.loc 1 447 0
 582 03e0 FE0005E2 		and	r0, r5, #254
 583              		.loc 1 445 0
 584 03e4 003084E5 		str	r3, [r4, #0]
 585 03e8 0C00001A 		bne	.L142
 586              		.loc 1 447 0
 587 03ec 4CFFFFEB 		bl	i2cPutByte
 588 03f0 000050E3 		cmp	r0, #0
 589 03f4 000084E5 		str	r0, [r4, #0]
 590 03f8 0800001A 		bne	.L142
 448:i2c/i2c.c     ****       break;
 449:i2c/i2c.c     ****     if ((i2cErrno = i2cStatus ()) == I2CERR_SLAWTX_ACKRX)
 591              		.loc 1 449 0
 592 03fc FFFEFFEB 		bl	i2cStatus
 593 0400 180050E3 		cmp	r0, #24
 594 0404 000084E5 		str	r0, [r4, #0]
 595 0408 0900000A 		beq	.L145
 596              	.LVL51:
 597              	.L140:
 598              		.loc 1 444 0
 599 040c 40309FE5 		ldr	r3, .L151
 600 0410 003093E5 		ldr	r3, [r3, #0]
 601 0414 060053E1 		cmp	r3, r6
 602              		.loc 1 445 0
 603 0418 3C409FE5 		ldr	r4, .L151+8
 604              		.loc 1 444 0
 605 041c ECFFFF3A 		bcc	.L141
 606              	.L142:
 450:i2c/i2c.c     ****       break;
 451:i2c/i2c.c     ****   }
 452:i2c/i2c.c     **** 
 453:i2c/i2c.c     ****   if (i2cErrno != I2CERR_SLAWTX_ACKRX)
 607              		.loc 1 453 0
 608 0420 34209FE5 		ldr	r2, .L151+8
 609 0424 003092E5 		ldr	r3, [r2, #0]
 610 0428 180053E3 		cmp	r3, #24
 454:i2c/i2c.c     ****     i2cErrno = I2CERR_TIMEOUTACKPOLL;
 611              		.loc 1 454 0
 612 042c 0530A013 		movne	r3, #5
 613 0430 00308215 		strne	r3, [r2, #0]
 614              	.L145:
 455:i2c/i2c.c     **** 
 456:i2c/i2c.c     ****   i2cStop ();
 615              		.loc 1 456 0
 616 0434 FAFEFFEB 		bl	i2cStop
 457:i2c/i2c.c     **** 
 458:i2c/i2c.c     ****   if ( i2cErrno == I2CERR_SLAWTX_ACKRX ) return 0; else return -1;
 617              		.loc 1 458 0
 618 0438 1C309FE5 		ldr	r3, .L151+8
 619 043c 003093E5 		ldr	r3, [r3, #0]
 620 0440 180053E3 		cmp	r3, #24
 459:i2c/i2c.c     **** }
 621              		.loc 1 459 0
 622 0444 0000E013 		mvnne	r0, #0
 623 0448 0000A003 		moveq	r0, #0
 624 044c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 625 0450 1EFF2FE1 		bx	lr
 626              	.L152:
 627              		.align	2
 628              	.L151:
 629 0454 00000000 		.word	miliSec
 630 0458 00000000 		.word	i2cTimeout
 631 045c 00000000 		.word	i2cErrno
 632              	.LFE12:
 634              		.align	2
 635              		.global	i2cSetTimeout_o
 637              	i2cSetTimeout_o:
 638              	.LFB13:
 460:i2c/i2c.c     **** 
 461:i2c/i2c.c     **** //
 462:i2c/i2c.c     **** void i2cSetTimeout_o (unsigned int timeoutInMilliseconds)
 463:i2c/i2c.c     **** {
 639              		.loc 1 463 0
 640              		@ Function supports interworking.
 641              		@ args = 0, pretend = 0, frame = 0
 642              		@ frame_needed = 0, uses_anonymous_args = 0
 643              		@ link register save eliminated.
 644              	.LVL52:
 464:i2c/i2c.c     ****   i2cTimeout = timeoutInMilliseconds;
 645              		.loc 1 464 0
 646 0460 04309FE5 		ldr	r3, .L155
 647              		.loc 1 463 0
 648              		@ lr needed for prologue
 649              		.loc 1 464 0
 650 0464 000083E5 		str	r0, [r3, #0]
 465:i2c/i2c.c     **** }
 651              		.loc 1 465 0
 652 0468 1EFF2FE1 		bx	lr
 653              	.L156:
 654              		.align	2
 655              	.L155:
 656 046c 00000000 		.word	i2cTimeout
 657              	.LFE13:
 659              		.align	2
 660              		.global	i2cWriteBuffer_o
 662              	i2cWriteBuffer_o:
 663              	.LFB14:
 466:i2c/i2c.c     **** 
 467:i2c/i2c.c     **** int i2cWriteBuffer_o (uint8 address, uint8 *buffer, uint32 bufferLength)
 468:i2c/i2c.c     **** {
 664              		.loc 1 468 0
 665              		@ Function supports interworking.
 666              		@ args = 0, pretend = 0, frame = 0
 667              		@ frame_needed = 0, uses_anonymous_args = 0
 668              	.LVL53:
 669 0470 04E02DE5 		str	lr, [sp, #-4]!
 670              	.LCFI5:
 469:i2c/i2c.c     ****   if ((i2cErrno = i2cWriteBufferEx_o (address, buffer, bufferLength, I2CFLAGS_START | I2CFLAGS_ADDR
 671              		.loc 1 469 0
 672 0474 1D30A0E3 		mov	r3, #29
 673              		.loc 1 468 0
 674 0478 FF0000E2 		and	r0, r0, #255
 675              		.loc 1 469 0
 676 047c 4EFFFFEB 		bl	i2cWriteBufferEx_o
 677              	.LVL54:
 678 0480 10309FE5 		ldr	r3, .L162
 679 0484 000050E3 		cmp	r0, #0
 680 0488 000083E5 		str	r0, [r3, #0]
 470:i2c/i2c.c     ****     return -1;
 471:i2c/i2c.c     ****   }
 472:i2c/i2c.c     **** 
 473:i2c/i2c.c     ****   return 0;
 474:i2c/i2c.c     **** }
 681              		.loc 1 474 0
 682 048c 0000E013 		mvnne	r0, #0
 683 0490 04E09DE4 		ldr	lr, [sp], #4
 684 0494 1EFF2FE1 		bx	lr
 685              	.L163:
 686              		.align	2
 687              	.L162:
 688 0498 00000000 		.word	i2cErrno
 689              	.LFE14:
 691              		.align	2
 692              		.global	i2cReadBuffer_o
 694              	i2cReadBuffer_o:
 695              	.LFB15:
 475:i2c/i2c.c     **** 
 476:i2c/i2c.c     **** int i2cReadBuffer_o (uint8 address, uint8 *buffer, uint32 bufferLength)
 477:i2c/i2c.c     **** {
 696              		.loc 1 477 0
 697              		@ Function supports interworking.
 698              		@ args = 0, pretend = 0, frame = 0
 699              		@ frame_needed = 0, uses_anonymous_args = 0
 700              	.LVL55:
 701 049c 04E02DE5 		str	lr, [sp, #-4]!
 702              	.LCFI6:
 478:i2c/i2c.c     ****   if ((i2cErrno = i2cReadBufferEx_o (address, buffer, bufferLength, I2CFLAGS_START | I2CFLAGS_ADDRE
 703              		.loc 1 478 0
 704 04a0 2D30A0E3 		mov	r3, #45
 705              		.loc 1 477 0
 706 04a4 FF0000E2 		and	r0, r0, #255
 707              		.loc 1 478 0
 708 04a8 83FFFFEB 		bl	i2cReadBufferEx_o
 709              	.LVL56:
 710 04ac 10309FE5 		ldr	r3, .L169
 711 04b0 000050E3 		cmp	r0, #0
 712 04b4 000083E5 		str	r0, [r3, #0]
 479:i2c/i2c.c     ****     return -1;
 480:i2c/i2c.c     ****   }
 481:i2c/i2c.c     **** 
 482:i2c/i2c.c     ****   return 0;
 483:i2c/i2c.c     **** }
 713              		.loc 1 483 0
 714 04b8 0000E013 		mvnne	r0, #0
 715 04bc 04E09DE4 		ldr	lr, [sp], #4
 716 04c0 1EFF2FE1 		bx	lr
 717              	.L170:
 718              		.align	2
 719              	.L169:
 720 04c4 00000000 		.word	i2cErrno
 721              	.LFE15:
 723              		.align	2
 724              		.global	i2cWriteReadBuffer_o
 726              	i2cWriteReadBuffer_o:
 727              	.LFB16:
 484:i2c/i2c.c     **** 
 485:i2c/i2c.c     **** int i2cWriteReadBuffer_o (uint8 address, uint8 *buffer, uint32 putLength, uint32 getLength)
 486:i2c/i2c.c     **** {
 728              		.loc 1 486 0
 729              		@ Function supports interworking.
 730              		@ args = 0, pretend = 0, frame = 0
 731              		@ frame_needed = 0, uses_anonymous_args = 0
 732              	.LVL57:
 733 04c8 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 734              	.LCFI7:
 735              		.loc 1 486 0
 736 04cc FF4000E2 		and	r4, r0, #255
 737 04d0 0360A0E1 		mov	r6, r3
 487:i2c/i2c.c     ****   if ((i2cErrno = i2cWriteBufferEx_o (address, buffer, putLength, I2CFLAGS_START | I2CFLAGS_ADDRESS
 738              		.loc 1 487 0
 739 04d4 0400A0E1 		mov	r0, r4
 740              	.LVL58:
 741 04d8 1930A0E3 		mov	r3, #25
 742              	.LVL59:
 743              		.loc 1 486 0
 744 04dc 0150A0E1 		mov	r5, r1
 745              		.loc 1 487 0
 746 04e0 35FFFFEB 		bl	i2cWriteBufferEx_o
 747              	.LVL60:
 748 04e4 00C0A0E1 		mov	ip, r0
 488:i2c/i2c.c     ****     return -1;
 489:i2c/i2c.c     **** 	}
 490:i2c/i2c.c     **** 	
 491:i2c/i2c.c     ****   if ((i2cErrno = i2cReadBufferEx_o (address, buffer, getLength, I2CFLAGS_REPEATEDSTART | I2CFLAGS_
 749              		.loc 1 491 0
 750 04e8 0400A0E1 		mov	r0, r4
 751              		.loc 1 487 0
 752 04ec 38409FE5 		ldr	r4, .L177
 753              	.LVL61:
 754 04f0 00005CE3 		cmp	ip, #0
 755              		.loc 1 491 0
 756 04f4 0510A0E1 		mov	r1, r5
 757 04f8 0620A0E1 		mov	r2, r6
 758 04fc 2E30A0E3 		mov	r3, #46
 759              		.loc 1 487 0
 760 0500 00C084E5 		str	ip, [r4, #0]
 761 0504 0400001A 		bne	.L172
 762              	.LVL62:
 763              		.loc 1 491 0
 764 0508 6BFFFFEB 		bl	i2cReadBufferEx_o
 765              	.LVL63:
 766 050c 000050E3 		cmp	r0, #0
 767 0510 0030A0E1 		mov	r3, r0
 768 0514 000084E5 		str	r0, [r4, #0]
 769 0518 0000000A 		beq	.L175
 770              	.LVL64:
 771              	.L172:
 772 051c 0030E0E3 		mvn	r3, #0
 773              	.L175:
 492:i2c/i2c.c     ****     return -1;
 493:i2c/i2c.c     ****   }
 494:i2c/i2c.c     ****   
 495:i2c/i2c.c     ****   return 0;
 496:i2c/i2c.c     **** }
 774              		.loc 1 496 0
 775 0520 0300A0E1 		mov	r0, r3
 776 0524 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 777 0528 1EFF2FE1 		bx	lr
 778              	.L178:
 779              		.align	2
 780              	.L177:
 781 052c 00000000 		.word	i2cErrno
 782              	.LFE16:
 784              		.align	2
 785              		.global	i2cWriteBufferPoll
 787              	i2cWriteBufferPoll:
 788              	.LFB17:
 497:i2c/i2c.c     **** 
 498:i2c/i2c.c     **** int i2cWriteBufferPoll (uint8 address, uint8 *buffer, uint32 bufferLength)
 499:i2c/i2c.c     **** {
 789              		.loc 1 499 0
 790              		@ Function supports interworking.
 791              		@ args = 0, pretend = 0, frame = 0
 792              		@ frame_needed = 0, uses_anonymous_args = 0
 793              	.LVL65:
 794 0530 10402DE9 		stmfd	sp!, {r4, lr}
 795              	.LCFI8:
 796              		.loc 1 499 0
 797 0534 FF4000E2 		and	r4, r0, #255
 500:i2c/i2c.c     ****   int r;
 501:i2c/i2c.c     **** 
 502:i2c/i2c.c     ****   if (!(r = i2cWriteBuffer_o (address, buffer, bufferLength)))
 798              		.loc 1 502 0
 799 0538 0400A0E1 		mov	r0, r4
 800              	.LVL66:
 801 053c FEFFFFEB 		bl	i2cWriteBuffer_o
 802              	.LVL67:
 803 0540 000050E3 		cmp	r0, #0
 804 0544 0200001A 		bne	.L180
 503:i2c/i2c.c     ****     r = i2cPoll (address);
 805              		.loc 1 503 0
 806 0548 0400A0E1 		mov	r0, r4
 504:i2c/i2c.c     **** 
 505:i2c/i2c.c     ****   return r;
 506:i2c/i2c.c     **** }
 807              		.loc 1 506 0
 808 054c 1040BDE8 		ldmfd	sp!, {r4, lr}
 809              		.loc 1 503 0
 810 0550 97FFFFEA 		b	i2cPoll
 811              	.L180:
 812              		.loc 1 506 0
 813 0554 1040BDE8 		ldmfd	sp!, {r4, lr}
 814 0558 1EFF2FE1 		bx	lr
 815              	.LFE17:
 817              		.align	2
 818              		.global	i2cWriteReadBufferPoll
 820              	i2cWriteReadBufferPoll:
 821              	.LFB18:
 507:i2c/i2c.c     **** 
 508:i2c/i2c.c     **** int i2cWriteReadBufferPoll (uint8 address, uint8 *buffer, uint32 putLength, uint32 getLength)
 509:i2c/i2c.c     **** {
 822              		.loc 1 509 0
 823              		@ Function supports interworking.
 824              		@ args = 0, pretend = 0, frame = 0
 825              		@ frame_needed = 0, uses_anonymous_args = 0
 826              	.LVL68:
 827 055c 10402DE9 		stmfd	sp!, {r4, lr}
 828              	.LCFI9:
 829              		.loc 1 509 0
 830 0560 FF4000E2 		and	r4, r0, #255
 510:i2c/i2c.c     ****   int r;
 511:i2c/i2c.c     **** 
 512:i2c/i2c.c     ****   if (!(r = i2cWriteReadBuffer_o (address, buffer, putLength, getLength)))
 831              		.loc 1 512 0
 832 0564 0400A0E1 		mov	r0, r4
 833              	.LVL69:
 834 0568 FEFFFFEB 		bl	i2cWriteReadBuffer_o
 835              	.LVL70:
 836 056c 000050E3 		cmp	r0, #0
 837 0570 0200001A 		bne	.L184
 513:i2c/i2c.c     ****     r = i2cPoll (address);
 838              		.loc 1 513 0
 839 0574 0400A0E1 		mov	r0, r4
 514:i2c/i2c.c     ****     
 515:i2c/i2c.c     ****   return r;
 516:i2c/i2c.c     **** }
 840              		.loc 1 516 0
 841 0578 1040BDE8 		ldmfd	sp!, {r4, lr}
 842              		.loc 1 513 0
 843 057c 8CFFFFEA 		b	i2cPoll
 844              	.L184:
 845              		.loc 1 516 0
 846 0580 1040BDE8 		ldmfd	sp!, {r4, lr}
 847 0584 1EFF2FE1 		bx	lr
 848              	.LFE18:
 850              		.global	__divsi3
 851              		.align	2
 852              		.global	i2cWaitComplete
 854              	i2cWaitComplete:
 855              	.LFB20:
 517:i2c/i2c.c     **** 
 518:i2c/i2c.c     **** /*****************
 519:i2c/i2c.c     ****  * I2C interrupt driven support
 520:i2c/i2c.c     ****  *
 521:i2c/i2c.c     **** *****************/
 522:i2c/i2c.c     **** int i2cTransferBytes (uint8 address, uint8 *buffer, int bufferLenWrite, int bufferLenRead)
 523:i2c/i2c.c     **** {
 524:i2c/i2c.c     ****   //
 525:i2c/i2c.c     ****   //  Determine if our first operation will be a write or read.  If both, the
 526:i2c/i2c.c     ****   //  write always occurs first.
 527:i2c/i2c.c     ****   //
 528:i2c/i2c.c     ****   if (bufferLenWrite)
 529:i2c/i2c.c     ****     address &= ~0x01;
 530:i2c/i2c.c     ****   else if (bufferLenRead)
 531:i2c/i2c.c     ****     address |= 0x01;
 532:i2c/i2c.c     ****   else
 533:i2c/i2c.c     ****   {
 534:i2c/i2c.c     ****     i2cErrno = I2CERR_OTHER;
 535:i2c/i2c.c     ****     return -1;
 536:i2c/i2c.c     ****   }
 537:i2c/i2c.c     **** 
 538:i2c/i2c.c     ****   //
 539:i2c/i2c.c     ****   //  Wait until last I2C operation has finished.  
 540:i2c/i2c.c     ****   //
 541:i2c/i2c.c     ****   if (i2cBusInUse && i2cWaitComplete (i2cTimeout))
 542:i2c/i2c.c     ****   {
 543:i2c/i2c.c     ****     i2cErrno = I2CERR_TIMEOUT;
 544:i2c/i2c.c     ****     return -1;
 545:i2c/i2c.c     ****   }
 546:i2c/i2c.c     **** 
 547:i2c/i2c.c     ****   //
 548:i2c/i2c.c     ****   //  Mark bus as in use, save the address, buffer and length
 549:i2c/i2c.c     ****   //
 550:i2c/i2c.c     ****   i2cBusInUse = 1;
 551:i2c/i2c.c     ****   i2cAddress = address;
 552:i2c/i2c.c     ****   i2cDataBuffer = buffer;
 553:i2c/i2c.c     ****   i2cDataLenWrite = bufferLenWrite;
 554:i2c/i2c.c     ****   i2cDataLenRead = bufferLenRead;
 555:i2c/i2c.c     ****   i2cDataPtr = buffer;
 556:i2c/i2c.c     **** 
 557:i2c/i2c.c     ****   I2C0_CONCLR = I2C_CONCLR_MASK;
 558:i2c/i2c.c     ****   I2C0_CONSET = I2C_CONSET_I2EN;
 559:i2c/i2c.c     ****   I2C0_CONSET = I2C_CONSET_STA;
 560:i2c/i2c.c     **** 
 561:i2c/i2c.c     ****   return 0;
 562:i2c/i2c.c     **** }
 563:i2c/i2c.c     **** 
 564:i2c/i2c.c     **** //
 565:i2c/i2c.c     **** //
 566:i2c/i2c.c     **** //
 567:i2c/i2c.c     **** int i2cWaitComplete (int milliseconds)
 568:i2c/i2c.c     **** {
 856              		.loc 1 568 0
 857              		@ Function supports interworking.
 858              		@ args = 0, pretend = 0, frame = 0
 859              		@ frame_needed = 0, uses_anonymous_args = 0
 860              	.LVL71:
 569:i2c/i2c.c     ****   if (i2cBusInUse)  {
 861              		.loc 1 569 0
 862 0588 70309FE5 		ldr	r3, .L199
 863 058c 003093E5 		ldr	r3, [r3, #0]
 864 0590 000053E3 		cmp	r3, #0
 865              		.loc 1 568 0
 866 0594 10402DE9 		stmfd	sp!, {r4, lr}
 867              	.LCFI10:
 868              		.loc 1 569 0
 869 0598 1500000A 		beq	.L188
 870              	.LBB6:
 570:i2c/i2c.c     ****     uint32 theFuture;
 571:i2c/i2c.c     **** 
 572:i2c/i2c.c     ****     if (milliseconds < 10) milliseconds = 10;
 573:i2c/i2c.c     **** 
 574:i2c/i2c.c     ****     for (theFuture = miliSec + (milliseconds / 10); i2cBusInUse; ) {
 871              		.loc 1 574 0
 872 059c 60309FE5 		ldr	r3, .L199+4
 873 05a0 0A0050E3 		cmp	r0, #10
 874 05a4 0A00A0B3 		movlt	r0, #10
 875 05a8 0A10A0E3 		mov	r1, #10
 876 05ac 004093E5 		ldr	r4, [r3, #0]
 877 05b0 FEFFFFEB 		bl	__divsi3
 878              	.LVL72:
 879 05b4 002084E0 		add	r2, r4, r0
 880              	.LVL73:
 881 05b8 090000EA 		b	.L192
 882              	.L193:
 575:i2c/i2c.c     ****       if (miliSec > theFuture) {
 883              		.loc 1 575 0
 884 05bc 020054E1 		cmp	r4, r2
 885 05c0 0700009A 		bls	.L192
 576:i2c/i2c.c     ****         I2C0_CONCLR = I2C_CONCLR_I2ENC;
 886              		.loc 1 576 0
 887 05c4 3C309FE5 		ldr	r3, .L199+8
 888 05c8 4020A0E3 		mov	r2, #64
 889              	.LVL74:
 890 05cc 1820C3E5 		strb	r2, [r3, #24]
 577:i2c/i2c.c     ****         i2cErrno = I2CERR_TIMEOUTWC;
 891              		.loc 1 577 0
 892 05d0 34309FE5 		ldr	r3, .L199+12
 893 05d4 0420A0E3 		mov	r2, #4
 894 05d8 0000E0E3 		mvn	r0, #0
 895 05dc 002083E5 		str	r2, [r3, #0]
 896 05e0 040000EA 		b	.L195
 897              	.LVL75:
 898              	.L192:
 899              		.loc 1 574 0
 900 05e4 14309FE5 		ldr	r3, .L199
 901 05e8 003093E5 		ldr	r3, [r3, #0]
 902 05ec 000053E3 		cmp	r3, #0
 903 05f0 F1FFFF1A 		bne	.L193
 904              	.LVL76:
 905              	.L188:
 906 05f4 0000A0E3 		mov	r0, #0
 907              	.LVL77:
 908              	.L195:
 909              	.LBE6:
 578:i2c/i2c.c     ****         return -1;
 579:i2c/i2c.c     ****       }
 580:i2c/i2c.c     ****     }
 581:i2c/i2c.c     ****   }
 582:i2c/i2c.c     **** 
 583:i2c/i2c.c     ****   return 0;
 584:i2c/i2c.c     **** }
 910              		.loc 1 584 0
 911 05f8 1040BDE8 		ldmfd	sp!, {r4, lr}
 912 05fc 1EFF2FE1 		bx	lr
 913              	.L200:
 914              		.align	2
 915              	.L199:
 916 0600 00000000 		.word	i2cBusInUse
 917 0604 00000000 		.word	miliSec
 918 0608 00C001E0 		.word	-536756224
 919 060c 00000000 		.word	i2cErrno
 920              	.LFE20:
 922              		.align	2
 923              		.global	i2cTransferBytes
 925              	i2cTransferBytes:
 926              	.LFB19:
 927              		.loc 1 523 0
 928              		@ Function supports interworking.
 929              		@ args = 0, pretend = 0, frame = 0
 930              		@ frame_needed = 0, uses_anonymous_args = 0
 931              	.LVL78:
 932 0610 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 933              	.LCFI11:
 934              		.loc 1 528 0
 935 0614 007052E2 		subs	r7, r2, #0
 936              		.loc 1 529 0
 937 0618 FE4000E2 		and	r4, r0, #254
 938              	.LVL79:
 939              		.loc 1 523 0
 940 061c 0350A0E1 		mov	r5, r3
 941 0620 0160A0E1 		mov	r6, r1
 942 0624 FF0000E2 		and	r0, r0, #255
 943              		.loc 1 528 0
 944 0628 0400001A 		bne	.L204
 945              	.LVL80:
 946              		.loc 1 530 0
 947 062c 000053E3 		cmp	r3, #0
 948              		.loc 1 531 0
 949 0630 014080E3 		orr	r4, r0, #1
 950              		.loc 1 534 0
 951 0634 0720A003 		moveq	r2, #7
 952 0638 0000E0E3 		mvn	r0, #0
 953              	.LVL81:
 954              		.loc 1 530 0
 955 063c 0A00000A 		beq	.L212
 956              	.LVL82:
 957              	.L204:
 958              		.loc 1 541 0
 959 0640 8C309FE5 		ldr	r3, .L213
 960 0644 003093E5 		ldr	r3, [r3, #0]
 961 0648 000053E3 		cmp	r3, #0
 962 064c 0900000A 		beq	.L208
 963 0650 80309FE5 		ldr	r3, .L213+4
 964 0654 000093E5 		ldr	r0, [r3, #0]
 965              	.LVL83:
 966 0658 FEFFFFEB 		bl	i2cWaitComplete
 967 065c 000050E3 		cmp	r0, #0
 968              		.loc 1 543 0
 969 0660 0000E0E3 		mvn	r0, #0
 970              		.loc 1 541 0
 971 0664 0300000A 		beq	.L208
 972              		.loc 1 543 0
 973 0668 0320A0E3 		mov	r2, #3
 974              	.LVL84:
 975              	.L212:
 976 066c 68309FE5 		ldr	r3, .L213+8
 977 0670 002083E5 		str	r2, [r3, #0]
 978 0674 140000EA 		b	.L207
 979              	.LVL85:
 980              	.L208:
 981              		.loc 1 550 0
 982 0678 54309FE5 		ldr	r3, .L213
 983 067c 0120A0E3 		mov	r2, #1
 984 0680 002083E5 		str	r2, [r3, #0]
 985              		.loc 1 551 0
 986 0684 54309FE5 		ldr	r3, .L213+12
 987 0688 0040C3E5 		strb	r4, [r3, #0]
 988              		.loc 1 553 0
 989 068c 50309FE5 		ldr	r3, .L213+16
 990 0690 007083E5 		str	r7, [r3, #0]
 991              		.loc 1 554 0
 992 0694 4C309FE5 		ldr	r3, .L213+20
 993 0698 005083E5 		str	r5, [r3, #0]
 994              		.loc 1 555 0
 995 069c 48309FE5 		ldr	r3, .L213+24
 996              		.loc 1 557 0
 997 06a0 48109FE5 		ldr	r1, .L213+28
 998              		.loc 1 555 0
 999 06a4 006083E5 		str	r6, [r3, #0]
 1000              		.loc 1 557 0
 1001 06a8 6C30A0E3 		mov	r3, #108
 1002 06ac 1830C1E5 		strb	r3, [r1, #24]
 1003              		.loc 1 552 0
 1004 06b0 3C309FE5 		ldr	r3, .L213+32
 1005 06b4 006083E5 		str	r6, [r3, #0]
 1006              		.loc 1 558 0
 1007 06b8 4030A0E3 		mov	r3, #64
 1008 06bc 0030C1E5 		strb	r3, [r1, #0]
 1009              		.loc 1 559 0
 1010 06c0 2030A0E3 		mov	r3, #32
 1011 06c4 0030C1E5 		strb	r3, [r1, #0]
 1012 06c8 0000A0E3 		mov	r0, #0
 1013              	.LVL86:
 1014              	.L207:
 1015              		.loc 1 562 0
 1016 06cc F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1017 06d0 1EFF2FE1 		bx	lr
 1018              	.L214:
 1019              		.align	2
 1020              	.L213:
 1021 06d4 00000000 		.word	i2cBusInUse
 1022 06d8 00000000 		.word	i2cTimeout
 1023 06dc 00000000 		.word	i2cErrno
 1024 06e0 00000000 		.word	i2cAddress
 1025 06e4 00000000 		.word	i2cDataLenWrite
 1026 06e8 00000000 		.word	i2cDataLenRead
 1027 06ec 00000000 		.word	i2cDataPtr
 1028 06f0 00C001E0 		.word	-536756224
 1029 06f4 00000000 		.word	i2cDataBuffer
 1030              	.LFE19:
 1032              		.align	2
 1033              		.global	i2cWriteBufferEx
 1035              	i2cWriteBufferEx:
 1036              	.LFB21:
 585:i2c/i2c.c     **** 
 586:i2c/i2c.c     **** //
 587:i2c/i2c.c     **** int i2cWriteBufferEx (uint8 address, uint8 *buffer, uint32 bufferLength, int milliseconds)
 588:i2c/i2c.c     **** {
 1037              		.loc 1 588 0
 1038              		@ Function supports interworking.
 1039              		@ args = 0, pretend = 0, frame = 0
 1040              		@ frame_needed = 0, uses_anonymous_args = 0
 1041              	.LVL87:
 1042 06f8 10402DE9 		stmfd	sp!, {r4, lr}
 1043              	.LCFI12:
 1044              		.loc 1 588 0
 1045 06fc FF0000E2 		and	r0, r0, #255
 1046 0700 0340A0E1 		mov	r4, r3
 589:i2c/i2c.c     ****   if (i2cTransferBytes (address, buffer, bufferLength, 0))
 1047              		.loc 1 589 0
 1048 0704 0030A0E3 		mov	r3, #0
 1049              	.LVL88:
 1050 0708 FEFFFFEB 		bl	i2cTransferBytes
 1051              	.LVL89:
 1052 070c 000050E3 		cmp	r0, #0
 590:i2c/i2c.c     ****     return -1;
 591:i2c/i2c.c     **** 
 592:i2c/i2c.c     ****   return i2cWaitComplete (milliseconds);
 1053              		.loc 1 592 0
 1054 0710 0400A0E1 		mov	r0, r4
 1055              		.loc 1 589 0
 1056 0714 0100001A 		bne	.L220
 1057              	.LVL90:
 593:i2c/i2c.c     **** }
 1058              		.loc 1 593 0
 1059 0718 1040BDE8 		ldmfd	sp!, {r4, lr}
 1060              		.loc 1 592 0
 1061 071c FEFFFFEA 		b	i2cWaitComplete
 1062              	.LVL91:
 1063              	.L220:
 1064              		.loc 1 593 0
 1065 0720 0000E0E3 		mvn	r0, #0
 1066              	.LVL92:
 1067 0724 1040BDE8 		ldmfd	sp!, {r4, lr}
 1068 0728 1EFF2FE1 		bx	lr
 1069              	.LFE21:
 1071              		.align	2
 1072              		.global	i2cReadBufferEx
 1074              	i2cReadBufferEx:
 1075              	.LFB22:
 594:i2c/i2c.c     **** 
 595:i2c/i2c.c     **** int i2cReadBufferEx (uint8 address, uint8 *buffer, uint32 bufferLength, int milliseconds)
 596:i2c/i2c.c     **** {
 1076              		.loc 1 596 0
 1077              		@ Function supports interworking.
 1078              		@ args = 0, pretend = 0, frame = 0
 1079              		@ frame_needed = 0, uses_anonymous_args = 0
 1080              	.LVL93:
 1081 072c 10402DE9 		stmfd	sp!, {r4, lr}
 1082              	.LCFI13:
 1083              		.loc 1 596 0
 1084 0730 FF0000E2 		and	r0, r0, #255
 1085 0734 0340A0E1 		mov	r4, r3
 597:i2c/i2c.c     ****   if (i2cTransferBytes (address, buffer, 0, bufferLength))
 1086              		.loc 1 597 0
 1087 0738 0230A0E1 		mov	r3, r2
 1088              	.LVL94:
 1089 073c 0020A0E3 		mov	r2, #0
 1090              	.LVL95:
 1091 0740 FEFFFFEB 		bl	i2cTransferBytes
 1092              	.LVL96:
 1093 0744 000050E3 		cmp	r0, #0
 598:i2c/i2c.c     ****     return -1;
 599:i2c/i2c.c     **** 
 600:i2c/i2c.c     ****   return i2cWaitComplete (milliseconds);
 1094              		.loc 1 600 0
 1095 0748 0400A0E1 		mov	r0, r4
 1096              		.loc 1 597 0
 1097 074c 0100001A 		bne	.L226
 1098              	.LVL97:
 601:i2c/i2c.c     **** }
 1099              		.loc 1 601 0
 1100 0750 1040BDE8 		ldmfd	sp!, {r4, lr}
 1101              		.loc 1 600 0
 1102 0754 FEFFFFEA 		b	i2cWaitComplete
 1103              	.LVL98:
 1104              	.L226:
 1105              		.loc 1 601 0
 1106 0758 0000E0E3 		mvn	r0, #0
 1107              	.LVL99:
 1108 075c 1040BDE8 		ldmfd	sp!, {r4, lr}
 1109 0760 1EFF2FE1 		bx	lr
 1110              	.LFE22:
 1112              		.align	2
 1113              		.global	i2cWriteReadBufferEx
 1115              	i2cWriteReadBufferEx:
 1116              	.LFB23:
 602:i2c/i2c.c     **** 
 603:i2c/i2c.c     **** int i2cWriteReadBufferEx (uint8 address, uint8 *buffer, uint32 putLength, uint32 getLength, int mil
 604:i2c/i2c.c     **** {
 1117              		.loc 1 604 0
 1118              		@ Function supports interworking.
 1119              		@ args = 4, pretend = 0, frame = 0
 1120              		@ frame_needed = 0, uses_anonymous_args = 0
 1121              	.LVL100:
 1122 0764 10402DE9 		stmfd	sp!, {r4, lr}
 1123              	.LCFI14:
 1124              		.loc 1 604 0
 1125 0768 FF0000E2 		and	r0, r0, #255
 1126 076c 08409DE5 		ldr	r4, [sp, #8]
 605:i2c/i2c.c     ****   if (i2cTransferBytes (address, buffer, putLength, getLength))
 1127              		.loc 1 605 0
 1128 0770 FEFFFFEB 		bl	i2cTransferBytes
 1129              	.LVL101:
 1130 0774 000050E3 		cmp	r0, #0
 606:i2c/i2c.c     ****     return -1;
 607:i2c/i2c.c     **** 
 608:i2c/i2c.c     ****   return i2cWaitComplete (milliseconds);
 1131              		.loc 1 608 0
 1132 0778 0400A0E1 		mov	r0, r4
 1133              		.loc 1 605 0
 1134 077c 0100001A 		bne	.L232
 1135              	.LVL102:
 609:i2c/i2c.c     **** }
 1136              		.loc 1 609 0
 1137 0780 1040BDE8 		ldmfd	sp!, {r4, lr}
 1138              		.loc 1 608 0
 1139 0784 FEFFFFEA 		b	i2cWaitComplete
 1140              	.LVL103:
 1141              	.L232:
 1142              		.loc 1 609 0
 1143 0788 0000E0E3 		mvn	r0, #0
 1144              	.LVL104:
 1145 078c 1040BDE8 		ldmfd	sp!, {r4, lr}
 1146 0790 1EFF2FE1 		bx	lr
 1147              	.LFE23:
 1149              		.align	2
 1150              		.global	i2cWriteBuffer
 1152              	i2cWriteBuffer:
 1153              	.LFB24:
 610:i2c/i2c.c     **** 
 611:i2c/i2c.c     **** //
 612:i2c/i2c.c     **** //  DANGER, WILL ROBINSON!  The callers buffer must persist until we're done
 613:i2c/i2c.c     **** //
 614:i2c/i2c.c     **** int i2cWriteBuffer (uint8 address, uint8 *buffer, uint32 bufferLength)
 615:i2c/i2c.c     **** {
 1154              		.loc 1 615 0
 1155              		@ Function supports interworking.
 1156              		@ args = 0, pretend = 0, frame = 0
 1157              		@ frame_needed = 0, uses_anonymous_args = 0
 1158              		@ link register save eliminated.
 1159              	.LVL105:
 616:i2c/i2c.c     ****   return i2cWriteBufferEx (address, buffer, bufferLength, i2cTimeout);
 1160              		.loc 1 616 0
 1161 0794 08309FE5 		ldr	r3, .L235
 1162 0798 003093E5 		ldr	r3, [r3, #0]
 1163              		.loc 1 615 0
 1164 079c FF0000E2 		and	r0, r0, #255
 1165              		@ lr needed for prologue
 617:i2c/i2c.c     **** }
 1166              		.loc 1 617 0
 1167              		.loc 1 616 0
 1168 07a0 FEFFFFEA 		b	i2cWriteBufferEx
 1169              	.LVL106:
 1170              	.L236:
 1171              		.align	2
 1172              	.L235:
 1173 07a4 00000000 		.word	i2cTimeout
 1174              	.LFE24:
 1176              		.align	2
 1177              		.global	i2cReadBuffer
 1179              	i2cReadBuffer:
 1180              	.LFB25:
 618:i2c/i2c.c     **** 
 619:i2c/i2c.c     **** int i2cReadBuffer (uint8 address, uint8 *buffer, uint32 bufferLength)
 620:i2c/i2c.c     **** {
 1181              		.loc 1 620 0
 1182              		@ Function supports interworking.
 1183              		@ args = 0, pretend = 0, frame = 0
 1184              		@ frame_needed = 0, uses_anonymous_args = 0
 1185              		@ link register save eliminated.
 1186              	.LVL107:
 621:i2c/i2c.c     ****   return i2cReadBufferEx (address, buffer, bufferLength, i2cTimeout);
 1187              		.loc 1 621 0
 1188 07a8 08309FE5 		ldr	r3, .L239
 1189 07ac 003093E5 		ldr	r3, [r3, #0]
 1190              		.loc 1 620 0
 1191 07b0 FF0000E2 		and	r0, r0, #255
 1192              		@ lr needed for prologue
 622:i2c/i2c.c     **** }
 1193              		.loc 1 622 0
 1194              		.loc 1 621 0
 1195 07b4 FEFFFFEA 		b	i2cReadBufferEx
 1196              	.LVL108:
 1197              	.L240:
 1198              		.align	2
 1199              	.L239:
 1200 07b8 00000000 		.word	i2cTimeout
 1201              	.LFE25:
 1203              		.align	2
 1204              		.global	i2cWriteReadBuffer
 1206              	i2cWriteReadBuffer:
 1207              	.LFB26:
 623:i2c/i2c.c     **** 
 624:i2c/i2c.c     **** int i2cWriteReadBuffer (uint8 address, uint8 *buffer, uint32 putLength, uint32 getLength)
 625:i2c/i2c.c     **** {
 1208              		.loc 1 625 0
 1209              		@ Function supports interworking.
 1210              		@ args = 0, pretend = 0, frame = 0
 1211              		@ frame_needed = 0, uses_anonymous_args = 0
 1212              	.LVL109:
 1213 07bc 04E02DE5 		str	lr, [sp, #-4]!
 1214              	.LCFI15:
 626:i2c/i2c.c     ****   return i2cWriteReadBufferEx (address, buffer, putLength, getLength, i2cTimeout);
 1215              		.loc 1 626 0
 1216 07c0 1CC09FE5 		ldr	ip, .L243
 1217 07c4 00C09CE5 		ldr	ip, [ip, #0]
 1218              		.loc 1 625 0
 1219 07c8 04D04DE2 		sub	sp, sp, #4
 1220              	.LCFI16:
 1221              		.loc 1 625 0
 1222 07cc FF0000E2 		and	r0, r0, #255
 1223              		.loc 1 626 0
 1224 07d0 00C08DE5 		str	ip, [sp, #0]
 1225 07d4 FEFFFFEB 		bl	i2cWriteReadBufferEx
 1226              	.LVL110:
 627:i2c/i2c.c     **** }
 1227              		.loc 1 627 0
 1228 07d8 04D08DE2 		add	sp, sp, #4
 1229 07dc 04E09DE4 		ldr	lr, [sp], #4
 1230 07e0 1EFF2FE1 		bx	lr
 1231              	.L244:
 1232              		.align	2
 1233              	.L243:
 1234 07e4 00000000 		.word	i2cTimeout
 1235              	.LFE26:
 1237              		.align	2
 1238              		.global	i2cSetTimeout
 1240              	i2cSetTimeout:
 1241              	.LFB27:
 628:i2c/i2c.c     **** 
 629:i2c/i2c.c     **** void i2cSetTimeout (int timeoutInMilliseconds)
 630:i2c/i2c.c     **** {
 1242              		.loc 1 630 0
 1243              		@ Function supports interworking.
 1244              		@ args = 0, pretend = 0, frame = 0
 1245              		@ frame_needed = 0, uses_anonymous_args = 0
 1246              		@ link register save eliminated.
 1247              	.LVL111:
 631:i2c/i2c.c     ****   if (timeoutInMilliseconds < 10)
 632:i2c/i2c.c     ****     timeoutInMilliseconds = 10;
 633:i2c/i2c.c     **** 
 634:i2c/i2c.c     ****   i2cTimeout = timeoutInMilliseconds;
 1248              		.loc 1 634 0
 1249 07e8 0C309FE5 		ldr	r3, .L249
 1250              		.loc 1 631 0
 1251 07ec 0A0050E3 		cmp	r0, #10
 1252 07f0 0A00A0B3 		movlt	r0, #10
 1253              		.loc 1 630 0
 1254              		@ lr needed for prologue
 1255              		.loc 1 634 0
 1256 07f4 000083E5 		str	r0, [r3, #0]
 635:i2c/i2c.c     **** }
 1257              		.loc 1 635 0
 1258 07f8 1EFF2FE1 		bx	lr
 1259              	.L250:
 1260              		.align	2
 1261              	.L249:
 1262 07fc 00000000 		.word	i2cTimeout
 1263              	.LFE27:
 1265              		.align	2
 1266              		.global	eepromRdSBlk
 1268              	eepromRdSBlk:
 1269              	.LFB28:
 636:i2c/i2c.c     **** 
 637:i2c/i2c.c     **** 
 638:i2c/i2c.c     **** /*****************
 639:i2c/i2c.c     ****  * EEProm CAT1640 8Kbx8 support
 640:i2c/i2c.c     ****  *
 641:i2c/i2c.c     **** *****************/
 642:i2c/i2c.c     **** 
 643:i2c/i2c.c     **** #define EEPROM_ADDRESS 0xae
 644:i2c/i2c.c     **** 
 645:i2c/i2c.c     **** // EEProm Read SubBlock in range 0xXX00-0xXX40
 646:i2c/i2c.c     **** int eepromRdSBlk (uint16 addr, uint8 *buffer, uint16 Length)
 647:i2c/i2c.c     **** {
 1270              		.loc 1 647 0
 1271              		@ Function supports interworking.
 1272              		@ args = 0, pretend = 0, frame = 0
 1273              		@ frame_needed = 0, uses_anonymous_args = 0
 1274              		@ link register save eliminated.
 1275              	.LVL112:
 648:i2c/i2c.c     ****   int r;
 649:i2c/i2c.c     ****   
 650:i2c/i2c.c     **** 	addr &= 0x1fff;
 1276              		.loc 1 650 0
 1277 0800 8009A0E1 		mov	r0, r0, asl #19
 1278              	.LVL113:
 1279 0804 A009A0E1 		mov	r0, r0, lsr #19
 1280              		.loc 1 647 0
 1281 0808 0238A0E1 		mov	r3, r2, asl #16
 651:i2c/i2c.c     ****   buffer [0] = addr >> 8;
 1282              		.loc 1 651 0
 1283 080c 20C4A0E1 		mov	ip, r0, lsr #8
 652:i2c/i2c.c     ****   buffer [1] = addr;
 1284              		.loc 1 652 0
 1285 0810 0100C1E5 		strb	r0, [r1, #1]
 653:i2c/i2c.c     **** 
 654:i2c/i2c.c     ****   //r = i2cWriteReadBufferPoll ((uint8)EEPROM_ADDRESS, buffer, 2, Length);
 655:i2c/i2c.c     ****   //printf("\n\reepromRdInt addr=%x len=%d", (int)addr, (int)Length);
 656:i2c/i2c.c     **** 	r = i2cWriteReadBuffer ((uint8)EEPROM_ADDRESS, buffer, 2, Length);
 1286              		.loc 1 656 0
 1287 0814 2338A0E1 		mov	r3, r3, lsr #16
 1288 0818 AE00A0E3 		mov	r0, #174
 1289              	.LVL114:
 1290 081c 0220A0E3 		mov	r2, #2
 1291              	.LVL115:
 1292              		.loc 1 647 0
 1293              		@ lr needed for prologue
 1294              		.loc 1 651 0
 1295 0820 00C0C1E5 		strb	ip, [r1, #0]
 657:i2c/i2c.c     **** 	
 658:i2c/i2c.c     ****   return r;
 659:i2c/i2c.c     **** }
 1296              		.loc 1 659 0
 1297              		.loc 1 656 0
 1298 0824 FEFFFFEA 		b	i2cWriteReadBuffer
 1299              	.LVL116:
 1300              	.LFE28:
 1302              		.align	2
 1303              		.global	eepromWrSBlk
 1305              	eepromWrSBlk:
 1306              	.LFB29:
 660:i2c/i2c.c     **** 
 661:i2c/i2c.c     **** // EEProm Write SubBlock in range 0xXX00-0xXX40
 662:i2c/i2c.c     **** int eepromWrSBlk (uint16 addr, uint8 *buffer, uint16 Length)
 663:i2c/i2c.c     **** {
 1307              		.loc 1 663 0
 1308              		@ Function supports interworking.
 1309              		@ args = 0, pretend = 0, frame = 0
 1310              		@ frame_needed = 0, uses_anonymous_args = 0
 1311              		@ link register save eliminated.
 1312              	.LVL117:
 664:i2c/i2c.c     ****   int r;
 665:i2c/i2c.c     **** 
 666:i2c/i2c.c     **** 	addr &= 0x1fff;
 1313              		.loc 1 666 0
 1314 0828 8009A0E1 		mov	r0, r0, asl #19
 1315              	.LVL118:
 1316              		.loc 1 663 0
 1317 082c 0228A0E1 		mov	r2, r2, asl #16
 1318              	.LVL119:
 1319              		.loc 1 666 0
 1320 0830 A009A0E1 		mov	r0, r0, lsr #19
 1321              		.loc 1 663 0
 1322 0834 2228A0E1 		mov	r2, r2, lsr #16
 1323              	.LVL120:
 667:i2c/i2c.c     ****   buffer [0] = addr >> 8;
 1324              		.loc 1 667 0
 1325 0838 20C4A0E1 		mov	ip, r0, lsr #8
 668:i2c/i2c.c     ****   buffer [1] = addr;
 1326              		.loc 1 668 0
 1327 083c 0100C1E5 		strb	r0, [r1, #1]
 669:i2c/i2c.c     ****   
 670:i2c/i2c.c     ****   //r = i2cWriteBufferPoll ((uint8)EEPROM_ADDRESS, buffer, Length + 2);
 671:i2c/i2c.c     ****   //printf("\n\reepromWrInt addr=%x len=%d", (int)addr, (int)Length);
 672:i2c/i2c.c     **** 	r = i2cWriteBuffer ((uint8)EEPROM_ADDRESS, buffer, Length + 2);
 1328              		.loc 1 672 0
 1329 0840 022082E2 		add	r2, r2, #2
 1330              	.LVL121:
 1331 0844 AE00A0E3 		mov	r0, #174
 1332              	.LVL122:
 1333              		.loc 1 663 0
 1334              		@ lr needed for prologue
 1335              		.loc 1 667 0
 1336 0848 00C0C1E5 		strb	ip, [r1, #0]
 673:i2c/i2c.c     ****   return r;
 674:i2c/i2c.c     **** }
 1337              		.loc 1 674 0
 1338              		.loc 1 672 0
 1339 084c FEFFFFEA 		b	i2cWriteBuffer
 1340              	.LVL123:
 1341              	.LFE29:
 1343              		.align	2
 1344              		.global	eepromRead
 1346              	eepromRead:
 1347              	.LFB31:
 675:i2c/i2c.c     **** 
 676:i2c/i2c.c     **** int eepromWrite (uint16 addr, uint8* buffer, int Length)
 677:i2c/i2c.c     **** {
 678:i2c/i2c.c     **** 	int len, bLen, el, r, idx;
 679:i2c/i2c.c     **** 	uint16 adr = addr;
 680:i2c/i2c.c     **** 	
 681:i2c/i2c.c     **** 	idx = 0;
 682:i2c/i2c.c     **** 	r = -1;
 683:i2c/i2c.c     **** 	len = Length;
 684:i2c/i2c.c     **** 	while ( len > 0 ) {
 685:i2c/i2c.c     **** 		if ( len > 64 ) bLen = 64; else bLen = len;
 686:i2c/i2c.c     **** 		el = ((adr|0x3f)-adr)+1;
 687:i2c/i2c.c     **** 		if ( el<bLen ) bLen = el;	
 688:i2c/i2c.c     **** 		r = eepromWrSBlk (adr, &buffer[idx], bLen);
 689:i2c/i2c.c     **** 		//printf("\n\reeWrBlk adr=%d(x%x) len=%d idx=%d r=%d ", adr, adr, bLen, idx, r);
 690:i2c/i2c.c     **** 		LogWr(0x50); LogWr(adr); LogWr((uint16)bLen);
 691:i2c/i2c.c     **** 
 692:i2c/i2c.c     **** 		idx += bLen;
 693:i2c/i2c.c     **** 		len -= bLen;
 694:i2c/i2c.c     **** 		adr += bLen;
 695:i2c/i2c.c     **** 	}
 696:i2c/i2c.c     **** 	return r;
 697:i2c/i2c.c     **** }
 698:i2c/i2c.c     **** 
 699:i2c/i2c.c     **** int eepromRead (uint16 addr, uint8* buffer, int Length)
 700:i2c/i2c.c     **** {
 1348              		.loc 1 700 0
 1349              		@ Function supports interworking.
 1350              		@ args = 0, pretend = 0, frame = 0
 1351              		@ frame_needed = 0, uses_anonymous_args = 0
 1352              	.LVL124:
 1353 0850 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1354              	.LCFI17:
 1355              		.loc 1 700 0
 1356 0854 0008A0E1 		mov	r0, r0, asl #16
 1357              	.LVL125:
 1358 0858 7D0F52E3 		cmp	r2, #500
 1359 085c 0270A0B1 		movlt	r7, r2
 1360 0860 7D7FA0A3 		movge	r7, #500
 1361              	.LVL126:
 1362 0864 01A0A0E1 		mov	sl, r1
 1363 0868 2058A0E1 		mov	r5, r0, lsr #16
 1364              	.LVL127:
 1365 086c 0090E0E3 		mvn	r9, #0
 1366              	.LVL128:
 1367 0870 0080A0E3 		mov	r8, #0
 1368              	.LVL129:
 1369 0874 140000EA 		b	.L256
 1370              	.LVL130:
 1371              	.L257:
 701:i2c/i2c.c     **** 	int bLen, len, el, r, idx;
 702:i2c/i2c.c     **** 	uint16 adr = addr;
 703:i2c/i2c.c     **** 	
 704:i2c/i2c.c     **** 	len = Length;
 705:i2c/i2c.c     **** 	if ( len > 500 ) len = 500;
 706:i2c/i2c.c     **** 	idx = 0;
 707:i2c/i2c.c     **** 	r = -1;
 708:i2c/i2c.c     **** 	
 709:i2c/i2c.c     **** 	while ( len > 0 ) {
 1372              		.loc 1 709 0
 1373 0878 400057E3 		cmp	r7, #64
 1374 087c 0730A0B1 		movlt	r3, r7
 1375 0880 4030A0A3 		movge	r3, #64
 1376              	.LVL131:
 710:i2c/i2c.c     **** 		if ( len > 64 ) bLen = 64; else bLen = len;
 711:i2c/i2c.c     **** 		el = ((adr|0x3f)-adr)+1;
 1377              		.loc 1 711 0
 1378 0884 030056E1 		cmp	r6, r3
 1379 0888 0360A0A1 		movge	r6, r3
 712:i2c/i2c.c     **** 		if ( el<bLen ) bLen = el;	
 713:i2c/i2c.c     **** 		r = eepromRdSBlk (adr, &buffer[idx], bLen);
 1380              		.loc 1 713 0
 1381 088c 0648A0E1 		mov	r4, r6, asl #16
 1382 0890 2448A0E1 		mov	r4, r4, lsr #16
 1383 0894 0420A0E1 		mov	r2, r4
 1384              	.LVL132:
 1385 0898 FEFFFFEB 		bl	eepromRdSBlk
 1386              	.LVL133:
 1387 089c 0090A0E1 		mov	r9, r0
 714:i2c/i2c.c     **** 		//printf("\n\reeRdBlk adr=%d(x%x) len=%d idx=%d r=%d ", adr, adr, bLen, idx, r);
 715:i2c/i2c.c     **** 		LogWr(0x51); LogWr(adr); LogWr((uint16)bLen);
 1388              		.loc 1 715 0
 1389 08a0 5100A0E3 		mov	r0, #81
 1390 08a4 FEFFFFEB 		bl	LogWr
 1391 08a8 0500A0E1 		mov	r0, r5
 1392 08ac FEFFFFEB 		bl	LogWr
 1393 08b0 0400A0E1 		mov	r0, r4
 1394 08b4 FEFFFFEB 		bl	LogWr
 716:i2c/i2c.c     **** 
 717:i2c/i2c.c     **** 		idx += bLen;
 718:i2c/i2c.c     **** 		len -= bLen;
 719:i2c/i2c.c     **** 		adr += bLen;
 1395              		.loc 1 719 0
 1396 08b8 044085E0 		add	r4, r5, r4
 1397 08bc 0448A0E1 		mov	r4, r4, asl #16
 1398              		.loc 1 718 0
 1399 08c0 077066E0 		rsb	r7, r6, r7
 1400              		.loc 1 717 0
 1401 08c4 068088E0 		add	r8, r8, r6
 1402              		.loc 1 719 0
 1403 08c8 2458A0E1 		mov	r5, r4, lsr #16
 1404              	.LVL134:
 1405              	.L256:
 1406              		.loc 1 711 0
 1407 08cc 3F3085E3 		orr	r3, r5, #63
 1408 08d0 033065E0 		rsb	r3, r5, r3
 1409              		.loc 1 709 0
 1410 08d4 000057E3 		cmp	r7, #0
 1411              		.loc 1 711 0
 1412 08d8 016083E2 		add	r6, r3, #1
 1413              		.loc 1 713 0
 1414 08dc 08108AE0 		add	r1, sl, r8
 1415 08e0 0500A0E1 		mov	r0, r5
 1416              		.loc 1 709 0
 1417 08e4 E3FFFFCA 		bgt	.L257
 720:i2c/i2c.c     **** 	}
 721:i2c/i2c.c     **** 	return r;
 722:i2c/i2c.c     **** }
 1418              		.loc 1 722 0
 1419 08e8 0900A0E1 		mov	r0, r9
 1420 08ec F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1421 08f0 1EFF2FE1 		bx	lr
 1422              	.LFE31:
 1424              		.align	2
 1425              		.global	eepromWrite
 1427              	eepromWrite:
 1428              	.LFB30:
 1429              		.loc 1 677 0
 1430              		@ Function supports interworking.
 1431              		@ args = 0, pretend = 0, frame = 0
 1432              		@ frame_needed = 0, uses_anonymous_args = 0
 1433              	.LVL135:
 1434 08f4 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1435              	.LCFI18:
 1436              		.loc 1 677 0
 1437 08f8 0008A0E1 		mov	r0, r0, asl #16
 1438              	.LVL136:
 1439 08fc 0190A0E1 		mov	r9, r1
 1440 0900 0270A0E1 		mov	r7, r2
 1441              	.LVL137:
 1442 0904 2058A0E1 		mov	r5, r0, lsr #16
 1443              	.LVL138:
 1444 0908 00A0E0E3 		mvn	sl, #0
 1445              	.LVL139:
 1446 090c 0080A0E3 		mov	r8, #0
 1447              	.LVL140:
 1448 0910 140000EA 		b	.L261
 1449              	.LVL141:
 1450              	.L262:
 1451              		.loc 1 684 0
 1452 0914 400057E3 		cmp	r7, #64
 1453 0918 0730A0B1 		movlt	r3, r7
 1454 091c 4030A0A3 		movge	r3, #64
 1455              	.LVL142:
 1456              		.loc 1 686 0
 1457 0920 030056E1 		cmp	r6, r3
 1458 0924 0360A0A1 		movge	r6, r3
 1459              		.loc 1 688 0
 1460 0928 0648A0E1 		mov	r4, r6, asl #16
 1461 092c 2448A0E1 		mov	r4, r4, lsr #16
 1462 0930 0420A0E1 		mov	r2, r4
 1463              	.LVL143:
 1464 0934 FEFFFFEB 		bl	eepromWrSBlk
 1465              	.LVL144:
 1466 0938 00A0A0E1 		mov	sl, r0
 1467              		.loc 1 690 0
 1468 093c 5000A0E3 		mov	r0, #80
 1469 0940 FEFFFFEB 		bl	LogWr
 1470 0944 0500A0E1 		mov	r0, r5
 1471 0948 FEFFFFEB 		bl	LogWr
 1472 094c 0400A0E1 		mov	r0, r4
 1473 0950 FEFFFFEB 		bl	LogWr
 1474              		.loc 1 694 0
 1475 0954 044085E0 		add	r4, r5, r4
 1476 0958 0448A0E1 		mov	r4, r4, asl #16
 1477              		.loc 1 693 0
 1478 095c 077066E0 		rsb	r7, r6, r7
 1479              		.loc 1 692 0
 1480 0960 068088E0 		add	r8, r8, r6
 1481              		.loc 1 694 0
 1482 0964 2458A0E1 		mov	r5, r4, lsr #16
 1483              	.LVL145:
 1484              	.L261:
 1485              		.loc 1 686 0
 1486 0968 3F3085E3 		orr	r3, r5, #63
 1487 096c 033065E0 		rsb	r3, r5, r3
 1488              		.loc 1 684 0
 1489 0970 000057E3 		cmp	r7, #0
 1490              		.loc 1 686 0
 1491 0974 016083E2 		add	r6, r3, #1
 1492              		.loc 1 688 0
 1493 0978 081089E0 		add	r1, r9, r8
 1494 097c 0500A0E1 		mov	r0, r5
 1495              		.loc 1 684 0
 1496 0980 E3FFFFCA 		bgt	.L262
 1497              		.loc 1 697 0
 1498 0984 0A00A0E1 		mov	r0, sl
 1499 0988 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1500 098c 1EFF2FE1 		bx	lr
 1501              	.LFE30:
 1503              		.align	2
 1505              	i2cISR:
 1506              	.LFB2:
 1507              		.loc 1 63 0
 1508              		@ Function supports interworking.
 1509              		@ Naked Function: prologue and epilogue provided by programmer.
 1510              		@ args = 0, pretend = 0, frame = 0
 1511              		@ frame_needed = 0, uses_anonymous_args = 0
 1512              		.loc 1 64 0
 1513 0990 04E04EE2 		 sub   lr, lr,#4
 1514 0994 FF5F2DE9 	 stmfd sp!,{r0-r12,lr}
 1515 0998 00104FE1 	 mrs   r1, spsr
 1516 099c 02002DE9 	 stmfd sp!,{r1}
 1517              		.loc 1 66 0
 1518 09a0 EC519FE5 		ldr	r5, .L296
 1519 09a4 0430D5E5 		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 1520 09a8 E8419FE5 		ldr	r4, .L296+4
 1521 09ac F83003E2 		and	r3, r3, #248
 1522 09b0 003084E5 		str	r3, [r4, #0]
 1523              		.loc 1 67 0
 1524 09b4 4900A0E3 		mov	r0, #73
 1525 09b8 FEFFFFEB 		bl	LogWr
 1526 09bc B000D4E1 		ldrh	r0, [r4, #0]
 1527 09c0 FEFFFFEB 		bl	LogWr
 1528              		.loc 1 69 0
 1529 09c4 004094E5 		ldr	r4, [r4, #0]
 1530 09c8 300054E3 		cmp	r4, #48
 1531 09cc 5C00000A 		beq	.L278
 1532 09d0 0E00008A 		bhi	.L280
 1533 09d4 100054E3 		cmp	r4, #16
 1534 09d8 2000000A 		beq	.L269
 1535 09dc 0400008A 		bhi	.L281
 1536 09e0 000054E3 		cmp	r4, #0
 1537 09e4 1800000A 		beq	.L267
 1538 09e8 080054E3 		cmp	r4, #8
 1539 09ec 5900001A 		bne	.L266
 1540 09f0 1A0000EA 		b	.L269
 1541              	.L281:
 1542 09f4 200054E3 		cmp	r4, #32
 1543 09f8 5300000A 		beq	.L295
 1544 09fc 280054E3 		cmp	r4, #40
 1545 0a00 1A00000A 		beq	.L272
 1546 0a04 180054E3 		cmp	r4, #24
 1547 0a08 5200001A 		bne	.L266
 1548 0a0c 1D0000EA 		b	.L291
 1549              	.L280:
 1550 0a10 480054E3 		cmp	r4, #72
 1551 0a14 4A00000A 		beq	.L278
 1552 0a18 0400008A 		bhi	.L282
 1553 0a1c 380054E3 		cmp	r4, #56
 1554 0a20 3000000A 		beq	.L274
 1555 0a24 400054E3 		cmp	r4, #64
 1556 0a28 4A00001A 		bne	.L266
 1557 0a2c 3A0000EA 		b	.L292
 1558              	.L282:
 1559 0a30 580054E3 		cmp	r4, #88
 1560 0a34 4200000A 		beq	.L278
 1561 0a38 F80054E3 		cmp	r4, #248
 1562 0a3c 4B00000A 		beq	.L279
 1563 0a40 500054E3 		cmp	r4, #80
 1564 0a44 4300001A 		bne	.L266
 1565 0a48 280000EA 		b	.L277
 1566              	.L267:
 1567              		.loc 1 72 0
 1568 0a4c 1430A0E3 		mov	r3, #20
 1569 0a50 0030C5E5 		strb	r3, [r5, #0]
 1570              		.loc 1 73 0
 1571 0a54 40319FE5 		ldr	r3, .L296+8
 1572 0a58 004083E5 		str	r4, [r3, #0]
 1573 0a5c 430000EA 		b	.L279
 1574              	.L269:
 1575              		.loc 1 81 0
 1576 0a60 38319FE5 		ldr	r3, .L296+12
 1577 0a64 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1578 0a68 0830C5E5 		strb	r3, [r5, #8]
 1579 0a6c 3F0000EA 		b	.L279
 1580              	.L272:
 1581              		.loc 1 95 0
 1582 0a70 2C219FE5 		ldr	r2, .L296+16
 1583 0a74 003092E5 		ldr	r3, [r2, #0]
 1584 0a78 013043E2 		sub	r3, r3, #1
 1585 0a7c 000053E3 		cmp	r3, #0
 1586 0a80 003082E5 		str	r3, [r2, #0]
 1587 0a84 0700000A 		beq	.L283
 1588              	.L291:
 1589              		.loc 1 96 0
 1590 0a88 18219FE5 		ldr	r2, .L296+20
 1591 0a8c 003092E5 		ldr	r3, [r2, #0]
 1592 0a90 0110D3E4 		ldrb	r1, [r3], #1	@ zero_extendqisi2
 1593 0a94 003082E5 		str	r3, [r2, #0]
 1594              		.loc 1 97 0
 1595 0a98 2030A0E3 		mov	r3, #32
 1596              		.loc 1 96 0
 1597 0a9c 0810C5E5 		strb	r1, [r5, #8]
 1598              		.loc 1 97 0
 1599 0aa0 1830C5E5 		strb	r3, [r5, #24]
 1600 0aa4 310000EA 		b	.L279
 1601              	.L283:
 1602              		.loc 1 100 0
 1603 0aa8 FC309FE5 		ldr	r3, .L296+24
 1604 0aac 002093E5 		ldr	r2, [r3, #0]
 1605 0ab0 000052E3 		cmp	r2, #0
 1606              		.loc 1 101 0
 1607 0ab4 2030A003 		moveq	r3, #32
 1608 0ab8 1830C505 		streqb	r3, [r5, #24]
 1609              		.loc 1 102 0
 1610 0abc 1030A003 		moveq	r3, #16
 1611 0ac0 0030C505 		streqb	r3, [r5, #0]
 1612 0ac4 2700000A 		beq	.L294
 1613              	.L285:
 1614              		.loc 1 106 0
 1615 0ac8 D0109FE5 		ldr	r1, .L296+12
 1616 0acc 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 1617              		.loc 1 107 0
 1618 0ad0 D8209FE5 		ldr	r2, .L296+28
 1619              		.loc 1 106 0
 1620 0ad4 013083E3 		orr	r3, r3, #1
 1621              		.loc 1 107 0
 1622 0ad8 002092E5 		ldr	r2, [r2, #0]
 1623              		.loc 1 106 0
 1624 0adc 0030C1E5 		strb	r3, [r1, #0]
 1625              		.loc 1 107 0
 1626 0ae0 C0309FE5 		ldr	r3, .L296+20
 1627 0ae4 002083E5 		str	r2, [r3, #0]
 1628              	.L274:
 1629              		.loc 1 120 0
 1630 0ae8 2030A0E3 		mov	r3, #32
 1631 0aec 0D0000EA 		b	.L293
 1632              	.L277:
 1633              		.loc 1 137 0
 1634 0af0 B0009FE5 		ldr	r0, .L296+20
 1635 0af4 0830D5E5 		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 1636 0af8 002090E5 		ldr	r2, [r0, #0]
 1637              		.loc 1 138 0
 1638 0afc A8109FE5 		ldr	r1, .L296+24
 1639              		.loc 1 137 0
 1640 0b00 0130C2E4 		strb	r3, [r2], #1
 1641              		.loc 1 138 0
 1642 0b04 003091E5 		ldr	r3, [r1, #0]
 1643 0b08 01C043E2 		sub	ip, r3, #1
 1644 0b0c 00005CE3 		cmp	ip, #0
 1645              		.loc 1 137 0
 1646 0b10 002080E5 		str	r2, [r0, #0]
 1647              		.loc 1 138 0
 1648 0b14 00C081E5 		str	ip, [r1, #0]
 1649 0b18 0400000A 		beq	.L287
 1650              	.L292:
 1651              		.loc 1 139 0
 1652 0b1c 2030A0E3 		mov	r3, #32
 1653 0b20 1830C5E5 		strb	r3, [r5, #24]
 1654              		.loc 1 140 0
 1655 0b24 0430A0E3 		mov	r3, #4
 1656              	.L293:
 1657 0b28 0030C5E5 		strb	r3, [r5, #0]
 1658 0b2c 0F0000EA 		b	.L279
 1659              	.L287:
 1660              		.loc 1 143 0
 1661 0b30 2430A0E3 		mov	r3, #36
 1662 0b34 1830C5E5 		strb	r3, [r5, #24]
 1663              		.loc 1 144 0
 1664 0b38 5C309FE5 		ldr	r3, .L296+8
 1665 0b3c 00C083E5 		str	ip, [r3, #0]
 1666 0b40 0A0000EA 		b	.L279
 1667              	.L278:
 1668              		.loc 1 149 0
 1669 0b44 2030A0E3 		mov	r3, #32
 1670 0b48 1830C5E5 		strb	r3, [r5, #24]
 1671              	.L295:
 1672              		.loc 1 150 0
 1673 0b4c 1030A0E3 		mov	r3, #16
 1674 0b50 0030C5E5 		strb	r3, [r5, #0]
 1675 0b54 020000EA 		b	.L290
 1676              	.L266:
 1677              		.loc 1 158 0
 1678 0b58 34309FE5 		ldr	r3, .L296
 1679 0b5c 4020A0E3 		mov	r2, #64
 1680 0b60 1820C3E5 		strb	r2, [r3, #24]
 1681              	.L290:
 1682              		.loc 1 159 0
 1683 0b64 0020A0E3 		mov	r2, #0
 1684              	.L294:
 1685 0b68 2C309FE5 		ldr	r3, .L296+8
 1686 0b6c 002083E5 		str	r2, [r3, #0]
 1687              	.L279:
 1688              		.loc 1 163 0
 1689 0b70 1C309FE5 		ldr	r3, .L296
 1690 0b74 0820A0E3 		mov	r2, #8
 1691 0b78 1820C3E5 		strb	r2, [r3, #24]
 1692              		.loc 1 165 0
 1693 0b7c 0020A0E3 		mov	r2, #0
 1694 0b80 0F3CE0E3 		mvn	r3, #3840
 1695 0b84 CF2003E5 		str	r2, [r3, #-207]
 1696              		.loc 1 167 0
 1697 0b88 0200BDE8 		 ldmfd sp!,{r1}
 1698 0b8c 01F061E1 	 msr   spsr_c,r1
 1699 0b90 FF9FFDE8 	 ldmfd sp!,{r0-r12,pc}^
 1700              		.loc 1 169 0
 1701              	.L297:
 1702              		.align	2
 1703              	.L296:
 1704 0b94 00C001E0 		.word	-536756224
 1705 0b98 00000000 		.word	i2cErrno
 1706 0b9c 00000000 		.word	i2cBusInUse
 1707 0ba0 00000000 		.word	i2cAddress
 1708 0ba4 00000000 		.word	i2cDataLenWrite
 1709 0ba8 00000000 		.word	i2cDataPtr
 1710 0bac 00000000 		.word	i2cDataLenRead
 1711 0bb0 00000000 		.word	i2cDataBuffer
 1712              	.LFE2:
 1714              		.align	2
 1715              		.global	i2cInit
 1717              	i2cInit:
 1718              	.LFB3:
 1719              		.loc 1 174 0
 1720              		@ Function supports interworking.
 1721              		@ args = 0, pretend = 0, frame = 0
 1722              		@ frame_needed = 0, uses_anonymous_args = 0
 1723              		.loc 1 176 0
 1724 0bb4 A8209FE5 		ldr	r2, .L300
 1725 0bb8 C43092E5 		ldr	r3, [r2, #196]
 1726 0bbc 803083E3 		orr	r3, r3, #128
 1727 0bc0 C43082E5 		str	r3, [r2, #196]
 1728              		.loc 1 179 0
 1729 0bc4 1D2842E2 		sub	r2, r2, #1900544
 1730 0bc8 003092E5 		ldr	r3, [r2, #0]
 1731 0bcc 3030C3E3 		bic	r3, r3, #48
 1732 0bd0 003082E5 		str	r3, [r2, #0]
 1733              		.loc 1 180 0
 1734 0bd4 003092E5 		ldr	r3, [r2, #0]
 1735 0bd8 103083E3 		orr	r3, r3, #16
 1736 0bdc 003082E5 		str	r3, [r2, #0]
 1737              		.loc 1 183 0
 1738 0be0 003092E5 		ldr	r3, [r2, #0]
 1739 0be4 C030C3E3 		bic	r3, r3, #192
 1740 0be8 003082E5 		str	r3, [r2, #0]
 1741              		.loc 1 184 0
 1742 0bec 003092E5 		ldr	r3, [r2, #0]
 1743              		.loc 1 174 0
 1744 0bf0 10402DE9 		stmfd	sp!, {r4, lr}
 1745              	.LCFI19:
 1746              		.loc 1 184 0
 1747 0bf4 403083E3 		orr	r3, r3, #64
 1748              		.loc 1 187 0
 1749 0bf8 68409FE5 		ldr	r4, .L300+4
 1750              		.loc 1 184 0
 1751 0bfc 003082E5 		str	r3, [r2, #0]
 1752              		.loc 1 187 0
 1753 0c00 4C10A0E3 		mov	r1, #76
 1754              		.loc 1 191 0
 1755 0c04 0030E0E3 		mvn	r3, #0
 1756              		.loc 1 187 0
 1757 0c08 B411C4E1 		strh	r1, [r4, #20]	@ movhi
 1758              		.loc 1 192 0
 1759 0c0c 0A00A0E3 		mov	r0, #10
 1760              		.loc 1 188 0
 1761 0c10 B011C4E1 		strh	r1, [r4, #16]	@ movhi
 1762              		.loc 1 191 0
 1763 0c14 1830C4E5 		strb	r3, [r4, #24]
 1764              		.loc 1 192 0
 1765 0c18 FEFFFFEB 		bl	delay
 1766              		.loc 1 195 0
 1767 0c1c 6C30A0E3 		mov	r3, #108
 1768 0c20 1830C4E5 		strb	r3, [r4, #24]
 1769              		.loc 1 196 0
 1770 0c24 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 1771 0c28 403083E3 		orr	r3, r3, #64
 1772 0c2c 0030C4E5 		strb	r3, [r4, #0]
 1773              		.loc 1 199 0
 1774 0c30 0F2CE0E3 		mvn	r2, #3840
 1775 0c34 F33012E5 		ldr	r3, [r2, #-243]
 1776 0c38 023CC3E3 		bic	r3, r3, #512
 1777 0c3c F33002E5 		str	r3, [r2, #-243]
 1778              		.loc 1 200 0
 1779 0c40 2930A0E3 		mov	r3, #41
 1780 0c44 1D3182E5 		str	r3, [r2, #285]
 1781              		.loc 1 201 0
 1782 0c48 1C309FE5 		ldr	r3, .L300+8
 1783 0c4c 1D3082E5 		str	r3, [r2, #29]
 1784              		.loc 1 203 0
 1785 0c50 EF3012E5 		ldr	r3, [r2, #-239]
 1786 0c54 023C83E3 		orr	r3, r3, #512
 1787 0c58 EF3002E5 		str	r3, [r2, #-239]
 1788              		.loc 1 205 0
 1789 0c5c 1040BDE8 		ldmfd	sp!, {r4, lr}
 1790 0c60 1EFF2FE1 		bx	lr
 1791              	.L301:
 1792              		.align	2
 1793              	.L300:
 1794 0c64 00C01FE0 		.word	-534790144
 1795 0c68 00C001E0 		.word	-536756224
 1796 0c6c 90090000 		.word	i2cISR
 1797              	.LFE3:
 1799              		.global	i2cTimeout
 1800              		.data
 1801              		.align	2
 1804              	i2cTimeout:
 1805 0000 64000000 		.word	100
 1806              		.comm	i2cErrno,4,4
 1807              		.comm	i2cBusInUse,4,4
 1808              		.comm	i2cAddress,1,1
 1809              		.comm	i2cDataBuffer,4,4
 1810              		.comm	i2cDataLenWrite,4,4
 1811              		.comm	i2cDataLenRead,4,4
 1812              		.comm	i2cDataPtr,4,4
 2271              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 i2c.c
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:12     .text:00000000 i2cStatus
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:23     .text:00000000 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:36     .text:00000020 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:41     .text:00000024 i2cStop
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:49     .text:00000024 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:68     .text:0000004c $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:73     .text:00000050 i2cStart
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:80     .text:00000050 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:129    .text:000000b0 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:135    .text:000000b4 i2cRepeatedStart
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:141    .text:000000b4 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:194    .text:00000120 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:200    .text:00000124 i2cPutByte
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:209    .text:00000124 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:233    .text:00000150 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:238    .text:00000154 i2cGetByte
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:247    .text:00000154 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:294    .text:000001b8 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:299    .text:000001bc i2cWriteBufferEx_o
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:307    .text:000001bc $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:429    .text:000002bc i2cReadBufferEx_o
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:553    .text:000003b4 i2cPoll
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:629    .text:00000454 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1804   .data:00000000 i2cTimeout
                            *COM*:00000004 i2cErrno
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:637    .text:00000460 i2cSetTimeout_o
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:646    .text:00000460 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:656    .text:0000046c $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:662    .text:00000470 i2cWriteBuffer_o
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:669    .text:00000470 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:688    .text:00000498 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:694    .text:0000049c i2cReadBuffer_o
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:701    .text:0000049c $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:720    .text:000004c4 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:726    .text:000004c8 i2cWriteReadBuffer_o
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:733    .text:000004c8 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:781    .text:0000052c $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:787    .text:00000530 i2cWriteBufferPoll
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:794    .text:00000530 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:820    .text:0000055c i2cWriteReadBufferPoll
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:854    .text:00000588 i2cWaitComplete
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:916    .text:00000600 $d
                            *COM*:00000004 i2cBusInUse
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:925    .text:00000610 i2cTransferBytes
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:932    .text:00000610 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1021   .text:000006d4 $d
                            *COM*:00000001 i2cAddress
                            *COM*:00000004 i2cDataLenWrite
                            *COM*:00000004 i2cDataLenRead
                            *COM*:00000004 i2cDataPtr
                            *COM*:00000004 i2cDataBuffer
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1035   .text:000006f8 i2cWriteBufferEx
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1042   .text:000006f8 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1074   .text:0000072c i2cReadBufferEx
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1115   .text:00000764 i2cWriteReadBufferEx
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1152   .text:00000794 i2cWriteBuffer
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1173   .text:000007a4 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1179   .text:000007a8 i2cReadBuffer
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1188   .text:000007a8 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1200   .text:000007b8 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1206   .text:000007bc i2cWriteReadBuffer
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1213   .text:000007bc $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1234   .text:000007e4 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1240   .text:000007e8 i2cSetTimeout
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1249   .text:000007e8 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1262   .text:000007fc $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1268   .text:00000800 eepromRdSBlk
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1277   .text:00000800 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1305   .text:00000828 eepromWrSBlk
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1346   .text:00000850 eepromRead
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1427   .text:000008f4 eepromWrite
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1505   .text:00000990 i2cISR
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1704   .text:00000b94 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1717   .text:00000bb4 i2cInit
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1724   .text:00000bb4 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1794   .text:00000c64 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccVjj304.s:1805   .data:00000000 $d

UNDEFINED SYMBOLS
miliSec
__divsi3
LogWr
delay
