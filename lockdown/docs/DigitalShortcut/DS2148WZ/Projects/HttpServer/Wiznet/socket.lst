   1              		.file	"socket.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	disconnect
  13              	disconnect:
  14              	.LFB5:
  15              		.file 1 "Wiznet/socket.c"
   1:Wiznet/socket.c **** /**
   2:Wiznet/socket.c ****  * \file    socket.c
   3:Wiznet/socket.c ****  *   Implemetation of WIZnet SOCKET API fucntions
   4:Wiznet/socket.c ****  *
   5:Wiznet/socket.c ****  * This file implements the WIZnet SOCKET API functions that is used in your internat application p
   6:Wiznet/socket.c ****  * 
   7:Wiznet/socket.c ****  * Revision History :
   8:Wiznet/socket.c ****  * ----------  -------  -----------  ----------------------------
   9:Wiznet/socket.c ****  * Date        Version  Author       Description
  10:Wiznet/socket.c ****  * ----------  -------  -----------  ----------------------------
  11:Wiznet/socket.c ****  * 24/03/2008  1.0.0    MidnigthCow  Release with W5300 launching
  12:Wiznet/socket.c ****  * ----------  -------  -----------  ----------------------------
  13:Wiznet/socket.c ****  */
  14:Wiznet/socket.c ****  
  15:Wiznet/socket.c ****  
  16:Wiznet/socket.c **** #include "socket.h"
  17:Wiznet/socket.c **** #include "string.h"
  18:Wiznet/socket.c **** #include "DigiShort/ds5300.h"
  19:Wiznet/socket.c **** 
  20:Wiznet/socket.c **** #define	IBUF_SIZE		1500
  21:Wiznet/socket.c **** 
  22:Wiznet/socket.c **** int printf(const char *format, ...);
  23:Wiznet/socket.c **** 
  24:Wiznet/socket.c **** extern	int W53ErFlg;
  25:Wiznet/socket.c **** 
  26:Wiznet/socket.c **** 
  27:Wiznet/socket.c **** /** 
  28:Wiznet/socket.c ****  * Variable for temporary source port number 
  29:Wiznet/socket.c ****  */
  30:Wiznet/socket.c **** uint16   iinchip_source_port;
  31:Wiznet/socket.c **** 
  32:Wiznet/socket.c **** uint8   socState[MAX_SOCK_NUM];
  33:Wiznet/socket.c **** int			ssrErr[MAX_SOCK_NUM];
  34:Wiznet/socket.c **** 
  35:Wiznet/socket.c **** uint8    socket(SOCKET s, uint8 protocol, uint16 port, uint16 flag)
  36:Wiznet/socket.c **** {
  37:Wiznet/socket.c ****   IINCHIP_WRITE(Sn_MR(s),(uint16)(protocol | flag)); // set Sn_MR with protocol & flag
  38:Wiznet/socket.c ****   
  39:Wiznet/socket.c ****   if (port != 0) IINCHIP_WRITE(Sn_PORTR(s),port);
  40:Wiznet/socket.c ****   else  {
  41:Wiznet/socket.c ****     iinchip_source_port++;     // if don't set the source port, set local_port number.
  42:Wiznet/socket.c ****     IINCHIP_WRITE(Sn_PORTR(s),iinchip_source_port);
  43:Wiznet/socket.c ****   }
  44:Wiznet/socket.c **** 	setSn_CR(s, Sn_CR_OPEN);      // open s-th SOCKET 
  45:Wiznet/socket.c ****    
  46:Wiznet/socket.c **** 	return 1;   
  47:Wiznet/socket.c **** }
  48:Wiznet/socket.c **** 
  49:Wiznet/socket.c **** void     close(SOCKET s)
  50:Wiznet/socket.c **** {
  51:Wiznet/socket.c **** 	
  52:Wiznet/socket.c **** 	// M_08082008 : It is fixed the problem that Sn_SSR cannot be changed a undefined value to the def
  53:Wiznet/socket.c **** 	//              Refer to Errata of W5300
  54:Wiznet/socket.c **** 	//Check if the transmit data is remained or not.
  55:Wiznet/socket.c **** 	if( ((getSn_MR(s)& 0x0F) == Sn_MR_TCP) && (getSn_TX_FSR(s) != getIINCHIP_TxMAX(s)) ) { 
  56:Wiznet/socket.c **** 		uint16 loop_cnt =0;
  57:Wiznet/socket.c **** 		#ifdef __DEF_IINCHIP_DBG__
  58:Wiznet/socket.c ****       printf("\n\rClose() Fix");
  59:Wiznet/socket.c **** 		#endif
  60:Wiznet/socket.c **** 		while(getSn_TX_FSR(s) != getIINCHIP_TxMAX(s)) {
  61:Wiznet/socket.c **** 			if(loop_cnt++ > 10) {
  62:Wiznet/socket.c **** 				uint8 destip[4];
  63:Wiznet/socket.c **** 				getSIPR(destip);
  64:Wiznet/socket.c **** 				socket(s,Sn_MR_UDP,0x3000,0);
  65:Wiznet/socket.c **** 				//sendto(s,(uint8*)"x",1,destip,0x3000); // send the dummy data to an unknown destination(0.0.0
  66:Wiznet/socket.c **** 			}
  67:Wiznet/socket.c **** 			wait_10ms(10);
  68:Wiznet/socket.c **** 		}
  69:Wiznet/socket.c **** 	}
  70:Wiznet/socket.c **** 	
  71:Wiznet/socket.c **** 	setSn_IR(s ,0x00FF);          // Clear the remained interrupt bits.
  72:Wiznet/socket.c **** 	setSn_CR(s ,Sn_CR_CLOSE);     // Close s-th SOCKET 
  73:Wiznet/socket.c ****  
  74:Wiznet/socket.c **** }
  75:Wiznet/socket.c **** 
  76:Wiznet/socket.c **** uint8    connect(SOCKET s, uint8 * addr, uint16 port)
  77:Wiznet/socket.c **** {
  78:Wiznet/socket.c ****   if  (
  79:Wiznet/socket.c ****       ((addr[0] == 0xFF) && (addr[1] == 0xFF) && (addr[2] == 0xFF) && (addr[3] == 0xFF)) ||
  80:Wiznet/socket.c ****       ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00)) ||
  81:Wiznet/socket.c ****       (port == 0x00) )
  82:Wiznet/socket.c ****   {
  83:Wiznet/socket.c ****       #ifdef __DEF_IINCHIP_DBG__
  84:Wiznet/socket.c ****          printf("\n\r%d : Fail[invalid ip,port]",s);
  85:Wiznet/socket.c ****       #endif
  86:Wiznet/socket.c ****       return 0;
  87:Wiznet/socket.c ****    }
  88:Wiznet/socket.c ****    
  89:Wiznet/socket.c ****    // set destination IP 
  90:Wiznet/socket.c ****    IINCHIP_WRITE(Sn_DIPR(s),((uint16)addr[0]<<8)+(uint16)addr[1]);
  91:Wiznet/socket.c ****    IINCHIP_WRITE(Sn_DIPR2(s),((uint16)addr[2]<<8)+(uint16)addr[3]);
  92:Wiznet/socket.c ****    // set destination port number
  93:Wiznet/socket.c ****    IINCHIP_WRITE(Sn_DPORTR(s),port);
  94:Wiznet/socket.c ****    
  95:Wiznet/socket.c ****    // Connect
  96:Wiznet/socket.c ****    setSn_CR(s,Sn_CR_CONNECT);
  97:Wiznet/socket.c **** 
  98:Wiznet/socket.c ****    return 1;   
  99:Wiznet/socket.c **** }
 100:Wiznet/socket.c **** 
 101:Wiznet/socket.c **** void     disconnect(SOCKET s)
 102:Wiznet/socket.c **** {
  16              		.loc 1 102 0
  17              		@ Function supports interworking.
  18              		@ args = 0, pretend = 0, frame = 0
  19              		@ frame_needed = 0, uses_anonymous_args = 0
  20              	.LVL0:
  21 0000 04E02DE5 		str	lr, [sp, #-4]!
  22              	.LCFI0:
  23              		.loc 1 102 0
  24 0004 FF0000E2 		and	r0, r0, #255
 103:Wiznet/socket.c **** 
 104:Wiznet/socket.c **** 	setSn_CR(s,Sn_CR_DISCON);     // Disconnect
  25              		.loc 1 104 0
  26 0008 0810A0E3 		mov	r1, #8
  27 000c FEFFFFEB 		bl	setSn_CR
  28              	.LVL1:
 105:Wiznet/socket.c **** }
  29              		.loc 1 105 0
  30 0010 04E09DE4 		ldr	lr, [sp], #4
  31 0014 1EFF2FE1 		bx	lr
  32              	.LFE5:
  34              		.section	.rodata.str1.4,"aMS",%progbits,1
  35              		.align	2
  36              	.LC0:
  37 0000 0A0D5061 		.ascii	"\012\015Pack_size too big %d\000"
  37      636B5F73 
  37      697A6520 
  37      746F6F20 
  37      62696720 
  38              		.text
  39              		.align	2
  40              		.global	recv
  42              	recv:
  43              	.LFB7:
 106:Wiznet/socket.c **** 
 107:Wiznet/socket.c **** uint8    listen(SOCKET s)
 108:Wiznet/socket.c **** {
 109:Wiznet/socket.c **** 
 110:Wiznet/socket.c ****   if (getSn_SSR(s) != SOCK_INIT)    {
 111:Wiznet/socket.c ****       #ifdef __DEF_IINCHIP_DBG__
 112:Wiznet/socket.c ****          printf("\n\r%d : SOCKET is not created!",s);
 113:Wiznet/socket.c ****       #endif
 114:Wiznet/socket.c ****       return 0;
 115:Wiznet/socket.c ****   }
 116:Wiznet/socket.c ****   
 117:Wiznet/socket.c **** 	setSn_CR(s,Sn_CR_LISTEN);     // listen
 118:Wiznet/socket.c ****    
 119:Wiznet/socket.c ****   return 1;
 120:Wiznet/socket.c **** }  
 121:Wiznet/socket.c **** 
 122:Wiznet/socket.c **** uint32   recv(SOCKET s, uint8 * buf, uint32 len)
 123:Wiznet/socket.c **** {
  44              		.loc 1 123 0
  45              		@ Function supports interworking.
  46              		@ args = 0, pretend = 0, frame = 4
  47              		@ frame_needed = 0, uses_anonymous_args = 0
  48              	.LVL2:
  49 0018 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
  50              	.LCFI1:
  51 001c FF5000E2 		and	r5, r0, #255
 124:Wiznet/socket.c ****   uint16 pack_size=0;
 125:Wiznet/socket.c ****   uint16 v1, tps;
 126:Wiznet/socket.c **** 
 127:Wiznet/socket.c ****   v1 = IINCHIP_READ(Sn_MR(s)); 
  52              		.loc 1 127 0
  53 0020 0503A0E1 		mov	r0, r5, asl #6
  54              	.LVL3:
  55              		.loc 1 123 0
  56 0024 04D04DE2 		sub	sp, sp, #4
  57              	.LCFI2:
  58              		.loc 1 124 0
  59 0028 0030A0E3 		mov	r3, #0	@ movhi
  60              		.loc 1 127 0
  61 002c 020C80E2 		add	r0, r0, #512
  62              		.loc 1 123 0
  63 0030 0170A0E1 		mov	r7, r1
  64 0034 0240A0E1 		mov	r4, r2
  65              		.loc 1 124 0
  66 0038 B230CDE1 		strh	r3, [sp, #2]	@ movhi
  67              	.LVL4:
  68              		.loc 1 127 0
  69 003c FEFFFFEB 		bl	IINCHIP_READ
  70              	.LVL5:
 128:Wiznet/socket.c **** 	if( v1 & Sn_MR_ALIGN ) {
  71              		.loc 1 128 0
  72 0040 010C10E3 		tst	r0, #256
 129:Wiznet/socket.c **** 		wiz_read_buf(s, buf, (uint32)len);
  73              		.loc 1 129 0
  74 0044 0710A0E1 		mov	r1, r7
  75 0048 0420A0E1 		mov	r2, r4
 130:Wiznet/socket.c **** 		setSn_CR(s,Sn_CR_RECV);
 131:Wiznet/socket.c **** 		return len;
 132:Wiznet/socket.c **** 	}
 133:Wiznet/socket.c ****    
 134:Wiznet/socket.c **** 	wiz_read_buf(s, (uint8*)&pack_size, 2);        // extract the PACKET-INFO(DATA packet length)
 135:Wiznet/socket.c **** 	pack_size = ((((pack_size << 8 ) & 0xFF00)) | ((pack_size >> 8)& 0x00FF));
 136:Wiznet/socket.c **** 	if ( pack_size>IBUF_SIZE ) {
  76              		.loc 1 136 0
  77 004c 84609FE5 		ldr	r6, .L13
  78              		.loc 1 129 0
  79 0050 0500A0E1 		mov	r0, r5
  80              		.loc 1 128 0
  81 0054 1700001A 		bne	.L12
  82              	.LVL6:
  83              		.loc 1 134 0
  84 0058 02108DE2 		add	r1, sp, #2
  85              	.LVL7:
  86 005c 0220A0E3 		mov	r2, #2
  87              	.LVL8:
  88 0060 0500A0E1 		mov	r0, r5
  89 0064 FEFFFFEB 		bl	wiz_read_buf
  90              		.loc 1 135 0
  91 0068 B220DDE1 		ldrh	r2, [sp, #2]
  92 006c 0234A0E1 		mov	r3, r2, asl #8
  93 0070 FF3C03E2 		and	r3, r3, #65280
  94 0074 223483E1 		orr	r3, r3, r2, lsr #8
  95              	.LVL9:
  96              		.loc 1 136 0
  97 0078 060053E1 		cmp	r3, r6
 137:Wiznet/socket.c **** 		printf("\n\rPack_size too big %d", pack_size);
  98              		.loc 1 137 0
  99 007c 58009FE5 		ldr	r0, .L13+4
 100 0080 0310A0E1 		mov	r1, r3
 101              		.loc 1 135 0
 102 0084 B230CDE1 		strh	r3, [sp, #2]	@ movhi
 103              		.loc 1 136 0
 104 0088 0300009A 		bls	.L7
 105              		.loc 1 137 0
 106 008c FEFFFFEB 		bl	printf
 107              	.LVL10:
 138:Wiznet/socket.c **** 		pack_size = IBUF_SIZE;
 108              		.loc 1 138 0
 109 0090 0630A0E1 		mov	r3, r6
 110              	.LVL11:
 111 0094 B260CDE1 		strh	r6, [sp, #2]	@ movhi
 112 0098 020000EA 		b	.L9
 113              	.LVL12:
 114              	.L7:
 139:Wiznet/socket.c **** 	}
 140:Wiznet/socket.c **** 	tps = pack_size; 											// ***JD tps keeps original packet size without adjustment to even	
 141:Wiznet/socket.c **** 		 
 142:Wiznet/socket.c **** 	if ( pack_size&0x01 ) pack_size++;
 115              		.loc 1 142 0
 116 009c 010013E3 		tst	r3, #1
 117 00a0 012083E2 		add	r2, r3, #1
 118 00a4 B220CD11 		strneh	r2, [sp, #2]	@ movhi
 119              	.L9:
 143:Wiznet/socket.c **** 	
 144:Wiznet/socket.c **** 	wiz_read_buf(s, buf, pack_size);     // copy data 
 120              		.loc 1 144 0
 121 00a8 B220DDE1 		ldrh	r2, [sp, #2]
 122 00ac 0710A0E1 		mov	r1, r7
 123 00b0 0500A0E1 		mov	r0, r5
 145:Wiznet/socket.c **** 	setSn_CR(s,Sn_CR_RECV);                      // recv
 146:Wiznet/socket.c **** 	
 147:Wiznet/socket.c **** 	return (uint32)tps;
 124              		.loc 1 147 0
 125 00b4 0340A0E1 		mov	r4, r3
 126              	.LVL13:
 127              	.L12:
 128              		.loc 1 144 0
 129 00b8 FEFFFFEB 		bl	wiz_read_buf
 130              	.LVL14:
 131              		.loc 1 145 0
 132 00bc 0500A0E1 		mov	r0, r5
 133 00c0 4010A0E3 		mov	r1, #64
 134 00c4 FEFFFFEB 		bl	setSn_CR
 148:Wiznet/socket.c **** }
 135              		.loc 1 148 0
 136 00c8 0400A0E1 		mov	r0, r4
 137 00cc 04D08DE2 		add	sp, sp, #4
 138 00d0 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 139 00d4 1EFF2FE1 		bx	lr
 140              	.L14:
 141              		.align	2
 142              	.L13:
 143 00d8 DC050000 		.word	1500
 144 00dc 00000000 		.word	.LC0
 145              	.LFE7:
 147              		.section	.rodata.str1.4
 148 0017 00       		.align	2
 149              	.LC1:
 150 0018 0A0D2564 		.ascii	"\012\015%d : SOCKET is not created!\000"
 150      203A2053 
 150      4F434B45 
 150      54206973 
 150      206E6F74 
 151              		.text
 152              		.align	2
 153              		.global	listen
 155              	listen:
 156              	.LFB6:
 157              		.loc 1 108 0
 158              		@ Function supports interworking.
 159              		@ args = 0, pretend = 0, frame = 0
 160              		@ frame_needed = 0, uses_anonymous_args = 0
 161              	.LVL15:
 162 00e0 10402DE9 		stmfd	sp!, {r4, lr}
 163              	.LCFI3:
 164              		.loc 1 108 0
 165 00e4 FF4000E2 		and	r4, r0, #255
 166              		.loc 1 110 0
 167 00e8 0400A0E1 		mov	r0, r4
 168              	.LVL16:
 169 00ec FEFFFFEB 		bl	getSn_SSR
 170 00f0 130050E3 		cmp	r0, #19
 171              		.loc 1 112 0
 172 00f4 0410A0E1 		mov	r1, r4
 173 00f8 24009FE5 		ldr	r0, .L20
 174              		.loc 1 110 0
 175 00fc 0200000A 		beq	.L16
 176              		.loc 1 112 0
 177 0100 FEFFFFEB 		bl	printf
 178 0104 0000A0E3 		mov	r0, #0
 179 0108 030000EA 		b	.L18
 180              	.L16:
 181              		.loc 1 117 0
 182 010c 0400A0E1 		mov	r0, r4
 183 0110 0210A0E3 		mov	r1, #2
 184 0114 FEFFFFEB 		bl	setSn_CR
 185 0118 0100A0E3 		mov	r0, #1
 186              	.L18:
 187              		.loc 1 120 0
 188 011c 1040BDE8 		ldmfd	sp!, {r4, lr}
 189 0120 1EFF2FE1 		bx	lr
 190              	.L21:
 191              		.align	2
 192              	.L20:
 193 0124 18000000 		.word	.LC1
 194              	.LFE6:
 196              		.section	.rodata.str1.4
 197 0036 0000     		.align	2
 198              	.LC2:
 199 0038 0A0D2564 		.ascii	"\012\015%d : Fail[invalid ip,port]\000"
 199      203A2046 
 199      61696C5B 
 199      696E7661 
 199      6C696420 
 200              		.text
 201              		.align	2
 202              		.global	connect
 204              	connect:
 205              	.LFB4:
 206              		.loc 1 77 0
 207              		@ Function supports interworking.
 208              		@ args = 0, pretend = 0, frame = 0
 209              		@ frame_needed = 0, uses_anonymous_args = 0
 210              	.LVL17:
 211 0128 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 212              	.LCFI4:
 213              		.loc 1 78 0
 214 012c 00C0D1E5 		ldrb	ip, [r1, #0]	@ zero_extendqisi2
 215              		.loc 1 77 0
 216 0130 0228A0E1 		mov	r2, r2, asl #16
 217              	.LVL18:
 218              		.loc 1 78 0
 219 0134 FF005CE3 		cmp	ip, #255
 220              		.loc 1 77 0
 221 0138 0150A0E1 		mov	r5, r1
 222 013c FF6000E2 		and	r6, r0, #255
 223 0140 2278A0E1 		mov	r7, r2, lsr #16
 224              	.LVL19:
 225              		.loc 1 78 0
 226 0144 0800001A 		bne	.L23
 227              	.LVL20:
 228 0148 0130D1E5 		ldrb	r3, [r1, #1]	@ zero_extendqisi2
 229 014c FF0053E3 		cmp	r3, #255
 230 0150 1000001A 		bne	.L25
 231              	.LVL21:
 232 0154 0230D1E5 		ldrb	r3, [r1, #2]	@ zero_extendqisi2
 233 0158 FF0053E3 		cmp	r3, #255
 234 015c 0D00001A 		bne	.L25
 235 0160 0330D1E5 		ldrb	r3, [r1, #3]	@ zero_extendqisi2
 236 0164 FF0053E3 		cmp	r3, #255
 237 0168 090000EA 		b	.L35
 238              	.LVL22:
 239              	.L23:
 240 016c 00005CE3 		cmp	ip, #0
 241 0170 0800001A 		bne	.L25
 242 0174 0130D1E5 		ldrb	r3, [r1, #1]	@ zero_extendqisi2
 243 0178 000053E3 		cmp	r3, #0
 244 017c 0500001A 		bne	.L25
 245              	.LVL23:
 246 0180 0230D1E5 		ldrb	r3, [r1, #2]	@ zero_extendqisi2
 247 0184 000053E3 		cmp	r3, #0
 248 0188 0200001A 		bne	.L25
 249 018c 0330D1E5 		ldrb	r3, [r1, #3]	@ zero_extendqisi2
 250 0190 000053E3 		cmp	r3, #0
 251              	.L35:
 252 0194 0100000A 		beq	.L28
 253              	.L25:
 254 0198 000057E3 		cmp	r7, #0
 255 019c 0400001A 		bne	.L32
 256              	.L28:
 257              		.loc 1 84 0
 258 01a0 0610A0E1 		mov	r1, r6
 259              	.LVL24:
 260 01a4 6C009FE5 		ldr	r0, .L36
 261 01a8 FEFFFFEB 		bl	printf
 262 01ac 0000A0E3 		mov	r0, #0
 263 01b0 160000EA 		b	.L33
 264              	.LVL25:
 265              	.L32:
 266              		.loc 1 90 0
 267 01b4 0110D5E5 		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 268              	.LVL26:
 269 01b8 0C1481E0 		add	r1, r1, ip, asl #8
 270 01bc 0643A0E1 		mov	r4, r6, asl #6
 271 01c0 0118A0E1 		mov	r1, r1, asl #16
 272 01c4 2118A0E1 		mov	r1, r1, lsr #16
 273 01c8 850F84E2 		add	r0, r4, #532
 274 01cc FEFFFFEB 		bl	IINCHIP_WRITE
 275              		.loc 1 91 0
 276 01d0 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 277 01d4 0310D5E5 		ldrb	r1, [r5, #3]	@ zero_extendqisi2
 278 01d8 031481E0 		add	r1, r1, r3, asl #8
 279 01dc 0118A0E1 		mov	r1, r1, asl #16
 280 01e0 850F84E2 		add	r0, r4, #532
 281 01e4 020080E2 		add	r0, r0, #2
 282 01e8 2118A0E1 		mov	r1, r1, lsr #16
 283 01ec FEFFFFEB 		bl	IINCHIP_WRITE
 284              		.loc 1 93 0
 285 01f0 210E84E2 		add	r0, r4, #528
 286 01f4 0710A0E1 		mov	r1, r7
 287 01f8 020080E2 		add	r0, r0, #2
 288 01fc FEFFFFEB 		bl	IINCHIP_WRITE
 289              		.loc 1 96 0
 290 0200 0600A0E1 		mov	r0, r6
 291 0204 0410A0E3 		mov	r1, #4
 292 0208 FEFFFFEB 		bl	setSn_CR
 293 020c 0100A0E3 		mov	r0, #1
 294              	.L33:
 295              		.loc 1 99 0
 296 0210 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 297 0214 1EFF2FE1 		bx	lr
 298              	.L37:
 299              		.align	2
 300              	.L36:
 301 0218 38000000 		.word	.LC2
 302              	.LFE4:
 304              		.align	2
 305              		.global	socket
 307              	socket:
 308              	.LFB2:
 309              		.loc 1 36 0
 310              		@ Function supports interworking.
 311              		@ args = 0, pretend = 0, frame = 0
 312              		@ frame_needed = 0, uses_anonymous_args = 0
 313              	.LVL27:
 314 021c FF1001E2 		and	r1, r1, #255
 315 0220 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 316              	.LCFI5:
 317              		.loc 1 37 0
 318 0224 013083E1 		orr	r3, r3, r1
 319              	.LVL28:
 320              		.loc 1 36 0
 321 0228 FF6000E2 		and	r6, r0, #255
 322 022c 0248A0E1 		mov	r4, r2, asl #16
 323              		.loc 1 37 0
 324 0230 0338A0E1 		mov	r3, r3, asl #16
 325 0234 0653A0E1 		mov	r5, r6, asl #6
 326 0238 020C85E2 		add	r0, r5, #512
 327              	.LVL29:
 328              		.loc 1 36 0
 329 023c 2448A0E1 		mov	r4, r4, lsr #16
 330              		.loc 1 37 0
 331 0240 2318A0E1 		mov	r1, r3, lsr #16
 332              	.LVL30:
 333 0244 825F85E2 		add	r5, r5, #520
 334 0248 FEFFFFEB 		bl	IINCHIP_WRITE
 335              	.LVL31:
 336 024c 025085E2 		add	r5, r5, #2
 337              		.loc 1 39 0
 338 0250 000054E3 		cmp	r4, #0
 339 0254 0410A0E1 		mov	r1, r4
 340              		.loc 1 41 0
 341 0258 3C209FE5 		ldr	r2, .L44
 342              		.loc 1 39 0
 343 025c 0500A0E1 		mov	r0, r5
 344 0260 0600001A 		bne	.L43
 345              	.LVL32:
 346              		.loc 1 41 0
 347 0264 B030D2E1 		ldrh	r3, [r2, #0]
 348 0268 013083E2 		add	r3, r3, #1
 349 026c 0338A0E1 		mov	r3, r3, asl #16
 350 0270 2338A0E1 		mov	r3, r3, lsr #16
 351 0274 B030C2E1 		strh	r3, [r2, #0]	@ movhi
 352              		.loc 1 42 0
 353 0278 0500A0E1 		mov	r0, r5
 354 027c 0310A0E1 		mov	r1, r3
 355              	.LVL33:
 356              	.L43:
 357 0280 FEFFFFEB 		bl	IINCHIP_WRITE
 358              		.loc 1 44 0
 359 0284 0600A0E1 		mov	r0, r6
 360 0288 0110A0E3 		mov	r1, #1
 361 028c FEFFFFEB 		bl	setSn_CR
 362              		.loc 1 47 0
 363 0290 0100A0E3 		mov	r0, #1
 364 0294 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 365 0298 1EFF2FE1 		bx	lr
 366              	.L45:
 367              		.align	2
 368              	.L44:
 369 029c 00000000 		.word	iinchip_source_port
 370              	.LFE2:
 372              		.section	.rodata.str1.4
 373 0055 000000   		.align	2
 374              	.LC3:
 375 0058 0A0D436C 		.ascii	"\012\015Close() Fix\000"
 375      6F736528 
 375      29204669 
 375      7800
 376 0066 0000     		.text
 377              		.align	2
 378              		.global	close
 380              	close:
 381              	.LFB3:
 382              		.loc 1 50 0
 383              		@ Function supports interworking.
 384              		@ args = 0, pretend = 0, frame = 4
 385              		@ frame_needed = 0, uses_anonymous_args = 0
 386              	.LVL34:
 387 02a0 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 388              	.LCFI6:
 389 02a4 FF5000E2 		and	r5, r0, #255
 390 02a8 04D04DE2 		sub	sp, sp, #4
 391              	.LCFI7:
 392              		.loc 1 55 0
 393 02ac 0500A0E1 		mov	r0, r5
 394              	.LVL35:
 395 02b0 FEFFFFEB 		bl	getSn_MR
 396 02b4 0F0000E2 		and	r0, r0, #15
 397 02b8 010050E3 		cmp	r0, #1
 398 02bc 1E00001A 		bne	.L47
 399 02c0 0500A0E1 		mov	r0, r5
 400 02c4 FEFFFFEB 		bl	getSn_TX_FSR
 401 02c8 0040A0E1 		mov	r4, r0
 402 02cc 0500A0E1 		mov	r0, r5
 403 02d0 FEFFFFEB 		bl	getIINCHIP_TxMAX
 404 02d4 000054E1 		cmp	r4, r0
 405 02d8 1700000A 		beq	.L47
 406              	.LBB2:
 407              		.loc 1 58 0
 408 02dc 7C009FE5 		ldr	r0, .L55
 409 02e0 FEFFFFEB 		bl	printf
 410 02e4 0060A0E3 		mov	r6, #0
 411 02e8 090000EA 		b	.L50
 412              	.L51:
 413              		.loc 1 61 0
 414 02ec 0A0853E3 		cmp	r3, #655360
 415 02f0 0500009A 		bls	.L52
 416              	.LBB3:
 417              		.loc 1 63 0
 418 02f4 FEFFFFEB 		bl	getSIPR
 419              		.loc 1 64 0
 420 02f8 0500A0E1 		mov	r0, r5
 421 02fc 0210A0E3 		mov	r1, #2
 422 0300 032AA0E3 		mov	r2, #12288
 423 0304 0030A0E3 		mov	r3, #0
 424 0308 FEFFFFEB 		bl	socket
 425              	.L52:
 426              	.LBE3:
 427              		.loc 1 67 0
 428 030c 0A00A0E3 		mov	r0, #10
 429 0310 FEFFFFEB 		bl	wait_10ms
 430              	.L50:
 431              		.loc 1 60 0
 432 0314 0500A0E1 		mov	r0, r5
 433 0318 FEFFFFEB 		bl	getSn_TX_FSR
 434 031c 0040A0E1 		mov	r4, r0
 435 0320 0500A0E1 		mov	r0, r5
 436 0324 FEFFFFEB 		bl	getIINCHIP_TxMAX
 437 0328 000054E1 		cmp	r4, r0
 438              		.loc 1 61 0
 439 032c 0638A0E1 		mov	r3, r6, asl #16
 440              	.LBB4:
 441              		.loc 1 63 0
 442 0330 0D00A0E1 		mov	r0, sp
 443              	.LBE4:
 444              		.loc 1 67 0
 445 0334 016086E2 		add	r6, r6, #1
 446              		.loc 1 60 0
 447 0338 EBFFFF1A 		bne	.L51
 448              	.L47:
 449              	.LBE2:
 450              		.loc 1 71 0
 451 033c 0500A0E1 		mov	r0, r5
 452 0340 FF10A0E3 		mov	r1, #255
 453 0344 FEFFFFEB 		bl	setSn_IR
 454              		.loc 1 72 0
 455 0348 0500A0E1 		mov	r0, r5
 456 034c 1010A0E3 		mov	r1, #16
 457 0350 FEFFFFEB 		bl	setSn_CR
 458              		.loc 1 74 0
 459 0354 04D08DE2 		add	sp, sp, #4
 460 0358 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 461 035c 1EFF2FE1 		bx	lr
 462              	.L56:
 463              		.align	2
 464              	.L55:
 465 0360 58000000 		.word	.LC3
 466              	.LFE3:
 468              		.comm	iinchip_source_port,2,2
 469              		.comm	socState,8,1
 470              		.comm	ssrErr,32,4
 610              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 socket.c
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:13     .text:00000000 disconnect
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:21     .text:00000000 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:42     .text:00000018 recv
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:143    .text:000000d8 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:155    .text:000000e0 listen
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:162    .text:000000e0 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:193    .text:00000124 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:204    .text:00000128 connect
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:211    .text:00000128 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:301    .text:00000218 $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:307    .text:0000021c socket
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:314    .text:0000021c $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:369    .text:0000029c $d
                            *COM*:00000002 iinchip_source_port
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:380    .text:000002a0 close
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:387    .text:000002a0 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccrxVj92.s:465    .text:00000360 $d
                            *COM*:00000008 socState
                            *COM*:00000020 ssrErr

UNDEFINED SYMBOLS
setSn_CR
IINCHIP_READ
wiz_read_buf
printf
getSn_SSR
IINCHIP_WRITE
getSn_MR
getSn_TX_FSR
getIINCHIP_TxMAX
getSIPR
wait_10ms
setSn_IR
