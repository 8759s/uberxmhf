   1              		.file	"sockutil.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	swaps
  13              	swaps:
  14              	.LFB2:
  15              		.file 1 "Wiznet/sockutil.c"
   1:Wiznet/sockutil.c **** /*
   2:Wiznet/sockutil.c **** *
   3:Wiznet/sockutil.c **** @file		sockutil.c
   4:Wiznet/sockutil.c **** @brief	Implementation of useful function of iinChip
   5:Wiznet/sockutil.c **** *
   6:Wiznet/sockutil.c **** */
   7:Wiznet/sockutil.c **** 
   8:Wiznet/sockutil.c **** 
   9:Wiznet/sockutil.c **** #include <stdio.h>
  10:Wiznet/sockutil.c **** #include <string.h>
  11:Wiznet/sockutil.c **** 
  12:Wiznet/sockutil.c **** #include "types.h"
  13:Wiznet/sockutil.c **** #include "sockutil.h"
  14:Wiznet/sockutil.c **** 
  15:Wiznet/sockutil.c **** uint16 swaps(u_int i);
  16:Wiznet/sockutil.c **** uint32 swapl(uint32 l);
  17:Wiznet/sockutil.c **** 
  18:Wiznet/sockutil.c **** uint16 swaps(u_int i)
  19:Wiznet/sockutil.c **** {
  16              		.loc 1 19 0
  17              		@ Function supports interworking.
  18              		@ args = 0, pretend = 0, frame = 0
  19              		@ frame_needed = 0, uses_anonymous_args = 0
  20              		@ link register save eliminated.
  21              	.LVL0:
  22 0000 0030A0E1 		mov	r3, r0
  20:Wiznet/sockutil.c **** 	u_short ret=0;
  21:Wiznet/sockutil.c **** 	ret = (i & 0xFF) << 8;
  23              		.loc 1 21 0
  24 0004 2004A0E1 		mov	r0, r0, lsr #8
  25              	.LVL1:
  26 0008 033CA0E1 		mov	r3, r3, asl #24
  27              	.LVL2:
  28 000c FF0000E2 		and	r0, r0, #255
  22:Wiznet/sockutil.c **** 	ret |= ((i >> 8)& 0xFF);
  23:Wiznet/sockutil.c **** 	return ret;	
  24:Wiznet/sockutil.c **** }
  29              		.loc 1 24 0
  30 0010 230880E1 		orr	r0, r0, r3, lsr #16
  31              		.loc 1 19 0
  32              		@ lr needed for prologue
  33              		.loc 1 24 0
  34 0014 1EFF2FE1 		bx	lr
  35              	.LFE2:
  37              		.align	2
  38              		.global	swapl
  40              	swapl:
  41              	.LFB3:
  25:Wiznet/sockutil.c **** 
  26:Wiznet/sockutil.c **** uint32 swapl(uint32 l)
  27:Wiznet/sockutil.c **** {
  42              		.loc 1 27 0
  43              		@ Function supports interworking.
  44              		@ args = 0, pretend = 0, frame = 0
  45              		@ frame_needed = 0, uses_anonymous_args = 0
  46              		@ link register save eliminated.
  47              	.LVL3:
  28:Wiznet/sockutil.c **** 	u_long ret=0;
  29:Wiznet/sockutil.c **** 	ret = (l & 0xFF) << 24;
  30:Wiznet/sockutil.c **** 	ret |= ((l >> 8) & 0xFF) << 16;
  48              		.loc 1 30 0
  49 0018 0034A0E1 		mov	r3, r0, asl #8
  50 001c FF3803E2 		and	r3, r3, #16711680
  51 0020 003C83E1 		orr	r3, r3, r0, asl #24
  52              	.LVL4:
  31:Wiznet/sockutil.c **** 	ret |= ((l >> 16) & 0xFF) << 8;
  53              		.loc 1 31 0
  54 0024 2024A0E1 		mov	r2, r0, lsr #8
  55 0028 203C83E1 		orr	r3, r3, r0, lsr #24
  56              	.LVL5:
  57 002c FF2C02E2 		and	r2, r2, #65280
  32:Wiznet/sockutil.c **** 	ret |= ((l >> 24) & 0xFF);
  33:Wiznet/sockutil.c **** 	return ret;
  34:Wiznet/sockutil.c **** }
  58              		.loc 1 34 0
  59 0030 030082E1 		orr	r0, r2, r3
  60              	.LVL6:
  61              		.loc 1 27 0
  62              		@ lr needed for prologue
  63              		.loc 1 34 0
  64 0034 1EFF2FE1 		bx	lr
  65              	.LFE3:
  67              		.align	2
  68              		.global	htons
  70              	htons:
  71              	.LFB5:
  35:Wiznet/sockutil.c **** 
  36:Wiznet/sockutil.c **** 
  37:Wiznet/sockutil.c **** /**
  38:Wiznet/sockutil.c **** @brief	Convert 32bit Address(Host Ordering) into Dotted Decimal Format
  39:Wiznet/sockutil.c **** @return 	a char pointer to a static buffer containing the text address in standard ".'' notation. O
  40:Wiznet/sockutil.c **** */  
  41:Wiznet/sockutil.c **** char* inet_ntoa(
  42:Wiznet/sockutil.c **** 	unsigned long addr	/**< Pointer variable to store converted value(INPUT) */
  43:Wiznet/sockutil.c **** 	)
  44:Wiznet/sockutil.c **** {
  45:Wiznet/sockutil.c **** 	static char addr_str[16];
  46:Wiznet/sockutil.c **** 	memset(addr_str,0,16);
  47:Wiznet/sockutil.c **** 	sprintf(addr_str,"%d.%d.%d.%d",(int)(addr>>24 & 0xFF),(int)(addr>>16 & 0xFF),(int)(addr>>8 & 0xFF)
  48:Wiznet/sockutil.c **** 	return addr_str;
  49:Wiznet/sockutil.c **** }
  50:Wiznet/sockutil.c **** 
  51:Wiznet/sockutil.c **** #if 0
  52:Wiznet/sockutil.c **** char* inet_ntoa_pad(unsigned long addr)
  53:Wiznet/sockutil.c **** {
  54:Wiznet/sockutil.c **** 	static char addr_str[16];
  55:Wiznet/sockutil.c **** 	memset(addr_str,0,16);
  56:Wiznet/sockutil.c **** 	sprintf(addr_str,"%03d.%03d.%03d.%03d",(int)(addr>>24 & 0xFF),(int)(addr>>16 & 0xFF),(int)(addr>>8
  57:Wiznet/sockutil.c **** 	return addr_str;
  58:Wiznet/sockutil.c **** }
  59:Wiznet/sockutil.c **** 
  60:Wiznet/sockutil.c **** /**
  61:Wiznet/sockutil.c **** @brief	Converts a string containing an (Ipv4) Internet Protocol decimal dotted address into a 32bit
  62:Wiznet/sockutil.c **** @return 	32bit address (Host Odering)
  63:Wiznet/sockutil.c **** */  
  64:Wiznet/sockutil.c **** uint32 inet_addr(
  65:Wiznet/sockutil.c **** 	unsigned char* addr	/**< dotted notation address string.  */
  66:Wiznet/sockutil.c **** 	)
  67:Wiznet/sockutil.c **** {
  68:Wiznet/sockutil.c **** 	char i;
  69:Wiznet/sockutil.c **** 	uint32 inetaddr = 0;
  70:Wiznet/sockutil.c **** 	char taddr[30];
  71:Wiznet/sockutil.c **** 	char * nexttok;
  72:Wiznet/sockutil.c **** 	int num;
  73:Wiznet/sockutil.c **** 	strcpy(taddr,addr);
  74:Wiznet/sockutil.c **** 	
  75:Wiznet/sockutil.c **** 	nexttok = taddr;
  76:Wiznet/sockutil.c **** 	for(i = 0; i < 4 ; i++)
  77:Wiznet/sockutil.c **** 	{
  78:Wiznet/sockutil.c **** 		nexttok = strtok(nexttok,".");
  79:Wiznet/sockutil.c **** 		if(nexttok[0] == '0' && nexttok[1] == 'x') num = ATOI(nexttok+2,0x10);
  80:Wiznet/sockutil.c **** 		else num = ATOI(nexttok,10);
  81:Wiznet/sockutil.c **** 		inetaddr = inetaddr << 8;		
  82:Wiznet/sockutil.c **** 		inetaddr |= (num & 0xFF);
  83:Wiznet/sockutil.c **** 		nexttok = NULL;
  84:Wiznet/sockutil.c **** 	}
  85:Wiznet/sockutil.c **** 	return inetaddr;	
  86:Wiznet/sockutil.c **** }	
  87:Wiznet/sockutil.c **** 
  88:Wiznet/sockutil.c **** 
  89:Wiznet/sockutil.c **** /**
  90:Wiznet/sockutil.c **** @brief	Verify dotted notation IP address string
  91:Wiznet/sockutil.c **** @return 	success - 1, fail - 0
  92:Wiznet/sockutil.c **** */ 
  93:Wiznet/sockutil.c **** char VerifyIPAddress(
  94:Wiznet/sockutil.c **** 	char* src	/**< pointer to IP address string */
  95:Wiznet/sockutil.c **** 	)
  96:Wiznet/sockutil.c **** {
  97:Wiznet/sockutil.c **** 	int i;
  98:Wiznet/sockutil.c **** 	int tnum;
  99:Wiznet/sockutil.c **** 	char tsrc[50];
 100:Wiznet/sockutil.c **** 	char* tok = tsrc;
 101:Wiznet/sockutil.c **** 	
 102:Wiznet/sockutil.c **** 	strcpy(tsrc,src);
 103:Wiznet/sockutil.c **** 	
 104:Wiznet/sockutil.c **** 	for(i = 0; i < 4; i++)
 105:Wiznet/sockutil.c **** 	{
 106:Wiznet/sockutil.c **** 		tok = strtok(tok,".");
 107:Wiznet/sockutil.c **** 		if ( !tok ) return 0;
 108:Wiznet/sockutil.c **** 		if(tok[0] == '0' && tok[1] == 'x')
 109:Wiznet/sockutil.c **** 		{
 110:Wiznet/sockutil.c **** 			if(!ValidATOI(tok+2,0x10,&tnum)) return 0;
 111:Wiznet/sockutil.c **** 		}
 112:Wiznet/sockutil.c **** 		else if(!ValidATOI(tok,10,&tnum)) return 0;
 113:Wiznet/sockutil.c **** 		
 114:Wiznet/sockutil.c **** 		if(tnum < 0 || tnum > 255) return 0;
 115:Wiznet/sockutil.c **** 		tok = NULL;
 116:Wiznet/sockutil.c **** 	}
 117:Wiznet/sockutil.c **** 	return 1;	
 118:Wiznet/sockutil.c **** }
 119:Wiznet/sockutil.c **** 
 120:Wiznet/sockutil.c **** 
 121:Wiznet/sockutil.c **** /**
 122:Wiznet/sockutil.c **** @brief	Output destination IP address of appropriate channel
 123:Wiznet/sockutil.c **** @return 	32bit destination address (Host Ordering)
 124:Wiznet/sockutil.c **** */ 
 125:Wiznet/sockutil.c **** uint32 GetDestAddr(
 126:Wiznet/sockutil.c **** 	SOCKET s	/**< Channel number which try to get destination IP Address */
 127:Wiznet/sockutil.c **** 	)
 128:Wiznet/sockutil.c **** {
 129:Wiznet/sockutil.c **** 	uint32 addr=0;
 130:Wiznet/sockutil.c **** 	int i = 0;
 131:Wiznet/sockutil.c **** 	for(i=0; i < 4; i++)
 132:Wiznet/sockutil.c **** 	{
 133:Wiznet/sockutil.c **** 		addr <<=8;
 134:Wiznet/sockutil.c **** 		addr += IINCHIP_READ(Sn_DIPR0(s)+i);
 135:Wiznet/sockutil.c **** 	}
 136:Wiznet/sockutil.c **** 	return addr;
 137:Wiznet/sockutil.c **** }
 138:Wiznet/sockutil.c **** 
 139:Wiznet/sockutil.c **** /**
 140:Wiznet/sockutil.c **** @brief	Output destination port number of appropriate channel
 141:Wiznet/sockutil.c **** @return 	16bit destination port number
 142:Wiznet/sockutil.c **** */ 
 143:Wiznet/sockutil.c **** unsigned int GetDestPort(
 144:Wiznet/sockutil.c **** 	SOCKET s	/**< Channel number which try to get destination port */
 145:Wiznet/sockutil.c **** 	)
 146:Wiznet/sockutil.c **** {
 147:Wiznet/sockutil.c **** 	u_int port;
 148:Wiznet/sockutil.c **** 	port = ((u_int) IINCHIP_READ(Sn_DPORT0(s))) & 0x00FF;
 149:Wiznet/sockutil.c **** 	port <<= 8;
 150:Wiznet/sockutil.c **** 	port += ((u_int) IINCHIP_READ(Sn_DPORT0(s)+1)) & 0x00FF;
 151:Wiznet/sockutil.c **** 	return port;
 152:Wiznet/sockutil.c **** }
 153:Wiznet/sockutil.c **** #endif
 154:Wiznet/sockutil.c **** 
 155:Wiznet/sockutil.c **** /**
 156:Wiznet/sockutil.c **** @brief	htons function converts a unsigned short from host to TCP/IP network byte order (which is bi
 157:Wiznet/sockutil.c **** @return 	the value in TCP/IP network byte order
 158:Wiznet/sockutil.c **** */ 
 159:Wiznet/sockutil.c **** uint16 htons( uint16 hostshort )	/**< A 16-bit number in host byte order.  */
 160:Wiznet/sockutil.c **** {
  72              		.loc 1 160 0
  73              		@ Function supports interworking.
  74              		@ args = 0, pretend = 0, frame = 0
  75              		@ frame_needed = 0, uses_anonymous_args = 0
  76              	.LVL7:
  77 0038 0008A0E1 		mov	r0, r0, asl #16
  78              	.LVL8:
  79 003c 04E02DE5 		str	lr, [sp, #-4]!
  80              	.LCFI0:
 161:Wiznet/sockutil.c **** 	return swaps(hostshort);
  81              		.loc 1 161 0
  82 0040 2008A0E1 		mov	r0, r0, lsr #16
  83              	.LVL9:
  84 0044 FEFFFFEB 		bl	swaps
  85              	.LVL10:
 162:Wiznet/sockutil.c **** }
  86              		.loc 1 162 0
  87 0048 04E09DE4 		ldr	lr, [sp], #4
  88 004c 1EFF2FE1 		bx	lr
  89              	.LFE5:
  91              		.align	2
  92              		.global	htonl
  94              	htonl:
  95              	.LFB6:
 163:Wiznet/sockutil.c **** 
 164:Wiznet/sockutil.c **** 
 165:Wiznet/sockutil.c **** /**
 166:Wiznet/sockutil.c **** @brief	htonl function converts a unsigned long from host to TCP/IP network byte order (which is big
 167:Wiznet/sockutil.c **** @return 	the value in TCP/IP network byte order
 168:Wiznet/sockutil.c **** */ 
 169:Wiznet/sockutil.c **** uint32 htonl( uint32 hostlong )		/**< hostshort  - A 32-bit number in host byte order.  */
 170:Wiznet/sockutil.c **** {
  96              		.loc 1 170 0
  97              		@ Function supports interworking.
  98              		@ args = 0, pretend = 0, frame = 0
  99              		@ frame_needed = 0, uses_anonymous_args = 0
 100              		@ link register save eliminated.
 101              	.LVL11:
 102              		@ lr needed for prologue
 171:Wiznet/sockutil.c **** 	return swapl(hostlong);
 172:Wiznet/sockutil.c **** }
 103              		.loc 1 172 0
 104              		.loc 1 171 0
 105 0050 FEFFFFEA 		b	swapl
 106              	.LVL12:
 107              	.LFE6:
 109              		.align	2
 110              		.global	ntohs
 112              	ntohs:
 113              	.LFB7:
 173:Wiznet/sockutil.c **** 
 174:Wiznet/sockutil.c **** 
 175:Wiznet/sockutil.c **** /**
 176:Wiznet/sockutil.c **** @brief	ntohs function converts a unsigned short from TCP/IP network byte order to host byte order (
 177:Wiznet/sockutil.c **** @return 	a 16-bit number in host byte order
 178:Wiznet/sockutil.c **** */ 
 179:Wiznet/sockutil.c **** unsigned long ntohs( 	unsigned short netshort )	/**< netshort - network odering 16bit value */
 180:Wiznet/sockutil.c **** {
 114              		.loc 1 180 0
 115              		@ Function supports interworking.
 116              		@ args = 0, pretend = 0, frame = 0
 117              		@ frame_needed = 0, uses_anonymous_args = 0
 118              	.LVL13:
 119 0054 0008A0E1 		mov	r0, r0, asl #16
 120              	.LVL14:
 121 0058 04E02DE5 		str	lr, [sp, #-4]!
 122              	.LCFI1:
 181:Wiznet/sockutil.c **** 	return htons(netshort);
 123              		.loc 1 181 0
 124 005c 2008A0E1 		mov	r0, r0, lsr #16
 125              	.LVL15:
 126 0060 FEFFFFEB 		bl	htons
 127              	.LVL16:
 182:Wiznet/sockutil.c **** }
 128              		.loc 1 182 0
 129 0064 04E09DE4 		ldr	lr, [sp], #4
 130 0068 1EFF2FE1 		bx	lr
 131              	.LFE7:
 133              		.align	2
 134              		.global	ntohl
 136              	ntohl:
 137              	.LFB8:
 183:Wiznet/sockutil.c **** 
 184:Wiznet/sockutil.c **** 
 185:Wiznet/sockutil.c **** /**
 186:Wiznet/sockutil.c **** @brief	converts a unsigned long from TCP/IP network byte order to host byte order (which is little-
 187:Wiznet/sockutil.c **** @return 	a 16-bit number in host byte order
 188:Wiznet/sockutil.c **** */ 
 189:Wiznet/sockutil.c **** unsigned long ntohl(unsigned long netlong)
 190:Wiznet/sockutil.c **** {
 138              		.loc 1 190 0
 139              		@ Function supports interworking.
 140              		@ args = 0, pretend = 0, frame = 0
 141              		@ frame_needed = 0, uses_anonymous_args = 0
 142              		@ link register save eliminated.
 143              	.LVL17:
 144              		@ lr needed for prologue
 191:Wiznet/sockutil.c **** 	return htonl(netlong);
 192:Wiznet/sockutil.c **** }
 145              		.loc 1 192 0
 146              		.loc 1 191 0
 147 006c FEFFFFEA 		b	htonl
 148              	.LVL18:
 149              	.LFE8:
 151              		.section	.rodata.str1.4,"aMS",%progbits,1
 152              		.align	2
 153              	.LC0:
 154 0000 25642E25 		.ascii	"%d.%d.%d.%d\000"
 154      642E2564 
 154      2E256400 
 155              		.text
 156              		.align	2
 157              		.global	inet_ntoa
 159              	inet_ntoa:
 160              	.LFB4:
 161              		.loc 1 44 0
 162              		@ Function supports interworking.
 163              		@ args = 0, pretend = 0, frame = 0
 164              		@ frame_needed = 0, uses_anonymous_args = 0
 165              	.LVL19:
 166 0070 30402DE9 		stmfd	sp!, {r4, r5, lr}
 167              	.LCFI2:
 168              		.loc 1 46 0
 169 0074 50509FE5 		ldr	r5, .L15
 170              		.loc 1 44 0
 171 0078 08D04DE2 		sub	sp, sp, #8
 172              	.LCFI3:
 173              		.loc 1 44 0
 174 007c 0040A0E1 		mov	r4, r0
 175              		.loc 1 46 0
 176 0080 0010A0E3 		mov	r1, #0
 177 0084 1020A0E3 		mov	r2, #16
 178 0088 0500A0E1 		mov	r0, r5
 179              	.LVL20:
 180 008c FEFFFFEB 		bl	memset
 181              		.loc 1 47 0
 182 0090 2438A0E1 		mov	r3, r4, lsr #16
 183 0094 24C4A0E1 		mov	ip, r4, lsr #8
 184 0098 FFC00CE2 		and	ip, ip, #255
 185 009c 242CA0E1 		mov	r2, r4, lsr #24
 186 00a0 FF3003E2 		and	r3, r3, #255
 187 00a4 FF4004E2 		and	r4, r4, #255
 188              	.LVL21:
 189 00a8 0500A0E1 		mov	r0, r5
 190 00ac 1C109FE5 		ldr	r1, .L15+4
 191 00b0 00C08DE5 		str	ip, [sp, #0]
 192 00b4 04408DE5 		str	r4, [sp, #4]
 193 00b8 FEFFFFEB 		bl	sprintf
 194              		.loc 1 49 0
 195 00bc 0500A0E1 		mov	r0, r5
 196 00c0 08D08DE2 		add	sp, sp, #8
 197 00c4 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 198 00c8 1EFF2FE1 		bx	lr
 199              	.L16:
 200              		.align	2
 201              	.L15:
 202 00cc 00000000 		.word	addr_str.2119
 203 00d0 00000000 		.word	.LC0
 204              	.LFE4:
 206              		.bss
 207              	addr_str.2119:
 208 0000 00000000 		.space	16
 208      00000000 
 208      00000000 
 208      00000000 
 309              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 sockutil.c
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:13     .text:00000000 swaps
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:22     .text:00000000 $a
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:40     .text:00000018 swapl
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:70     .text:00000038 htons
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:94     .text:00000050 htonl
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:112    .text:00000054 ntohs
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:136    .text:0000006c ntohl
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:159    .text:00000070 inet_ntoa
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:202    .text:000000cc $d
/cygdrive/c/DOCUME~1/AMITVA~1/LOCALS~1/Temp/ccSO7ryw.s:207    .bss:00000000 addr_str.2119

UNDEFINED SYMBOLS
memset
sprintf
