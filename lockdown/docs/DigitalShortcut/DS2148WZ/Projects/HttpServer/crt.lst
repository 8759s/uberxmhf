   1              	# 1 "crt.S"
   2              	# 1 "<built-in>"
   1              	@
   0              	
   0              	
   2              	@  $Id: boot.s 43 2008-10-04 18:42:08Z jcw $
   3              	@  $Revision: 43 $
   4              	@  $Author: jcw $
   5              	@  $Date: 2008-10-04 14:42:08 -0400 (Sat, 04 Oct 2008) $
   6              	@  $HeadURL: http://tinymicros.com/svn_public/arm/lpc2148_demo/trunk/boot.s $
   7              	@
   8              	
   9              	@
  10              	@  Sample initialization file 
  11              	@
  12              	        .extern main
  13              	        .extern exit
  14              	
  15              	        .text
  16              	        .code 32
  17              	
  18              	        .align  0
  19              	
  20              	        .extern __bss_beg__
  21              	        .extern __bss_end__
  22              	        .extern __stack_end__
  23              	        .extern __data_beg__
  24              	        .extern __data_beg_src__   
  25              	        .extern __intvects_beg__     
  26              	        .extern __intvects_beg_src__
  27              	        .extern __intvects_end__   
  28              	        .extern __data_end__
  29              	        .extern __data+beg_src__
  30              	
  31              	        .global start
  32              	        .global endless_loop
  33              	
  34              	@ 
  35              	@  Stack sizes.  These have been determined empirically.  If your interrupt
  36              	@  routines become more complex or use a lot of dynamically allocated space,
  37              	@  the IRQ and/or FIQ stacks may been be grown.  The supervisor stack may 
  38              	@  overflow into the system/user stack as the system is going any initialization,
  39              	@  before starting the FreeRTOS scheduler.  The scheduler itself needs a small
  40              	@  amount of supervisor stack space, once it's running.
  41              	@
  42              	        .set  UND_STACK_SIZE, 0x00000004
  43              	        .set  ABT_STACK_SIZE, 0x00000004
  44              	        .set  FIQ_STACK_SIZE, 0x00000020
  45              	        .set  IRQ_STACK_SIZE, 0X00000100
  46              	        .set  SVC_STACK_SIZE, 0x00000100
  47              	
  48              	@
  49              	@  Standard definitions of Mode bits and Interrupt (I & F) flags in PSRs 
  50              	@
  51              	        .set  MODE_USR, 0x10            @ User Mode 
  52              	        .set  MODE_FIQ, 0x11            @ FIQ Mode 
  53              	        .set  MODE_IRQ, 0x12            @ IRQ Mode 
  54              	        .set  MODE_SVC, 0x13            @ Supervisor Mode 
  55              	        .set  MODE_ABT, 0x17            @ Abort Mode 
  56              	        .set  MODE_UND, 0x1B            @ Undefined Mode 
  57              	        .set  MODE_SYS, 0x1F            @ System Mode 
  58              	
  59              	        .equ  I_BIT, 0x80               @ when I bit is set, IRQ is disabled 
  60              	        .equ  F_BIT, 0x40               @ when F bit is set, FIQ is disabled 
  61              	        .equ  T_BIT, 0x20               @ when T bit is set, THUMB mode is active
  62              	
  63              	start:
  64              	__start:
  65              	_mainCRTStartup:
  66              	@
  67              	@  Clear all of memory to 0xe5e5e5e5.  We use this value later to determine
  68              	@  stack highwater usage.
  69              	@
  70 0000 10119FE5 	        ldr     r1, =__data_beg__       @ __data_beg__ is start of RAM 
  71 0004 10319FE5 	        ldr     r3, =__stack_end__      @ __stack_end__ is end of RAM
  72 0008 013043E0 	        sub     r3, r3, r1              @ Length of RAM to set
  73 000c 0C219FE5 	        ldr     r2, =0xe5e5e5e5         @ Fill value
  74              	
  75              	.init_loop:
  76 0010 042081E4 	        str     r2, [r1], #4            @ Store fill value, r1 += 4
  77 0014 043053E2 	        subs    r3, r3, #4              @ Length -= 4
  78 0018 FCFFFFCA 	        bgt     .init_loop              @ >= 0, go again
  79              	
  80              	.end_init_loop:
  81              	
  82              	@
  83              	@  Clear BSS. 
  84              	@
  85 001c 00119FE5 	        ldr     r1, =__bss_beg__        @ Start of memory block 
  86 0020 00319FE5 	        ldr     r3, =__bss_end__        @ End of memory block 
  87 0024 013053E0 	        subs    r3, r3, r1              @ Calculate length of block 
  88 0028 0300000A 	        beq     .end_clear_loop         @ If 0, nothing to do
  89 002c 0020A0E3 	        mov     r2, #0                  @ Fill value
  90              	
  91              	.clear_loop:
  92 0030 0120C1E4 	        strb    r2, [r1], #1            @ Store byte, r1++
  93 0034 013053E2 	        subs    r3, r3, #1              @ Decrement counter
  94 0038 FCFFFFCA 	        bgt     .clear_loop             @ >= 0, go again
  95              	
  96              	.end_clear_loop:
  97              	
  98              	@
  99              	@  Initialize data.
 100              	@
 101 003c D4109FE5 	        ldr     r1, =__data_beg__       @ Destination (.data in RAM)
 102 0040 E4209FE5 	        ldr     r2, =__data_beg_src__   @ Source (.data in FLASH)
 103 0044 E4309FE5 	        ldr     r3, =__data_end__       @ End of .data in RAM
 104 0048 013053E0 	        subs    r3, r3, r1              @ Calculate length of block 
 105 004c 0300000A 	        beq     .end_set_loop           @ If 0, nothing to do
 106              	
 107              	.set_loop:
 108 0050 0140D2E4 	        ldrb    r4, [r2], #1            @ Get byte from source, r2++
 109 0054 0140C1E4 	        strb    r4, [r1], #1            @ Store byte to destination, r1++
 110 0058 013053E2 	        subs    r3, r3, #1              @ Decrement loop counter
 111 005c FBFFFFCA 	        bgt     .set_loop               @ >= 0, go again
 112              	
 113              	.end_set_loop:
 114              	
 115              	@
 116              	@  Copy interrupt vectors
 117              	@
 118 0060 CC109FE5 	        ldr     r1, =__intvects_beg__     @ Destination (.intvects in RAM)
 119 0064 CC209FE5 	        ldr     r2, =__intvects_beg_src__ @ Source (.intvects in FLASH)
 120 0068 CC309FE5 	        ldr     r3, =__intvects_end__     @ End of .intvects in RAM
 121 006c 013053E0 	        subs    r3, r3, r1                @ Calculate length of block 
 122 0070 0300000A 	        beq     .end_ints_loop            @ If 0, nothing to do
 123              	
 124              	.ints_loop:
 125 0074 0140D2E4 	        ldrb    r4, [r2], #1            @ Get byte from source, r2++
 126 0078 0140C1E4 	        strb    r4, [r1], #1            @ Store byte to destination, r1++
 127 007c 013053E2 	        subs    r3, r3, #1              @ Decrement loop counter
 128 0080 FBFFFFCA 	        bgt     .ints_loop              @ >= 0, go again
 129              	
 130              	.end_ints_loop:
 131              	
 132              	@
 133              	@  Setup a stack for each mode - note that this only sets up a usable stack
 134              	@  for system/user, SWI and IRQ modes.   Also each mode is setup with
 135              	@  interrupts initially disabled. 
 136              	@
 137 0084 B4109FE5 	        ldr   r1, =__stack_beg_und          @ Pointer to various values we update
 138 0088 8C009FE5 	        ldr   r0, =__stack_end__            @ Get top of stack space
 139 008c DBF021E3 	        msr   CPSR_c, #MODE_UND|I_BIT|F_BIT @ Undefined Instruction Mode
 140 0090 00D0A0E1 	        mov   sp, r0                        @ Set undef mode SP
 141 0094 000081E5 	        str   r0, [r1, #0]                  @ Store this so 'mem map' knows
 142              	
 143 0098 040040E2 	        sub   r0, r0, #UND_STACK_SIZE       @ Subtract undef stack size for abort stack start
 144 009c D7F021E3 	        msr   CPSR_c, #MODE_ABT|I_BIT|F_BIT @ Abort Mode 
 145 00a0 00D0A0E1 	        mov   sp, r0                        @ Set abort mode SP
 146 00a4 040081E5 	        str   r0, [r1, #4]                  @ Store this so 'mem map' knows
 147 00a8 080081E5 	        str   r0, [r1, #8]                  @ Store this so 'mem map' knows
 148              	
 149 00ac 040040E2 	        sub   r0, r0, #ABT_STACK_SIZE       @ Subtract abort stack size for FIQ stack start
 150 00b0 D1F021E3 	        msr   CPSR_c, #MODE_FIQ|I_BIT|F_BIT @ FIQ Mode 
 151 00b4 00D0A0E1 	        mov   sp, r0                        @ Set FIQ mode SP
 152 00b8 0C0081E5 	        str   r0, [r1, #12]                 @ Store this so 'mem map' knows
 153 00bc 100081E5 	        str   r0, [r1, #16]                 @ Store this so 'mem map' knows
 154              	
 155 00c0 200040E2 	        sub   r0, r0, #FIQ_STACK_SIZE       @ Subtract FIQ stack size for IRQ stack start
 156 00c4 D2F021E3 	        msr   CPSR_c, #MODE_IRQ|I_BIT|F_BIT @ IRQ Mode 
 157 00c8 00D0A0E1 	        mov   sp, r0                        @ Set IRQ mode SP
 158 00cc 140081E5 	        str   r0, [r1, #20]                 @ Store this so 'mem map' knows
 159 00d0 180081E5 	        str   r0, [r1, #24]                 @ Store this so 'mem map' knows
 160              	
 161 00d4 010C40E2 	        sub   r0, r0, #IRQ_STACK_SIZE       @ Subtract IRQ stack size for SVC stack start
 162 00d8 D3F021E3 	        msr   CPSR_c, #MODE_SVC|I_BIT|F_BIT @ Supervisor Mode 
 163 00dc 00D0A0E1 	        mov   sp, r0                        @ Set supervisor mode SP
 164 00e0 1C0081E5 	        str   r0, [r1, #28]                 @ Store this so 'mem map' knows
 165 00e4 200081E5 	        str   r0, [r1, #32]                 @ Store this so 'mem map' knows
 166 00e8 012C40E2 	        sub   r2, r0, #256                  @ MAGIC! FreeRTOS only uses a few bytes of supervisor s
 167 00ec 302081E5 	        str   r2, [r1, #48]                 @ ...so tell _sbrk() where heap ends when FreeRTOS runn
 168              	
 169 00f0 010C40E2 	        sub   r0, r0, #SVC_STACK_SIZE       @ Subtract supervisor stack size for system/user stack 
 170 00f4 DFF021E3 	        msr   CPSR_c, #MODE_SYS|I_BIT|F_BIT @ System Mode 
 171 00f8 00D0A0E1 	        mov   sp, r0                        @ Set system/user mode SP
 172 00fc 240081E5 	        str   r0, [r1, #36]                 @ Store this so 'mem map' knows
 173 0100 280081E5 	        str   r0, [r1, #40]                 @ Store this so 'mem map' knows
 174              	
 175              	@
 176              	@  We want to start in supervisor mode (probably always, but FreeRTOS demands it)
 177              	@
 178 0104 D3F021E3 	        msr   CPSR_c, #MODE_SVC|I_BIT|F_BIT
 179              	
 180              	@
 181              	@  Set argc & argv, initialize newlib, and jump to main
 182              	@
 183 0108 0000A0E3 	        mov     r0, #0                  @ No arguments  
 184 010c 0010A0E3 	        mov     r1, #0                  @ No argv either 
 185              	
 186 0110 FEFFFFEB 	        bl      main                    @ And call good ol' main()
 187 0114 FEFFFFEA 	        b       .                       @ In case main() ever returns
 188              	
 189              	@
 190              	@  Setup vector table.  
 191              	@
 192              	        .section .startup,"ax"
 193              	        .code 32
 194              	        .align 0
 195              	
 196 0000 18F09FE5 	        ldr     pc, _start              @ reset - _start               
 197 0004 18F09FE5 	        ldr     pc, _undf               @ undefined - _undf            
 198 0008 18F09FE5 	        ldr     pc, _swi                @ SWI - _swi                   
 199 000c 18F09FE5 	        ldr     pc, _pabt               @ program abort - _pabt        
 200 0010 18F09FE5 	        ldr     pc, _dabt               @ data abort - _dabt           
 201 0014 04F09FE5 	        ldr     pc, _start              @ reserved - reset
 202 0018 F0FF1FE5 	        ldr     pc, [pc, #-0xff0]       @ IRQ - read VIC_VectAddr (magic!  It's at 0xfffff030)
 203 001c 10F09FE5 	        ldr     pc, _fiq                @ FIQ - _fiq                   
 204              	
 205 0020 00000000 	_start: .word   __start                 @ reset
 206 0024 38000000 	_undf:  .word   __undf                  @ undefined                    
 207 0028 00000000 	_swi:   .word   SWI_Routine             @ SWI
 208 002c 4C000000 	_pabt:  .word   __pabt                  @ program abort                
 209 0030 60000000 	_dabt:  .word   __dabt                  @ data abort                   
 210 0034 00000000 	_fiq:   .word   FIQ_Routine             @ FIQ                          
 211              	
 212              	@
 213              	@  Handlers for undef, program abort and data abort.  They all update
 214              	@  their respective registers, then reset the system by timing out
 215              	@  the watchdog (only apparent way to force a hardware reset)
 216              	@
 217              	__undf: 
 218 0038 00D19FE5 	        ldr     sp, =(__abort_mem+5*4)  @ Set sp_abt to data array with offset (restore later)
 219 003c FF1F8DE8 	        stmia   sp, {r0-r12}            @ Save first dataset in r0-r12 to array
 220 0040 04004EE2 	        sub     r0, lr, #4              @ Calculate PC value of undef instruction
 221 0044 0010A0E3 	        mov     r1, #0                  @ Abort type
 222 0048 090000EA 	        b       .abtstore               @ Save info, reset system
 223              	
 224              	__pabt: 
 225 004c ECD09FE5 	        ldr     sp, =(__abort_mem+5*4)  @ Set sp_abt to data array with offset (restore later)
 226 0050 FF1F8DE8 	        stmia   sp, {r0-r12}            @ Save first dataset in r0-r12 to array
 227 0054 04004EE2 	        sub     r0, lr, #4              @ Calculate PC value of undef instruction
 228 0058 0110A0E3 	        mov     r1, #1                  @ Abort type
 229 005c 040000EA 	        b       .abtstore               @ Save info, reset system
 230              	
 231              	__dabt: 
 232 0060 D8D09FE5 	        ldr     sp, =(__abort_mem+5*4)  @ Set sp_abt to data array with offset (restore later)
 233 0064 FF1F8DE8 	        stmia   sp, {r0-r12}            @ Save first dataset in r0-r12 to array
 234 0068 08004EE2 	        sub     r0, lr, #8              @ Calculate PC value of undef instruction
 235 006c 0210A0E3 	        mov     r1, #2                  @ Abort type
 236 0070 FFFFFFEA 	        b       .abtstore               @ Save info, reset system
 237              	
 238              	@
 239              	@  Store the abort type.  Then see if the sigil value is set, and if not,
 240              	@  reset the abort counter to 0.
 241              	@
 242              	.abtstore:
 243 0074 C8209FE5 	        ldr     r2, =__abort_typ        @ Abort type
 244 0078 001082E5 	        str     r1, [r2]                @ Store it
 245              	
 246 007c C4209FE5 	        ldr     r2, =__abort_sig        @ Get the sigil address
 247 0080 C4409FE5 	        ldr     r4, =ABORT_SIGIL        @ Load sigil value
 248 0084 003092E5 	        ldr     r3, [r2]                @ Get sigil contents
 249 0088 040053E1 	        cmp     r3, r4                  @ Sigil set?
 250              	
 251 008c 00408215 	        strne   r4, [r2]                @ No, store sigil value
 252 0090 B8209F15 	        ldrne   r2, =__abort_cnt        @ No, load address of abort counter
 253 0094 0040A013 	        movne   r4, #0                  @ No, Zero for store
 254 0098 00408215 	        strne   r4, [r2]                @ No, Clear counter
 255              	
 256              	@
 257              	@  Now build up structure of registers and stack (r0 = abort address, r1 = 
 258              	@  abort type).  This code is based heavily on the work of Roger Lynx, from 
 259              	@  http://www.embedded.com/shared/printableArticle.jhtml?articleID=192202641
 260              	@
 261 009c 00500FE1 	        mrs     r5, cpsr                @ Save current mode to R5 for mode switching
 262 00a0 00604FE1 	        mrs     r6, spsr                @ spsr_abt = CPSR of dabt originating mode, save to r6 for 
 263 00a4 0620A0E1 	        mov     r2, r6                  @ Building second dataset: r2 = CPSR of exception
 264 00a8 0F0016E3 	        tst     r6, #0x0f               @ Test mode of the raised exception
 265 00ac 0F608603 	        orreq   r6, r6, #0x0f           @ If 0, elevate from user mode to system mode
 266 00b0 06F021E1 	        msr     cpsr_c, r6              @ Switch out from mode 0x17 (abort) to ...
 267 00b4 0E30A0E1 	        mov     r3, lr                  @ ... dabt generating mode and state
 268 00b8 0D40A0E1 	        mov     r4, sp                  @ ... Get lr (=r3) and sp (=r4)
 269 00bc 05F021E1 	        msr     cpsr_c, r5              @ Switch back to mode 0x17 (abort)
 270 00c0 010051E3 	        cmp     r1, #1                  @ Test for prefetch abort
 271 00c4 0010A003 	        moveq   r1, #0                  @ Can't fetch instruction at the abort address
 272 00c8 00109015 	        ldrne   r1, [r0]                @ r1 = [pc] (dabt)
 273 00cc 80D09FE5 	        ldr     sp, =__abort_mem        @ Reset sp to arrays starting address
 274 00d0 1F008DE8 	        stmia   sp, {r0-r4}             @ Save second dataset from r0 to r4
 275              	
 276 00d4 7C109FE5 	        ldr     r1, =__abort_stk        @ Space where we'll store abort stack
 277 00d8 0820A0E3 	        mov     r2,#8                   @ Copy 8 stack entries
 278              	.abtcopy:
 279 00dc 040094E4 	        ldr     r0, [r4], #4            @ Get byte from source, r4 += 4
 280 00e0 040081E4 	        str     r0, [r1], #4            @ Store byte to destination, r1 += 4
 281 00e4 012052E2 	        subs    r2, r2, #1              @ Decrement loop counter
 282 00e8 FBFFFFCA 	        bgt     .abtcopy                @ >= 0, go again
 283              	
 284 00ec FFFFFFEA 	        b       .sysreset               @ And reset
 285              	
 286              	@
 287              	@  Force a system reset with ye olde watch dogge
 288              	@
 289              	        .set    SCB_RSIR_MASK, 0x0000000f
 290              	        .set    SCB_RSIR,      0xe01fc180
 291              	        .set    WD_MOD,        0xe0000000
 292              	        .set    WD_TC,         0xe0000004
 293              	        .set    WD_FEED,       0xe0000008
 294              	        .set    WD_MOD_WDEN,   0x00000001
 295              	        .set    WD_MOD_RESET,  0x00000002
 296              	        .set    WD_MOD_TOF,    0x00000004
 297              	        .set    WD_MOD_INT,    0x00000008
 298              	        .set    WD_MOD_MASK,   0x0000000f
 299              	        .set    WD_FEED_FEED1, 0x000000aa
 300              	        .set    WD_FEED_FEED2, 0x00000055
 301              	        .set    ABORT_SIGIL,   0xdeadc0de
 302              	
 303              	.sysreset:
 304 00f0 58109FE5 	        ldr     r1, =__abort_cnt        @ Get the abort counter address
 305 00f4 000091E5 	        ldr     r0, [r1]                @ Load it
 306 00f8 010080E2 	        add     r0, r0, #1              @ Add 1
 307 00fc 000081E5 	        str     r0, [r1]                @ Store it back
 308              	
 309              	@
 310              	@  Now enable the watch dog, and go into a loop waiting for a timeout
 311              	@
 312 0100 0F00A0E3 	        ldr     r0, =SCB_RSIR_MASK
 313 0104 50109FE5 	        ldr     r1, =SCB_RSIR
 314 0108 000081E5 	        str     r0, [r1]
 315 010c 0300A0E3 	        ldr     r0, =WD_MOD_WDEN | WD_MOD_RESET
 316 0110 0E12A0E3 	        ldr     r1, =WD_MOD
 317 0114 000081E5 	        str     r0, [r1]
 318 0118 40009FE5 	        ldr     r0, =120000
 319 011c 4E12A0E3 	        ldr     r1, =WD_TC
 320 0120 000081E5 	        str     r0, [r1]
 321 0124 AA00A0E3 	        ldr     r0, =WD_FEED_FEED1
 322 0128 8E12A0E3 	        ldr     r1, =WD_FEED
 323 012c 000081E5 	        str     r0, [r1]
 324 0130 5500A0E3 	        ldr     r0, =WD_FEED_FEED2
 325 0134 8E12A0E3 	        ldr     r1, =WD_FEED
 326 0138 000081E5 	        str     r0, [r1]
 327 013c FEFFFFEA 	        b       .
 328              	
 329              	@
 330              	@  Reserve space for interrupt vectors in RAM, in case we decode to be tricky
 331              	@
 332              	        .global __intvects
 333              	        .section .intvects,"ax"
 334              	        .align  0
 335              	
 336 0000 18F09FE5 	__intvects:   ldr     pc, _ram_reset          @ reset
 337 0004 18F09FE5 	              ldr     pc, _ram_undf           @ undefined
 338 0008 18F09FE5 	              ldr     pc, _ram_swi            @ SWI
 339 000c 18F09FE5 	              ldr     pc, _ram_pabt           @ program abort
 340 0010 18F09FE5 	              ldr     pc, _ram_dabt           @ data abort
 341 0014 18F09FE5 	              ldr     pc, _ram_rsrvd          @ reserved
 342 0018 F0FF1FE5 	              ldr     pc, [pc, #-0xff0]       @ IRQ - read VIC_VectAddr (magic!  It's at 0xfffff030
 343 001c 18F09FE5 	              ldr     pc, _ram_fiq            @ FIQ
 344              	
 345 0020 00000000 	_ram_reset:   .word   __start                 @ reset
 346 0024 38000000 	_ram_undf:    .word   __undf                  @ undefined                    
 347 0028 00000000 	_ram_swi:     .word   SWI_Routine             @ SWI
 348 002c 4C000000 	_ram_pabt:    .word   __pabt                  @ program abort                
 349 0030 60000000 	_ram_dabt:    .word   __dabt                  @ data abort                   
 350 0034 00000000 	_ram_rsrvd:   .word   __start                 @ reserved
 351 0038 00000000 	_ram_irq:     .word   0                       @ (not used, just reserved space)
 352 003c 00000000 	_ram_fiq:     .word   FIQ_Routine             @ FIQ                          
 353              	
 354              	@
 355              	@  These are in the .protected space in RAM to make sure that initialization 
 356              	@  code doesn't overwrite them.  When a data abort or an undefined instruction
 357              	@  exception occurs, the handlers update the respective locations below.  ORDER
 358              	@  IS IMPORTANT, THESE ARE MAPPED INTO THE C STRUCTURE abortDat_t in monitor.c
 359              	@
 360              	        .global __abort_dat
 361              	        .section .protected
 362              	        .align  0
 363              	
 364 0000 00000000 	__abort_dat:  .word 0                   @ Dummy, not used
 365 0004 00000000 	__abort_sig:  .word 0                   @ Sigil to indicate data validity
 366 0008 00000000 	__abort_cnt:  .word 0                   @ Number of times we've aborted
 367 000c 00000000 	__abort_typ:  .word 0                   @ Type of abort (0=undef,1=pabort,2=dabort)
 368 0010 00000000 	__abort_mem:  .space (18 * 4), 0        @ Registers from abort state
 368      00000000 
 368      00000000 
 368      00000000 
 368      00000000 
 369 0058 00000000 	__abort_stk:  .space (8 * 4), 0         @ 8 stack entries from abort state
 369      00000000 
 369      00000000 
 369      00000000 
 369      00000000 
 370              	
 371              	@
 372              	@  Define globals so application can figure out what stacks are where.
 373              	@  Keep these in order!  The stack setup code expects it.
 374              	@
 375              	        .global __stack_beg_und
 376              	        .global __stack_end_und
 377              	        .global __stack_beg_abt
 378              	        .global __stack_end_abt
 379              	        .global __stack_beg_fiq
 380              	        .global __stack_end_fiq
 381              	        .global __stack_beg_irq
 382              	        .global __stack_end_irq
 383              	        .global __stack_beg_svc
 384              	        .global __stack_end_svc
 385              	        .global __stack_beg_sys
 386              	        .global __stack_end_sys
 387              	        .global __heap_max
 388              	        .global __heap_beg
 389              	        .global __heap_end
 390              	        .data
 391              	        .align  0
 392              	
 393 0000 00000000 	__stack_beg_und: .word 0                @ 0
 394 0004 00000000 	__stack_end_und: .word 0                @ 4
 395 0008 00000000 	__stack_beg_abt: .word 0                @ 8
 396 000c 00000000 	__stack_end_abt: .word 0                @ 12
 397 0010 00000000 	__stack_beg_fiq: .word 0                @ 16
 398 0014 00000000 	__stack_end_fiq: .word 0                @ 20
 399 0018 00000000 	__stack_beg_irq: .word 0                @ 24
 400 001c 00000000 	__stack_end_irq: .word 0                @ 28
 401 0020 00000000 	__stack_beg_svc: .word 0                @ 32
 402 0024 00000000 	__stack_end_svc: .word 0                @ 36
 403 0028 00000000 	__stack_beg_sys: .word 0                @ 40
 404 002c 00000000 	__stack_end_sys: .word 0                @ 44
 405 0030 00000000 	__heap_max:      .word 0                @ 48
 406 0034 00000000 	__heap_beg:      .word __heap_beg__
 407 0038 00000000 	__heap_end:      .word __heap_end__
 408              	
 409              	        .end
DEFINED SYMBOLS
                            *ABS*:00000000 crt.S
               crt.S:16     .text:00000000 $a
               crt.S:63     .text:00000000 start
               crt.S:42     *ABS*:00000004 UND_STACK_SIZE
               crt.S:43     *ABS*:00000004 ABT_STACK_SIZE
               crt.S:44     *ABS*:00000020 FIQ_STACK_SIZE
               crt.S:45     *ABS*:00000100 IRQ_STACK_SIZE
               crt.S:46     *ABS*:00000100 SVC_STACK_SIZE
               crt.S:51     *ABS*:00000010 MODE_USR
               crt.S:52     *ABS*:00000011 MODE_FIQ
               crt.S:53     *ABS*:00000012 MODE_IRQ
               crt.S:54     *ABS*:00000013 MODE_SVC
               crt.S:55     *ABS*:00000017 MODE_ABT
               crt.S:56     *ABS*:0000001b MODE_UND
               crt.S:57     *ABS*:0000001f MODE_SYS
               crt.S:59     *ABS*:00000080 I_BIT
               crt.S:60     *ABS*:00000040 F_BIT
               crt.S:61     *ABS*:00000020 T_BIT
               crt.S:64     .text:00000000 __start
               crt.S:65     .text:00000000 _mainCRTStartup
               crt.S:75     .text:00000010 .init_loop
               crt.S:80     .text:0000001c .end_init_loop
               crt.S:96     .text:0000003c .end_clear_loop
               crt.S:91     .text:00000030 .clear_loop
               crt.S:113    .text:00000060 .end_set_loop
               crt.S:107    .text:00000050 .set_loop
               crt.S:130    .text:00000084 .end_ints_loop
               crt.S:124    .text:00000074 .ints_loop
               crt.S:393    .data:00000000 __stack_beg_und
               crt.S:193    .startup:00000000 $a
               crt.S:205    .startup:00000020 _start
               crt.S:206    .startup:00000024 _undf
               crt.S:207    .startup:00000028 _swi
               crt.S:208    .startup:0000002c _pabt
               crt.S:209    .startup:00000030 _dabt
               crt.S:210    .startup:00000034 _fiq
               crt.S:205    .startup:00000020 $d
               crt.S:217    .startup:00000038 __undf
               crt.S:224    .startup:0000004c __pabt
               crt.S:231    .startup:00000060 __dabt
               crt.S:218    .startup:00000038 $a
               crt.S:368    .protected:00000010 __abort_mem
               crt.S:242    .startup:00000074 .abtstore
               crt.S:367    .protected:0000000c __abort_typ
               crt.S:365    .protected:00000004 __abort_sig
                            *ABS*:deadc0de ABORT_SIGIL
               crt.S:366    .protected:00000008 __abort_cnt
               crt.S:369    .protected:00000058 __abort_stk
               crt.S:278    .startup:000000dc .abtcopy
               crt.S:303    .startup:000000f0 .sysreset
               crt.S:289    *ABS*:0000000f SCB_RSIR_MASK
               crt.S:290    *ABS*:e01fc180 SCB_RSIR
               crt.S:291    *ABS*:e0000000 WD_MOD
               crt.S:292    *ABS*:e0000004 WD_TC
               crt.S:293    *ABS*:e0000008 WD_FEED
               crt.S:294    *ABS*:00000001 WD_MOD_WDEN
               crt.S:295    *ABS*:00000002 WD_MOD_RESET
               crt.S:296    *ABS*:00000004 WD_MOD_TOF
               crt.S:297    *ABS*:00000008 WD_MOD_INT
               crt.S:298    *ABS*:0000000f WD_MOD_MASK
               crt.S:299    *ABS*:000000aa WD_FEED_FEED1
               crt.S:300    *ABS*:00000055 WD_FEED_FEED2
               crt.S:336    .intvects:00000000 __intvects
               crt.S:336    .intvects:00000000 $a
               crt.S:345    .intvects:00000020 _ram_reset
               crt.S:346    .intvects:00000024 _ram_undf
               crt.S:347    .intvects:00000028 _ram_swi
               crt.S:348    .intvects:0000002c _ram_pabt
               crt.S:349    .intvects:00000030 _ram_dabt
               crt.S:350    .intvects:00000034 _ram_rsrvd
               crt.S:352    .intvects:0000003c _ram_fiq
               crt.S:345    .intvects:00000020 $d
               crt.S:351    .intvects:00000038 _ram_irq
               crt.S:364    .protected:00000000 __abort_dat
               crt.S:394    .data:00000004 __stack_end_und
               crt.S:395    .data:00000008 __stack_beg_abt
               crt.S:396    .data:0000000c __stack_end_abt
               crt.S:397    .data:00000010 __stack_beg_fiq
               crt.S:398    .data:00000014 __stack_end_fiq
               crt.S:399    .data:00000018 __stack_beg_irq
               crt.S:400    .data:0000001c __stack_end_irq
               crt.S:401    .data:00000020 __stack_beg_svc
               crt.S:402    .data:00000024 __stack_end_svc
               crt.S:403    .data:00000028 __stack_beg_sys
               crt.S:404    .data:0000002c __stack_end_sys
               crt.S:405    .data:00000030 __heap_max
               crt.S:406    .data:00000034 __heap_beg
               crt.S:407    .data:00000038 __heap_end
               crt.S:393    .data:00000000 $d
               crt.S:333    .startup:00000140 $d
               crt.S:192    .text:00000118 $d

UNDEFINED SYMBOLS
endless_loop
__data_beg__
__stack_end__
__bss_beg__
__bss_end__
__data_beg_src__
__data_end__
__intvects_beg__
__intvects_beg_src__
__intvects_end__
main
SWI_Routine
FIQ_Routine
__heap_beg__
__heap_end__
