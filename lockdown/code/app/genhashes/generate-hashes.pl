#!/usr/bin/perl
# pre-kernel-hash.pl:
# author(s): amit vasudevan (amitvasudevan@acm.org) 
# this script will generate SHA-1 hashes for 4K pages which execute before
# the windows kernel gets control:
# 1. ntldr real mode component
# 2. ntldr protected mode component
# 3. ntdetect.com
# 4. BIOS areas C0000-FFFFF


# some variables that will need to be tuned specific to the guest OS 
# this is for Windows 2003 SP1 installation
$os_systemroot = "/cygdrive/c/windows";
$os_bootdrive = "/cygdrive/c";

$windows_ntldr = "ntldr";
$windows_ntldr_pe_offset = 0x4E70;

$tempdir = "/tmp";
$hlistfull_filename = "../hashlist_full.dat";
$hlistpart_filename = "../hashlist_partial.dat";


################################################################################
system("echo '/* hashlist_full.dat is autogenerated */' > $hlistfull_filename");
system("echo '/* hashlist_partial.dat is autogenerated */' > $hlistpart_filename");

#system("dd if=$os_bootdrive/$windows_ntldr of=$tempdir/ntldr_pe bs=1 skip=$windows_ntldr_pe_offset");
&dumphashesforfile("/tmp/ntldr_pe");
#&dumphashesforfile("/cygdrive/T/windows/system32/wrkx86.exe");
recurse("/cygdrive/c/windows/");


sub recurse($) {
  my($path) = @_;
	local($status);
	
  ## append a trailing / if it's not there
  $path .= '/' if($path !~ /\/$/);

  ## print the directory being searched
  print $path,"\n";

  ## loop through the files contained in the directory
  for my $eachFile (glob($path.'*')) {

    ## if the file is a directory
    if( -d $eachFile) {
      ## pass the directory to the routine ( recursion )
      recurse($eachFile);
    } else {
      ## print the file ... tabbed for readability
      print "\t",$eachFile,"\n";
 			dumphashesforfile($eachFile);
    }
  }
}



#subroutine: given complete path to a file, if it is a PE, will dump both
#full and partial code page hashes
#return: 1 if the image is a PE and everything went well else 0 if image is not PE
#pre-defined vars used: tempdir, hlistfull_filename, hlistpart_filename
#assumption: hlistfull and hlistpart filenames have already been created
sub dumphashesforfile
{
	local(@lines);
	local($line, $totallines, $i, $ispe);
	local(@info);
	local($section_name, $section_vma, $section_size, $section_fileoffset);
		
	#$_[0] = arg1 = full path name to file
	$ispe = system("objdump -f $_[0] | grep 'pei-i386'");
	if ( $ispe != 0){
		return 0;
	}
	
	system("objdump -h $_[0] | awk -f pe_codesections_dump.awk > $tempdir/tmp.codesections");

	open(MYINPUTFILE, "< $tempdir/tmp.codesections"); 
	@lines = <MYINPUTFILE>; 
	close(MYINPUTFILE);
	$totallines = @lines;
	
	system("rm -rf $tempdir/tmp.codesections");
	
	for($i=0; $i < ($totallines/2); $i++){
		$line = $lines[$i];
		chomp($line);

		@info=split(/:/, $line);
		#/* section id, section name, section VMA, section size, section file offset*/
		$section_name= $info[1];
		$section_vma = $info[2];
		$section_size = $info[3];
		$section_fileoffset = $info[4];
		print "\t", "Full Hashes..." ,"\n";
 		system("./sha1 $_[0] $section_name $section_vma $section_size $section_fileoffset 0 >> $hlistfull_filename");
		print "\t", "Partial Hashes..." ,"\n";
		system("./sha1 $_[0] $section_name $section_vma $section_size $section_fileoffset 1 >> $hlistpart_filename");
	}

	return 1;
}